<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ToniBlog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-01-11T04:42:11.670Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>ToniXWD</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MIT6.8540(6.824) Lec05笔记: raft论文解读1：选举和日志</title>
    <link href="http://example.com/2024/01/11/MIT6.8540/Lec05%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/01/11/MIT6.8540/Lec05%E7%AC%94%E8%AE%B0/</id>
    <published>2024-01-11T01:33:25.000Z</published>
    <updated>2024-01-11T04:42:11.670Z</updated>
    
    <content type="html"><![CDATA[<p>本节课是介绍<code>Raft</code>共识算法的第一部分, 建议阅读<a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf">论文</a>, 如果要做<code>Lab</code>的话, 论文是一定要看的, 尤其是要吃透论文中的图2。</p><h1 id="1-引入-脑裂（split-brain）"><a href="#1-引入-脑裂（split-brain）" class="headerlink" title="1 引入: 脑裂（split brain）"></a>1 引入: 脑裂（split brain）</h1><p>脑裂的定义:</p><blockquote><p>当系统中的节点因为网络故障而无法相互通信时，可能会发生脑裂现象，即系统被分割成两个或多个互不连通的子集，每个子集都可能认为自己是完整的系统。</p></blockquote><p>在介绍<code>raft</code>算法之前, 课程首先总结了之前课程中的几个分布式应用程序的共性和潜在的问题:</p><ul><li><code>MapReduce</code>: 主节点管理<code>Map</code>和<code>Reduce</code>任务的派发和信息收集, 自始至终没有发生变化</li><li><code>GFS</code>: 主节点管理<code>Chunk</code>信息、租约管理等, 主节点通过日志的形式避免宕机后信息的丢失</li><li><code>VMware FT</code>: 通过一个原子测试完成<code>Primary</code>和<code>Backup</code>之间的切换</li></ul><p>以上讨论的问题都是主节点失效后系统能否正常工作的场景, 看起来<code>VMware FT</code>可以满足在一个服务器宕机后剩下的服务器也能正常运行的需求, 但这里仍然存在问题: <strong>其原子测试本身也是一个<code>Test-and-Set服务</code></strong></p><p>下图为课程中展示的案例:</p><p><img src="/../../images/Lec06-split.png" alt="split-brain"></p><p>因为<code>Test-and-Set服务</code>本身也算是一个分布式应用, 其也存在主从备份的概念, 因此会出现上图中描述 的场景:</p><ol><li><code>Primary</code>和<code>Backup</code>之间的网络出现问题, 都认为自己是唯一的服务节点</li><li><code>Primary</code>与<code>Test-and-Set Server1</code>之间网络正常, 与<code>Test-and-Set Server2</code>之间网络不正常; <code>Backup</code>与<code>Test-and-Set Server1</code>之间网络不正常, 与<code>Test-and-Set Server2</code>之间网络正常</li><li><code>Primary</code>和<code>Backup</code>的<code>Test-and-Set</code>测试都成功了, 此时存在2个上线的服务器, 这就是一种<strong>脑裂</strong>现象</li></ol><p>以上的问题是一种<strong>脑裂</strong>现象, 因为<code>Primary</code>和<code>Backup</code>之间出现了网络分区, 每个区域之间不能彼此访问。</p><p><strong>补充:另外二者对脑裂现象的处理</strong>:</p><ul><li><code>MapReduce</code>中没有提及解决方案</li><li><code>GFS</code>的主节点会将关键的元数据信息存储在持久化的操作日志中，这个日志会被复制到多个地方，确保其可用性。如果发生网络分区，那么分布在不同分区的节点可能无法与主节点通信，但<code>GFS</code>的设计允许系统在某种程度的网络分区后仍然能够继续操作，只要分区中有足够的副本存在。</li></ul><h1 id="2-多数投票（Majority-Vote）"><a href="#2-多数投票（Majority-Vote）" class="headerlink" title="2 多数投票（Majority Vote）"></a>2 多数投票（Majority Vote）</h1><p>以上的问题在于不同的网络分区并不知道自己是否在别的网络分区工作的同时也在工作， 为了解决这个问题， <code>raft</code>算法提出了<code>Majority Vote</code>: <strong>任何决策必须要求过半的节点的投票支持</strong>。这是<code>Raft</code>最基本的一个概念, 而且这个概念还有一个重要的前提: <strong>节点数量必须是奇数</strong></p><p>因为如果是奇数的节点构成的分布式应用, 至多只有一个数量过半的网络分区, 因此至多只有一个网络分区能够完成正常的决策工作, 避免了脑裂。同时， 这个机制还表达了<code>raft</code>的容错能力: <strong>至多允许一半的节点异常</strong>。</p><h1 id="3-raft的运行案例"><a href="#3-raft的运行案例" class="headerlink" title="3 raft的运行案例"></a>3 raft的运行案例</h1><p>课程中为了展示<code>raft</code>在实际应用中如何工作, 给出了<code>lab3</code>中将实现的<code>kv存储</code>的例子:</p><p><img src="/../../images/Lec06-raft-kv.png" alt="raft-kv"></p><ol><li>客户端请请求(<code>Get</code>或<code>Put</code>)发送给<code>Leader</code>的服务层</li><li><code>Leader</code>的服务层将这个<code>Get</code>或<code>Put</code>命令向下发送到<code>Raft</code>层</li><li><code>Raft</code>层将操作封装成日志发送给多个<code>Follower</code>的<code>Raft</code>层</li><li><code>Follower</code>的<code>Raft</code>层复制日志后回复</li><li><code>Leader</code>的<code>Raft</code>层收到过半节点回复后, 向上发送一个通知到应用程序表示真正的执行这个操作了。</li><li><code>Leader</code>的服务执行命令改变自身<code>Table</code>的状态, 并回复给客户端执行结果</li><li><code>Follower</code>的应用层也应用<code>Raft</code>层的日志改变自身<code>Table</code>的状态(这里需要<code>Leader</code>告知哪些<code>log</code>是<code>commited</code>, 通常是通过心跳告知, 图中未画出, 而且这个操作通常有延迟, 客户端不需要等待这个操作完成)</li></ol><p><strong>接口函数说明</strong></p><ol><li><code>Start</code>函数<br>应用程序通过<code>Start</code>函数将一个操作传递给<code>Raft</code>层，返回值包括，这个请求将会存放在<code>Log</code>中的索引(如果成功<code>commit</code>的话)</li><li><code>applyCh channel</code><br>当之前请求的操作<code>commit</code>之后, 通过<code>applyCh channel</code>向应用程序发出消息通知, 应用程序读取这个消息。</li></ol><p>具体而言, 客户端调用应用层的<code>RPC</code>，应用层收到<code>RPC</code>之后，会调用<code>Start</code>函数，<code>Start</code>函数会立即返回，但是这时，应用层不会返回消息给客户端，因为它还没有执行客户端请求，它也不知道这个请求是否会被<code>Raft</code>层<code>commit</code>。只有在某一时刻，对应于这个客户端请求的消息在<code>applyCh channel</code>中出现, 应用层才会执行这个请求，并返回响应给客户端。</p><h1 id="4-Log"><a href="#4-Log" class="headerlink" title="4 Log"></a>4 Log</h1><p><code>Raft</code>中的<code>Log</code>会被添加到节点的<code>Log数组</code>中, 每一个<code>Log</code>包含了以下内容:</p><ul><li>具体的命令, 取决于应用</li><li>任期<code>Term</code>, 用于判断这个<code>Log</code>是否有效</li></ul><p><code>Leader</code>节点需要维护每个<code>Follower</code>的<code>Log</code>状态:</p><ol><li>目前已经复制的<code>Log</code>在数组中的索引</li><li>下一个追加的<code>Log</code>应该从哪个索引开始</li></ol><p>同时<code>Leader</code>也需要维护全局的日志状态:</p><ul><li>目前已经提交的<code>Log</code>在日志数组中的索引</li></ul><p><code>Log</code>有3大作用:</p><ol><li>用于<code>Leader</code>和<code>Follower</code>之间的同步</li><li>包含命令用以改变应用程序的状态</li><li>每个<code>Raft</code>节点都需要将<code>Log</code>写入到它的磁盘中, 因此<code>Log</code>还可以被<code>Raft</code>节点用来从头执行其中的操作进而重建故障前的状态</li></ol><p><strong>重启后<code>Leader</code>如何利用<code>Log</code>进行恢复?</strong></p><ol><li>首先重启后进行<code>Leader</code>选举，其中一个节点被选为<code>Leader</code></li><li><code>Leader</code>通过心跳来确定目前已经提交的日志的索引位置</li><li>在这个索引位置以前, 所有的节点的日志是相同的, 可以应用到自身的状态机</li><li>在这个索引位置以后, <code>Leader</code>迫使其他所有副本的<code>Log</code>与自己保持一致</li></ol><h1 id="5-Leader选举"><a href="#5-Leader选举" class="headerlink" title="5 Leader选举"></a>5 Leader选举</h1><h2 id="5-1-选举机制"><a href="#5-1-选举机制" class="headerlink" title="5.1 选举机制"></a>5.1 选举机制</h2><p>每一个运行的<code>raft</code>节点都包含一个任期号(<code>Term</code>), 每个任期只能有一个<code>Leader</code>。</p><p>如何保证每个任期只能有一个<code>Leader</code>？</p><p>首先， 每一个运行的<code>raft</code>节点只能是如下几个角色之一：</p><ul><li><code>Leader</code></li><li><code>Follower</code></li><li><code>Candidate</code></li></ul><p>每个<code>Raft</code>节点都有一个选举定时器, 每次收到心跳<code>RPC</code>或追加<code>log</code>的<code>RPC</code>(都通过<code>AppendEntries</code>)时, 都将重置这个选举定时器, 在选举定时器没有到期时, 发出<code>AppendEntries</code>的节点是<code>Leader</code>, 接收<code>AppendEntries</code>的节点是<code>Follower</code>, 一旦因为没有接收到消息导致选举定时器到期, 节点转化为<code>Candidate</code>并进行投票选举。</p><p>每一次选举会增加<code>Term</code>，通过<code>RequestVote</code>向其他节点寻求投票, 由于节点数量是奇数, 而投票选举成功要求过半的投票, 因此只有一个<code>Leader</code>将在一个特定的<code>Term</code>内选举成功。</p><p>拿到过半投票的<code>Leader</code>将通过心跳告知新<code>Leader</code>的诞生, 如果没有这样的节点, 则再次自增<code>Term</code>进行新一轮的选举。</p><h2 id="5-2-避免选票分裂"><a href="#5-2-避免选票分裂" class="headerlink" title="5.2 避免选票分裂"></a>5.2 避免选票分裂</h2><p>因为每个<code>Candidate</code>都会给自己投票, 因此如果所有的<code>Follower</code>同时转化为<code>Candidate</code>并发起选举, 结果一定是各自一张投票, 形成了选票分裂(<code>Split Vote</code>), 并且恶心循环地再次进行新一轮选举。</p><p>为了避免这种情况，不同的服务器都应该选取随机的超时时间。先超时的节点有更大的概率获得更多的选票，因此避免了多次选票分裂的情况。</p><blockquote><p>PS: 选举超时的设定要求: 至少大于<code>Leader</code>的心跳间隔, 否则该节点会在收到正常的心跳之前触发选举</p></blockquote><h2 id="5-3-Raft未考虑的情形-单向网络故障"><a href="#5-3-Raft未考虑的情形-单向网络故障" class="headerlink" title="5.3 Raft未考虑的情形: 单向网络故障"></a>5.3 <code>Raft</code>未考虑的情形: 单向网络故障</h2><p>以下的情形会导致<code>Raft</code>不能正常工作:</p><ol><li><code>Leader</code>可以发出心跳，但是又不能收到任何客户端请求</li><li><code>Leader</code>的心跳会抑制其他服务器开始一次新的选举</li></ol><p>以上情形将导致客户端请求永远不被执行, 教授提出的解决方案是:<strong>通过一个双向的心跳解决</strong>: </p><ol><li><code>Follower</code>需要回复心跳</li><li>如果<code>Leader</code>一段时间没有收到自己发出心跳的回复，将让出<code>Leader</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本节课是介绍&lt;code&gt;Raft&lt;/code&gt;共识算法的第一部分, 建议阅读&lt;a href=&quot;https://pdos.csail.mit.edu/6.824/papers/gfs.pdf&quot;&gt;论文&lt;/a&gt;, 如果要做&lt;code&gt;Lab&lt;/code&gt;的话, 论文是一定要看的,</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Raft" scheme="http://example.com/tags/Raft/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.8540(6.824) Lec04笔记: vm-ft论文解读</title>
    <link href="http://example.com/2024/01/07/MIT6.8540/Lec04%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2024/01/07/MIT6.8540/Lec04%E7%AC%94%E8%AE%B0/</id>
    <published>2024-01-07T08:47:33.000Z</published>
    <updated>2024-01-08T05:46:37.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-整体介绍"><a href="#1-整体介绍" class="headerlink" title="1 整体介绍"></a>1 整体介绍</h1><p>论文介绍了一种在虚拟机上实现的备份系统的设计: <strong>VMWare Fault-tolerant</strong>, 使用了较小的带宽, 支持在远距离实现容错。该实现是基于<strong>状态机</strong>的。</p><p>传统的主从备份的复制方法称为<strong>状态转移</strong>（State Transfer），备份服务器几乎连续地将主服务器的所有状态更改进行传输到备份服务器，包括CPU、内存和I&#x2F;O设备的更改。然而，发送这些状态所需的带宽，特别是内存中的变化，可能非常大。</p><p>本文使用了<strong>复制状态机</strong>（Replicated State Machine）以减小带宽需求，其思想是将服务器建模为<strong>确定性状态机</strong>，通过从相同的初始状态开始，并确保它们以相同的顺序接收相同的输入请求来保持同步。</p><p>本质来说, <strong>状态转移</strong>是复制主节点内存或寄存器中的内容, <strong>复制状态机</strong>是传输来自客户端的操作或其他外部事件。使用复制状态机的主要原因是，外部操作或事件通常比服务的状态要小很多。</p><p>但是大多数服务器或服务存在一些非确定性操作，因此必须使用额外的协调来确保主服务器和备份服务器保持同步。对于物理机而言，实现确定性执行的协调非常困难。因此，论文将<strong>VM虚拟机</strong>定义为一个定义状态机。尽管<strong>VM虚拟机</strong>也有一些非确定性操作，但可以通过宿主对VM的执行有完全的控制权，包括所有输入的传递，它能够捕获主VM上非确定性操作的所有必要信息，并在<strong>备份VM</strong>上正确地重放这些操作。</p><blockquote><p>为什么非确定性操作需要额外的协调机制?<br>例如: 获取时间这个指令, 在主节点和副本上, 即使指令和内存相同, 其结果页不一样。类似的情形还包括：获取<code>CPU</code>的<code>ID</code><br>对这种情况, 解决方案是主节点直接将这些指令的执行结果发送给副本, 副本不执行指令, 接收主节点的结果</p></blockquote><p>接下来是几个论文中定义的概念：</p><ol><li><strong>状态机</strong>：将服务器建模为确定性状态机，从相同的初始状态开始，并确保它们以相同的顺序接收相同的输入请求来保持同步</li><li><strong>确定性重放</strong>：能够记录主服务器的执行并确保备份服务器执行相同的基础技术</li><li><strong>虚拟锁步状态</strong>：2个<strong>VM</strong>构成的容错虚拟机，<strong>主VM</strong>的操作会在<strong>备份VM</strong>上再次执行</li></ol><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>目前为止, 论文讨论的都是单核CPU的场景, 因为多核处理器指令间的交互很复杂</p><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>本论文的复制和之前提到过的<code>GFS</code>的复制有什么区别?</p><blockquote><p><code>GFS</code>没有复制内存中的每一个bit，它复制的更多是应用程序级别的<code>Chunk</code>, 而<code>VMware FT</code>是从底层开始的复制, 复制的是寄存器和内存</p></blockquote><h1 id="2-基本架构"><a href="#2-基本架构" class="headerlink" title="2 基本架构"></a>2 基本架构</h1><h2 id="2-1-基本配置"><a href="#2-1-基本配置" class="headerlink" title="2.1 基本配置"></a>2.1 基本配置</h2><p>下图所示为<strong>容错虚拟机VM</strong>的基本设置。左边是<strong>主VM</strong>，右边是<strong>备份VM</strong>，他们运行在不同的物理服务器上。<strong>备份VM</strong>与<strong>主VM</strong>保持同步并执行相同的操作，尽管会有小的时间延迟。工作时，只有主VM在网络上宣告其存在，即只有<strong>主VM</strong>产生实际的输出并返回给客户端，<strong>备份VM</strong>的输出被丢弃。<strong>主VM</strong>接收的所有输入都通过一个称为<code>logging channel</code>的通道发送给<strong>备份VM</strong>。</p><p>系统使用服务器之间的<strong>心跳</strong>和对<code>logging channel</code>的监控来判断是否有<code>VM</code>宕机。</p><p><img src="/../../images/Basic-FT-Configuration.png" alt="Basic-FT-Configuration"></p><h2 id="2-2-确定性重放实现"><a href="#2-2-确定性重放实现" class="headerlink" title="2.2 确定性重放实现"></a>2.2 确定性重放实现</h2><p><code>VM</code>的输入包括了常规的输入和<strong>非确定性输入</strong>, 常规的输入包括:网络数据、磁盘数据、键盘和鼠标输入等， <strong>非确定性输入</strong>主要包括虚拟中断和非确定性操作。</p><p><strong>确定性重放</strong>将一个<code>VM</code>的输入和所有与<code>VM</code>执行相关的可能的非确定性输入都写入到日志文件中。通过从文件中读取日志条目，可以稍后完全精确地重放<code>VM</code>执行。对于非确定性事件，如<strong>定时器</strong>或<strong>IO中断</strong>，其确切指令也被记录下来。在重放期间，事件在指令流中的相同点被传递。</p><h2 id="2-3-对外输出的规则"><a href="#2-3-对外输出的规则" class="headerlink" title="2.3 对外输出的规则"></a>2.3 对外输出的规则</h2><p>下图为摘自论文中, 展示了<code>FT Protocol</code>:</p><blockquote><p><strong>主VM</strong>在等待<strong>备份VM</strong>回复日志写入成功后才向外输出</p></blockquote><p>这样的目的是使得<strong>备份VM</strong>收到输出操作之前生成的所有日志条目, 因此如果输出之后<strong>主VM</strong>宕机, <strong>备份VM</strong>具有重放<strong>主VM</strong>宕机前所有指令的能力, 在重放操作完成后就可以上线替代原来的<strong>主VM</strong>。</p><p>为了做到一点，要在每次输出操作时创建一个特殊的日志条目， 然后<strong>主VM</strong>就会在这个特殊条目的回复到达前等待。</p><p><img src="/../../images/FT-Protocol.png" alt="FT-Protocol"></p><h2 id="2-4-故障检测与备份VM上线"><a href="#2-4-故障检测与备份VM上线" class="headerlink" title="2.4 故障检测与备份VM上线"></a>2.4 故障检测与备份VM上线</h2><p>在<strong>备份VM</strong>上线前, 还缺少一个关键点：<strong>如何判断<code>主VM</code>故障？</strong></p><p>这个问题其实是如何处理备份落后的问题, 因为<code>主VM</code>接收客户端的命令, 因此<code>备份VM</code>一定是滞后的。要确保故障发生时, <code>备份VM</code>已经跟上了<code>主VM</code>。</p><p>最容易想到的方案是监控管道中日志的流量和二者之间的心跳, 到那时这都会导致<strong>脑裂问题</strong>: <strong>主VM</strong>与<strong>备份VM</strong>之前的网络发生故障, 但客户端与二者之间的网络正常, 因此导致数据损坏和与<code>VM</code>通讯的客户端出现问题。问题发关键在于确保：<strong>只有<code>主VM</code>或<code>备份VM</code>中的一个变为活动状态</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>使用<strong>共享存储</strong>。当<strong>主VM</strong>或<strong>备份VM</strong>想要变为活动时，它在共享存储上执行一个原子测试并设置操作。如果操作成功，允许VM变为活动。如果操作失败，那么另一台<code>VM</code>必须已经变为活动状态，因此当前<code>VM</code>实际上会自行停止（“自杀”）。</p><p>具体而言，这个原子测试被称为<strong>Test-and-Set 服务</strong>，当其收到一个<code>Test-and-Set</code>请求，它会设置标志位，并且返回旧的值。这很像锁的实现。</p><h1 id="3-非确定性事件的处理"><a href="#3-非确定性事件的处理" class="headerlink" title="3 非确定性事件的处理"></a>3 非确定性事件的处理</h1><h2 id="3-1-什么是非确定性事件"><a href="#3-1-什么是非确定性事件" class="headerlink" title="3.1 什么是非确定性事件?"></a>3.1 什么是非确定性事件?</h2><p><strong>再次解析: 什么是非确定性事件?</strong></p><blockquote><p>不由当前内存直接决定的指令, 其在<code>Primary</code>和<code>Backup</code>的运行结果可能会不一样。这些指令就是所谓的非确定性事件。</p></blockquote><h2 id="3-2-非确定性事件分类"><a href="#3-2-非确定性事件分类" class="headerlink" title="3.2 非确定性事件分类"></a>3.2 非确定性事件分类</h2><ol><li>客户端输入<br>为什么客户端输入是非确定性事件? 因为客户端的输入实际上是网络报文。网络报文的数据会被网卡的<code>DMA</code>拷贝到内存，之后触发一个中断。尽管这个过程在<code>Primary</code>和<code>Backup</code>中是一样的， 但中断触发的时间是不确定的（大概率不一样），因此中断的触发打乱了指令流</li><li>特殊指令<ol><li>日期相关指令</li><li>随机数相关指令</li><li>获取<code>CPU ID</code>等类似的硬件相关的指令</li></ol></li><li>多核场景<br>指令在多个<code>CPU</code>上会交错运行，其指令顺序不可预期(目前不考虑次场景)<blockquote><p>PS: 这里的多核指的是<code>Primary</code>和<code>Backup</code>虚机操作系统的硬件是单核的, <code>VMM</code>以下的硬件一定是多核的</p></blockquote></li></ol><h2 id="3-3-日志设计"><a href="#3-3-日志设计" class="headerlink" title="3.3 日志设计"></a>3.3 日志设计</h2><p>日志设计可以处理以上的非确定性事件分类, 日志应当包含如下内容:</p><ol><li>事件发生时的指令序号<br><code>Backup</code>按照指令序号执行命令</li><li>日志条目的类型<br>可以判断这个指令是不是非确定性事件</li><li>数据</li></ol><p>课程中的例子是这样的:</p><blockquote><p>Primary和Backup两个虚机内部的guest操作系统需要在模拟的硬件里有一个定时器，能够每秒触发100次中断，这样操作系统才可以通过对这些中断进行计数来跟踪时间。因此，这里的定时器必须在Primary和Backup虚机的完全相同位置产生中断，否则这两个虚机不会以相同的顺序执行指令，进而可能会产生分歧。所以，在运行了Primary虚机的物理服务器上，有一个定时器，这个定时器会计时，生成定时器中断并发送给VMM。在适当的时候，VMM会停止Primary虚机的指令执行，并记下当前的指令序号，然后在指令序号的位置插入伪造的模拟定时器中断，并恢复Primary虚机的运行。之后，VMM将指令序号和定时器中断再发送给Backup虚机。虽然Backup虚机的VMM也可以从自己的物理定时器接收中断，但是它并没有将这些物理定时器中断传递给Backup虚机的guest操作系统，而是直接忽略它们。当来自于Primary虚机的Log条目到达时，Backup虚机的VMM配合特殊的CPU特性支持，会使得物理服务器在相同的指令序号处产生一个定时器中断，之后VMM获取到这个中断，并伪造一个假的定时器中断，并将其送入Backup虚机的guest操作系统，并且这个定时器中断会出现在与Primary相同的指令序号位置。</p></blockquote><h1 id="4-如何避免重复输出"><a href="#4-如何避免重复输出" class="headerlink" title="4 如何避免重复输出"></a>4 如何避免重复输出</h1><p>考虑以下的场景:</p><ol><li><code>Primary</code>在客户端收到了回复后崩溃</li><li><code>Backup</code>上线, 但其还没有处理完缓冲区的<code>log</code></li><li><code>Backup</code>处理完<code>log</code>后, 由于自己已经上线, 其将输出发送给客户端</li><li>客户端收到了2个相同的输出</li></ol><p>几乎所有的分布式场景都会遇到类似以上的重复输出的问题, 常规的解决方法是在客户端形成一套重复检测机制。</p><p>在<code>VMWare FT</code>中, 客户端通过<code>TCP</code>与服务进行交互, 而<code>Backup</code>由于与<code>Primary</code>状态相同, 其<code>TCP</code>报文也具有相同的序列号, 因此<code>VMWare FT</code>可以在客户端通过<code>TCP</code>简单地实现去重。</p><h1 id="5-具体案例说明"><a href="#5-具体案例说明" class="headerlink" title="5 具体案例说明"></a>5 具体案例说明</h1><p>下图为从<code>Lecture04</code>中总结出来的一个命令被执行的流程示意图</p><p><img src="/../../images/VMWare-FT-process.png" alt="VMWare-FT-process"></p><ul><li><strong>结构介绍</strong></li></ul><ol><li><code>primary</code>和<code>backup</code>各自运行在不同的服务器的<code>VMM</code>上</li><li><code>primary</code>, <code>backup</code>以及<code>client</code>都运行在同一个局域网</li><li><code>VMware FT</code>里的多副本服务没有使用本地盘，而是使用了一些<code>Disk Server</code>（远程盘）</li><li><code>primary</code>和<code>backup</code>之间通信的通道称为<code>Log Channel</code></li></ol><ul><li><strong><code>client</code>执行命令的流程</strong></li></ul><ol><li><code>client</code>发送包含命令的数据包</li><li>数据包服务器上被收到, 产生一个中断被<code>primary</code>的<code>VMM</code>捕获</li><li><code>primary</code>的<code>VMM</code>捕获到中断后, 进行如下两项操作<ol><li>在自己虚拟化的<code>OS</code>中, 模拟网络数据包到达的中断</li><li>将网络数据包拷贝一份，并通过<code>Log Channel</code>送给<code>Backup</code>虚机所在的<code>VMM</code></li></ol></li><li><code>Backup</code>虚机所在的<code>VMM</code>收到数据包, 同样在自己虚拟化的<code>OS</code>中, 模拟网络数据包到达的中断</li><li><code>primary</code>和<code>backup</code>执行数据包中的命令</li><li><code>primary</code>产生回复报文, 通过<code>VMM</code>返回给客户端</li><li><code>Backup</code>只是将回复简单的丢弃掉</li></ol><p><strong>网卡驱动在这里做啥什么事?</strong><br>网卡会将网络数据包拷贝给<code>VMM</code>的内存，之后，网卡中断会送给<code>VMM</code>, 然后由<code>VMM</code>负责如何处理这个中断和数据, 例如:</p><ol><li>暂停Primary虚机，记住当前的指令序号，将整个网络数据包拷贝给<code>Primary</code>虚机的内存，</li><li>之后模拟一个网卡中断发送给<code>Primary</code>虚机。</li><li>同时，将网络数据包和指令序号发送给<code>Backup</code>。<code>Backup</code>虚机的<code>VMM</code>也会在对应的指令序号暂停<code>Backup</code>虚机，将网络数据包拷贝给<code>Backup</code>虚机，之后在相同的指令序号位置模拟一个网卡中断发送给<code>Backup</code>虚机</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-整体介绍&quot;&gt;&lt;a href=&quot;#1-整体介绍&quot; class=&quot;headerlink&quot; title=&quot;1 整体介绍&quot;&gt;&lt;/a&gt;1 整体介绍&lt;/h1&gt;&lt;p&gt;论文介绍了一种在虚拟机上实现的备份系统的设计: &lt;strong&gt;VMWare Fault-tolerant&lt;</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="VMWare FT" scheme="http://example.com/tags/VMWare-FT/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.8540(6.824) Lab2: Raft 2B</title>
    <link href="http://example.com/2024/01/06/MIT6.8540/Lab2_Raft_2B/"/>
    <id>http://example.com/2024/01/06/MIT6.8540/Lab2_Raft_2B/</id>
    <published>2024-01-06T09:17:01.000Z</published>
    <updated>2024-01-07T08:15:14.967Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍<code>lab2B</code>部分的实现, <code>lab2B</code>要求实现<code>raft</code>中的日志复制和提交两部分的内容, 相比<code>lab2A</code>, <code>lab2B</code>的<code>Hint</code>更少, 难度也相对较大。</p><p><code>Lab文档</code>见: <a href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html">https://pdos.csail.mit.edu/6.824/labs/lab-raft.html</a></p><p>我的2A部分的实现在<a href="/2024/01/01/MIT6.8540/Lab2_Raft_2A/">这里</a> </p><p><a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">raft原论文</a></p><p>我的代码:</p><ul><li>时间戳实现: <a href="https://github.com/ToniXWD/MIT6.8540/tree/lab2B">https://github.com/ToniXWD/MIT6.8540/tree/lab2B</a></li><li>timer实现: <a href="https://github.com/ToniXWD/MIT6.8540/tree/lab2B-timer">https://github.com/ToniXWD/MIT6.8540/tree/lab2B-timer</a></li></ul><h1 id="1-2A部分的bug修复"><a href="#1-2A部分的bug修复" class="headerlink" title="1 2A部分的bug修复"></a>1 2A部分的bug修复</h1><h2 id="1-1-修复孤立节点被选举的bug"><a href="#1-1-修复孤立节点被选举的bug" class="headerlink" title="1.1 修复孤立节点被选举的bug"></a>1.1 修复孤立节点被选举的bug</h2><ul><li><strong>问题追溯</strong><br><code>2A</code>部分中, <code>RequestVote</code>中允许投票的判断我的实现是这样的:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rf.votedFor == <span class="number">-1</span> || rf.votedFor == args.CandidateId &#123;</span><br><span class="line">    <span class="comment">// 首先确保是没投过票的</span></span><br><span class="line">    <span class="keyword">if</span> args.Term &gt; rf.currentTerm ||</span><br><span class="line">        (args.LastLogIndex &gt;= <span class="built_in">len</span>(rf.log)<span class="number">-1</span> &amp;&amp; args.LastLogTerm &gt;= rf.log[<span class="built_in">len</span>(rf.log)<span class="number">-1</span>].Term) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在调试<code>2B</code>的时候, 遇到了已经<code>committed</code>的信息丢失的问题, 问题就在于上述的代码, 其判断统一投票的逻辑为:</li></ul><ol><li>首先要求其没有投过票或者投票对象就是这个<code>RPC</code>请求发起者</li><li>如果<code>args.Term &gt; rf.currentTerm</code>投票, 也就是投票者有更新的<code>term</code></li><li>如果<code>term</code>相同, 则只有请求者的<code>log</code>至少和自己一样长, 并且<code>LastLogTerm </code>也至少和自己的最后一个<code>log</code>的<code>term</code>一样新, 才投票</li></ol><p>这样的实现会导致以下的情况:</p><ol><li>某一时刻一个<code>server</code>网络出现了问题(称其为<code>S</code>), 其自增currentTerm后发出选举， 经过多次选举超时后其<code>currentTerm</code>已经远大于离开集群时的<code>currentTerm</code></li><li>后来网络恢复了正常, 这时其他的服务器收到了<code>S</code>的选举请求, 这个选举请求有更新的term, 因此都同意向它投票, <code>S</code>成为了最新的<code>leader</code></li><li>由于<code>S</code>离开集群时集群其他的服务器已经提交了多个<code>log</code>, 这些提交在<code>S</code>中不存在, 而<code>S</code>信任自己的<code>log</code>, 并将自己的<code>log</code>复制到所有的<code>follower</code>上, 这将覆盖已经提交了多个<code>log</code>, 导致了错误</li></ol><ul><li><strong>bug修改</strong><br>因此, 重新审视<code>raft</code>论文中<code>Figure 2</code>的描述:<blockquote><p>Receiver implementation:</p><ol><li>Reply false if term &lt; currentTerm (§5.1)</li><li>If votedFor is null or candidateId, and candidate’s log is at least as up-to-date as receiver’s log, grant vote (§5.2, §5.4)</li></ol></blockquote></li></ul><p>这里的日志至少一样新指的并不是<code>raft</code>结构体中的<code>currentTerm</code>, 而是指的<code>log</code>中最后一项的<code>Term</code>, 因此需要将<code>if</code>判断条件修改为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> rf.votedFor == <span class="number">-1</span> || rf.votedFor == args.CandidateId &#123;</span><br><span class="line">    <span class="comment">// 首先确保是没投过票的</span></span><br><span class="line">    <span class="keyword">if</span> args.LastLogTerm &gt; rf.log[<span class="built_in">len</span>(rf.log)<span class="number">-1</span>].Term ||</span><br><span class="line">        (args.LastLogTerm == rf.log[<span class="built_in">len</span>(rf.log)<span class="number">-1</span>].Term &amp;&amp; args.LastLogIndex &gt;= <span class="built_in">len</span>(rf.log)<span class="number">-1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>PS: 为什么这么显眼的错误能通过<code>2A</code>的测例…</em></p><h2 id="1-2-修复currentTerm的追赶问题"><a href="#1-2-修复currentTerm的追赶问题" class="headerlink" title="1.2 修复currentTerm的追赶问题"></a>1.2 修复<code>currentTerm</code>的追赶问题</h2><p>还是<code>RequestVote</code>中的bug:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">    <span class="comment">// 已经是新一轮的term, 之前的投票记录作废</span></span><br><span class="line">    rf.votedFor = <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在收到其他节点的投票申请后, 如果当前的<code>Term</code>更小, 则撤销以前任期的投票记录, 改为未投票, 这将导致后续的<code>if</code>判断满足第一个投票条件: <code>首先要求其没有投过票或者投票对象就是这个RPC请求发起者</code>, 但除了撤销以前任期的投票记录外, 还应该将自身转化为<code>Follower</code>, 同时直接将<code>Term</code>更新到<code>args.Term</code></p><p>为什么之前的实现忽略了这些呢? 因为在之前的实现中, 预想中的角色的转化是发生在接受到心跳后。换言之， 需要等待新的<code>leader</code>产生后通过心跳函数来完成之前在<code>RequestVote</code>中出现<code>args.Term &gt; rf.currentTerm</code>的节点的角色转换, 但是问题在于可能存在<strong>孤立节点</strong>, 因为<strong>孤立节点</strong>的<code>log</code>中的最后一项的<code>Term</code>很小, 但由于多次的选举超时, 其<code>currentTerm</code>很大, 而新的<code>leader</code>产生后通过心跳函数来完成某个节点角色切换为<code>follower</code>的前提是<code>term</code>更大*, 因此如果<strong>孤立节点</strong>的<code>currentTerm</code>很大, 需要新的<code>leader</code>经过非常多次的选举, 因为每次选举自增的<code>currentTerm</code>为1, 这将导致很长且并不要的时间消耗</p><p>所以, 修改过后的代码为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line">    <span class="comment">// 已经是新一轮的term, 之前的投票记录作废</span></span><br><span class="line">    rf.votedFor = <span class="number">-1</span></span><br><span class="line">    rf.currentTerm = args.Term <span class="comment">// 易错点, 需要将currentTerm提升到最新的term</span></span><br><span class="line">    rf.role = Follower</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-论文解读-日志复制和commit部分"><a href="#2-论文解读-日志复制和commit部分" class="headerlink" title="2 论文解读: 日志复制和commit部分"></a>2 论文解读: 日志复制和commit部分</h1><p>日志复制的逻辑如下:</p><ul><li><strong><code>leader</code>视角</strong></li></ul><ol><li><code>client</code>想集群的一个节点发送的命令, 如果不是<code>leader</code>, <code>follower</code>会通过心跳得知<code>leader</code>并返回给<code>client</code></li><li><code>leader</code>收到了命令, 将其构造为一个日志项, 添加当前节点的<code>currentTerm</code>为日志项的<code>Term</code>, 并将其追加到自己的<code>log</code>中</li><li><code>leader</code>发送<code>AppendEntries RPC</code>将<code>log</code>复制到所有的节点, <code>AppendEntries RPC</code>需要增加<code>PrevLogIndex</code>、<code>PrevLogTerm</code>以供<code>follower</code>校验, 其中<code>PrevLogIndex</code>、<code>PrevLogTerm</code>由<code>nextIndex</code>确定</li><li>如果<code>RPC</code>返回了成功, 则更新<code>matchIndex</code>和<code>nextIndex</code>, 同时寻找一个满足过半的<code>matchIndex[i] &gt;= N</code>的索引位置<code>N</code>, 将其更新为自己的<code>commitIndex</code>, 并提交直到<code>commitIndex</code>部分的日志项</li><li>如果<code>RPC</code>返回了失败, 且伴随的的<code>Term</code>更大, 表示自己已经不是<code>leader</code>了, 将自身的角色转换为<code>Follower</code>, 并更新<code>currentTerm</code>和<code>votedFor</code>, 重启计时器</li><li>如果<code>RPC</code>返回了失败, 且伴随的的<code>Term</code>和自己的<code>currentTerm</code>相同, 将<code>nextIndex</code>自减再重试</li></ol><ul><li><strong><code>follower</code>视角</strong></li></ul><ol><li><code>follower</code>收到<code>AppendEntries RPC</code>后,<code>currentTerm</code>不匹配直接告知更新的<code>Term</code>, 并返回<code>false</code></li><li><code>follower</code>收到<code>AppendEntries RPC</code>后, 通过<code>PrevLogIndex</code>、<code>PrevLogTerm</code>可以判断出”<code>leader</code>认为自己<code>log</code>的结尾位置”是否存在并且<code>Term</code>匹配, 如果不匹配, 返回<code>false</code>并不执行操作;</li><li>如果上述位置的信息匹配, 则需要判断插入位置是否有旧的日志项, 如果有, 则向后将<code>log</code>中冲突的内容清除</li><li>将<code>RPC</code>中的日志项追加到<code>log</code>中</li><li>根据<code>RPC</code>的传入参数更新<code>commitIndex</code>, 并提交直到<code>commitIndex</code>部分的日志项</li></ol><h1 id="3-设计思路"><a href="#3-设计思路" class="headerlink" title="3 设计思路"></a>3 设计思路</h1><h2 id="3-1-心跳和AppendEntries的区别"><a href="#3-1-心跳和AppendEntries的区别" class="headerlink" title="3.1 心跳和AppendEntries的区别?"></a>3.1 心跳和<code>AppendEntries</code>的区别?</h2><p>根据<code>2A</code>的内容可知, 心跳就是一种特殊的<code>AppendEntries</code>, 其特殊在<code>Entries</code>长度为0, 并且有论文可知</p><blockquote><p>• If last log index ≥ nextIndex for a follower: send AppendEntries RPC with log entries starting at nextIndex<br>• If successful: update nextIndex and matchIndex for follower (§5.3)<br>• If AppendEntries fails because of log inconsistency: decrement nextIndex and retry (§5.3)</p></blockquote><p><code>AppendEntries</code>除了<code>PRC</code>失败的情况下, 会一直重试, 直到返回<code>true</code>, 那么如果我们单独创建一个协程用于发送真正的不为心跳的<code>AppendEntries</code>, 需要考虑如下的问题:</p><ol><li>重试是应该立即重试, 还是设置一个重置超时?</li><li>何时触发这个处理<code>AppendEntries</code>的协程? 是累计了多个个日志项后再出发处理协程? 还是一旦有一个日志项就触发?</li><li>发射心跳处理函数时也会附带<code>PrevLogIndex</code>和<code>PrevLogTerm</code>以供<code>follower</code>验证, 心跳函数的这些参数会不会和之前的<code>AppendEntries</code>冲突? <code>follower</code>端如何处理这些重复的内容?</li></ol><p>看完上述几点, 我们可以看出, 如果将<code>AppendEntries</code>和心跳的发射器分开实现, 会增加代码的复杂度, 同时<code>AppendEntries</code>也具有重复发送的特点, 这和心跳的特点完美契合, 因此, 我们得出如下结论: <strong><code>AppendEntries</code>可以和心跳公用同一个发射器</strong></p><h2 id="3-2-结构体参数解读"><a href="#3-2-结构体参数解读" class="headerlink" title="3.2 结构体参数解读"></a>3.2 结构体参数解读</h2><p>首先<code>raft</code>结构体会新增几个<code>2A</code>中没有使用过的成员, 解释如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">nextIndex  []<span class="type">int</span> <span class="comment">// 复制到某一个follower时, log开始的索引</span></span><br><span class="line">matchIndex []<span class="type">int</span> <span class="comment">// 已经被复制到follower的日志的最高索引</span></span><br><span class="line">commitIndex <span class="type">int</span>  <span class="comment">// 将要提交的日志的最高索引</span></span><br><span class="line">lastApplied <span class="type">int</span>  <span class="comment">// 已经被应用到状态机的日志的最高索引</span></span><br><span class="line">applyCh     <span class="keyword">chan</span> ApplyMsg <span class="comment">// 用于在应用到状态机时传递消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此, 发送心跳或者<code>AppendEntries</code>时, <code>AppendEntriesArgs</code>应如下构造:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">Term:         rf.currentTerm,</span><br><span class="line">LeaderId:     rf.me,</span><br><span class="line">PrevLogIndex: rf.nextIndex[i] - <span class="number">1</span>,</span><br><span class="line">PrevLogTerm:  rf.log[rf.nextIndex[i]<span class="number">-1</span>].Term,</span><br><span class="line">LeaderCommit: rf.commitIndex,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(rf.log)<span class="number">-1</span> &gt;= rf.nextIndex[i] &#123;</span><br><span class="line">    <span class="comment">// 如果有新的log需要发送, 则就是一个真正的AppendEntries而不是心跳</span></span><br><span class="line">    args.Entries = rf.log[rf.nextIndex[i]:]</span><br><span class="line">    DPrintf(<span class="string">&quot;leader %v 开始向 server %v 广播新的AppendEntries\n&quot;</span>, rf.me, i)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有新的log发送, 就发送一个长度为0的切片, 表示心跳</span></span><br><span class="line">    args.Entries = <span class="built_in">make</span>([]Entry, <span class="number">0</span>)</span><br><span class="line">    DPrintf(<span class="string">&quot;leader %v 开始向 server %v 广播新的心跳, args = %+v \n&quot;</span>, rf.me, i, args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>PS: 术语补充</strong></p><ol><li><code>commited</code>: 集群中半数节点都已经复制了日志, 这保证了这个日志即使在重新选举后仍然存在, 因为不存在<code>commited</code>日志项的节点不会被选举</li><li><code>applied</code>: 指日志项的内容已经被应用到状态机</li></ol><h2 id="3-3-代码架构分析"><a href="#3-3-代码架构分析" class="headerlink" title="3.3 代码架构分析"></a>3.3 代码架构分析</h2><ol><li>由于<code>AppendEntries</code>和心跳公用同一个发射器(此后就称为心跳发射), 因此<code>leader</code>只需要将从<code>client</code>接收的心得日志项追加到<code>log</code>中即可, 发射器在每次超时到达后, 从每个<code>nextIndex[i]</code>构造<code>Entries</code>切片, 如果切片长度为0就是心跳, 不需要显式地判断是心跳或者是真的<code>AppendEntries</code>。</li><li>处理每个<code>AppendEntrie RPC</code>回复的函数只需要调整<code>nextIndex</code>和<code>matchIndex</code>即可, 下次心跳发送时会自动更新切片的长度。</li><li>处理每个<code>AppendEntrie RPC</code>回复的函数还需要找到<code>N</code>以更新<code>commitIndex</code>并唤醒<strong>应用到状态机的协程</strong>(这个协程也可以是<code>Sleep</code> + 轮训的方式实现)</li><li>由于<code>AppendEntries</code>也会附带上一次跳发射的回复处理中可能被更新的<code>commitIndex</code>, 因此<code>follower</code>端也会根据<code>commitIndex</code>唤醒自己的<strong>应用到状态机的协程</strong>(这个协程也可以是<code>Sleep</code> + 轮训的方式实现)</li></ol><h1 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4 代码实现"></a>4 代码实现</h1><h2 id="4-1-修改后的发射器"><a href="#4-1-修改后的发射器" class="headerlink" title="4.1 修改后的发射器"></a>4.1 修改后的发射器</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> SendHeartBeats() &#123;</span><br><span class="line"><span class="comment">// 2B相对2A的变化, 真实的AppendEntries也通过心跳发送</span></span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 开始发送心跳\n&quot;</span>, rf.me)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="comment">// if the server is dead or is not the leader, just return</span></span><br><span class="line"><span class="keyword">if</span> rf.role != Leader &#123;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="comment">// 不是leader则终止心跳的发送</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">Term:         rf.currentTerm,</span><br><span class="line">LeaderId:     rf.me,</span><br><span class="line">PrevLogIndex: rf.nextIndex[i] - <span class="number">1</span>,</span><br><span class="line">PrevLogTerm:  rf.log[rf.nextIndex[i]<span class="number">-1</span>].Term,</span><br><span class="line">LeaderCommit: rf.commitIndex,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(rf.log)<span class="number">-1</span> &gt;= rf.nextIndex[i] &#123;</span><br><span class="line"><span class="comment">// 如果有新的log需要发送, 则就是一个真正的AppendEntries而不是心跳</span></span><br><span class="line">args.Entries = rf.log[rf.nextIndex[i]:]</span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 开始向 server %v 广播新的AppendEntries\n&quot;</span>, rf.me, i)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果没有新的log发送, 就发送一个长度为0的切片, 表示心跳</span></span><br><span class="line">args.Entries = <span class="built_in">make</span>([]Entry, <span class="number">0</span>)</span><br><span class="line">DPrintf(<span class="string">&quot;leader %v 开始向 server %v 广播新的心跳, args = %+v \n&quot;</span>, rf.me, i, args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> rf.handleAppendEntries(i, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Duration(HeartBeatTimeOut) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前的区别就是为每个发送的<code>follower</code>单独构建了<code>AppendEntriesArgs</code>, 代码整体很简单, 几乎没啥区别</p><h2 id="4-2-AppendEntries-handler"><a href="#4-2-AppendEntries-handler" class="headerlink" title="4.2 AppendEntries handler"></a>4.2 <code>AppendEntries handler</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleAppendEntries(serverTo <span class="type">int</span>, args *AppendEntriesArgs) &#123;</span><br><span class="line"><span class="comment">// 目前的设计, 重试自动发生在下一次心跳函数, 所以这里不需要死循环</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// for &#123;</span></span><br><span class="line">reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">ok := rf.sendAppendEntries(serverTo, args, reply)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.Term != rf.currentTerm &#123;</span><br><span class="line"><span class="comment">// 函数调用间隙值变了, 已经不是发起这个调用时的term了</span></span><br><span class="line"><span class="comment">// 要先判断term是否改变, 否则后续的更改matchIndex等是不安全的</span></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.Success &#123;</span><br><span class="line"><span class="comment">// server回复成功</span></span><br><span class="line">rf.matchIndex[serverTo] = args.PrevLogIndex + <span class="built_in">len</span>(args.Entries)</span><br><span class="line">rf.nextIndex[serverTo] = rf.matchIndex[serverTo] + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要判断是否可以commit</span></span><br><span class="line">N := <span class="built_in">len</span>(rf.log) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> N &gt; rf.commitIndex &#123;</span><br><span class="line">count := <span class="number">1</span> <span class="comment">// 1表示包括了leader自己</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> rf.matchIndex[i] &gt;= N &amp;&amp; rf.log[N].Term == rf.currentTerm &#123;</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line"><span class="comment">// 如果至少一半的follower回复了成功, 更新commitIndex</span></span><br><span class="line">rf.commitIndex = N</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">N -= <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line"><span class="comment">// 回复了更新的term, 表示自己已经不是leader了</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v 旧的leader收到了来自 server % v 的心跳函数中更新的term: %v, 转化为Follower\n&quot;</span>, rf.me, serverTo, reply.Term)</span><br><span class="line"></span><br><span class="line">rf.currentTerm = reply.Term</span><br><span class="line">rf.role = Follower</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.timeStamp = time.Now()</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.Term == rf.currentTerm &amp;&amp; rf.role == Leader &#123;</span><br><span class="line"><span class="comment">// term仍然相同, 且自己还是leader, 表名对应的follower在prevLogIndex位置没有与prevLogTerm匹配的项</span></span><br><span class="line"><span class="comment">// 将nextIndex自减再重试</span></span><br><span class="line">rf.nextIndex[serverTo] -= <span class="number">1</span></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="comment">// time.Sleep(RetryTimeOut)</span></span><br><span class="line"><span class="comment">// continue</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里做出了如下几个修改:</p><ol><li>回复成功后, 添加了确定<code>N</code>的代码, 并判断是否更新<code>commitIndex</code>, 由于这里采取的<strong>应用到状态机的协程</strong>使用的是<code>Sleep</code>+轮训的方式, 因此没有别的操作, 如果采用条件变量, 还需要唤醒条件变量</li><li>如果返回<code>false</code>但<code>term</code>相同, 表明对应的<code>follower</code>在<code>prevLogIndex</code>位置没有与<code>prevLogTerm</code>匹配的项或者不存在<code>prevLogIndex</code>, 将<code>nextIndex</code>自减, 下一次发射器会重试</li></ol><h2 id="4-3-AppendEntries-RPC"><a href="#4-3-AppendEntries-RPC" class="headerlink" title="4.3 AppendEntries RPC"></a>4.3 <code>AppendEntries RPC</code></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppendEntries handler</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 之前的代码与2A相同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args.Entries) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 心跳函数</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v 接收到 leader %v 的心跳: %+v\n&quot;</span>, rf.me, args.LeaderId, args)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;server %v 收到 leader %v 的的AppendEntries: %+v \n&quot;</span>, rf.me, args.LeaderId, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) || rf.log[args.PrevLogIndex].Term != args.PrevLogTerm &#123;</span><br><span class="line"><span class="comment">// 校验PrevLogIndex和PrevLogTerm不合法</span></span><br><span class="line"><span class="comment">// 2. Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm (§5.3)</span></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">reply.Success = <span class="literal">false</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v 检查到心跳中参数不合法:\n\t args.PrevLogIndex=%v, args.PrevLogTerm=%v, \n\tlen(self.log)=%v, self最后一个位置term为:%v\n&quot;</span>, rf.me, args.PrevLogIndex, args.PrevLogTerm, <span class="built_in">len</span>(rf.log), rf.log[<span class="built_in">len</span>(rf.log)<span class="number">-1</span>].Term)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. If an existing entry conflicts with a new one (same index</span></span><br><span class="line"><span class="comment">// but different terms), delete the existing entry and all that</span></span><br><span class="line"><span class="comment">// follow it (§5.3)</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args.Entries) != <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(rf.log) &gt; args.PrevLogIndex+<span class="number">1</span> &amp;&amp; rf.log[args.PrevLogIndex+<span class="number">1</span>].Term != args.Entries[<span class="number">0</span>].Term &#123;</span><br><span class="line"><span class="comment">// 发生了冲突, 移除冲突位置开始后面所有的内容</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v 的log与args发生冲突, 进行移除\n&quot;</span>, rf.me)</span><br><span class="line">rf.log = rf.log[:args.PrevLogIndex+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. Append any new entries not already in the log</span></span><br><span class="line"><span class="comment">// 补充apeend的业务</span></span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, args.Entries...)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(args.Entries) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// DPrintf(&quot;server %v 成功进行apeend, log: %+v\n&quot;, rf.me, rf.log)</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v 成功进行apeend\n&quot;</span>, rf.me)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply.Success = <span class="literal">true</span></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"><span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line"><span class="comment">// 5.If leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry)</span></span><br><span class="line">rf.commitIndex = <span class="type">int</span>(math.Min(<span class="type">float64</span>(args.LeaderCommit), <span class="type">float64</span>(<span class="built_in">len</span>(rf.log)<span class="number">-1</span>)))</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的改动主要是增加了具体的<code>append</code>业务, 架构与之前变化不大, 需要注意的是, 如果采用条件变量实现<strong>应用到状态机的协程</strong>, 还需要唤醒条件变量。</p><h2 id="4-4-Start函数"><a href="#4-4-Start函数" class="headerlink" title="4.4 Start函数"></a>4.4 <code>Start</code>函数</h2><p><code>Start</code>函数只是将<code>command</code>追加到自己的<code>log</code>中, 因此其不保证<code>command</code>一定会提交。 其不需要调用任何其他的协程， 因此心跳函数是周期性自动检测的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Start(command <span class="keyword">interface</span>&#123;&#125;) (<span class="type">int</span>, <span class="type">int</span>, <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// 如果不是leader返回false</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> rf.role != Leader &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newEntry := &amp;Entry&#123;Term: rf.currentTerm, Cmd: command&#125;</span><br><span class="line">rf.log = <span class="built_in">append</span>(rf.log, *newEntry)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(rf.log) - <span class="number">1</span>, rf.currentTerm, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-5-应用到状态机的协程"><a href="#4-5-应用到状态机的协程" class="headerlink" title="4.5 应用到状态机的协程"></a>4.5 应用到状态机的协程</h2><p><code>CommitChecker</code>也是一个轮询的协程, 也可以使用条件变量来实现, 其不断检查<code>rf.commitIndex &gt; rf.lastApplied</code>, 将<code>rf.lastApplied</code>递增然后发送到管道<code>applyCh </code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> CommitChecker() &#123;</span><br><span class="line"><span class="comment">// 检查是否有新的commit</span></span><br><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">for</span> rf.commitIndex &gt; rf.lastApplied &#123;</span><br><span class="line">rf.lastApplied += <span class="number">1</span></span><br><span class="line">msg := &amp;ApplyMsg&#123;</span><br><span class="line">CommandValid: <span class="literal">true</span>,</span><br><span class="line">Command:      rf.log[rf.lastApplied].Cmd,</span><br><span class="line">CommandIndex: rf.lastApplied,</span><br><span class="line">&#125;</span><br><span class="line">rf.applyCh &lt;- *msg</span><br><span class="line">DPrintf(<span class="string">&quot;server %v 准备将命令 %v(索引为 %v ) 应用到状态机\n&quot;</span>, rf.me, msg.Command, msg.CommandIndex)</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">time.Sleep(CommitCheckTimeInterval)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-6-修改选举函数"><a href="#4-6-修改选举函数" class="headerlink" title="4.6 修改选举函数"></a>4.6 修改选举函数</h2><p>由于<code>nextIndex[]</code>和<code>matchIndex[]</code>是易失性数据, 每次重新选出<code>leader</code>后需要重新初始化, 因此对<code>collectVote</code>修改如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> collectVote(serverTo <span class="type">int</span>, args *RequestVoteArgs) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> rf.voteCount &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">...</span><br><span class="line">rf.role = Leader</span><br><span class="line"><span class="comment">// 需要重新初始化nextIndex和matchIndex</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.nextIndex); i++ &#123;</span><br><span class="line">rf.nextIndex[i] = <span class="built_in">len</span>(rf.log)</span><br><span class="line">rf.matchIndex[i] = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.muVote.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-测试"><a href="#5-测试" class="headerlink" title="5 测试"></a>5 测试</h1><h2 id="5-1-常规测试"><a href="#5-1-常规测试" class="headerlink" title="5.1 常规测试"></a>5.1 常规测试</h2><p>执行测试命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -v -run 2B</span><br></pre></td></tr></table></figure><p>结果如下:</p><p><img src="/../../images/lab2-2B-test1.png" alt="lab2-2A-test1"></p><h2 id="5-2-多次测试"><a href="#5-2-多次测试" class="headerlink" title="5.2 多次测试"></a>5.2 多次测试</h2><p><code>raft</code>的许多特性导致其一次测试并不准确, 有些bug需要多次测试才会出现, 编写如下脚本命名为<code>manyTest_2B.sh</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化计数器</span></span><br><span class="line">count=0</span><br><span class="line">success_count=0</span><br><span class="line">fail_count=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置测试次数</span></span><br><span class="line">max_tests=50</span><br><span class="line"></span><br><span class="line">for ((i=1; i&lt;=max_tests; i++))</span><br><span class="line">do</span><br><span class="line">    echo &quot;Running test iteration $i of $max_tests...&quot;</span><br><span class="line"></span><br><span class="line">    # 运行 go 测试命令</span><br><span class="line">    go test -v -run 2B &amp;&gt; output.log</span><br><span class="line"></span><br><span class="line">    # 检查 go 命令的退出状态</span><br><span class="line">    if [ &quot;$?&quot; -eq 0 ]; then</span><br><span class="line">        # 测试成功</span><br><span class="line">        success_count=$((success_count+1))</span><br><span class="line">        echo &quot;Test iteration $i passed.&quot;</span><br><span class="line">        # 如果想保存通过的测试日志，取消下面行的注释</span><br><span class="line">        # mv output.log &quot;success_$i.log&quot;</span><br><span class="line">    else</span><br><span class="line">        # 测试失败</span><br><span class="line">        fail_count=$((fail_count+1))</span><br><span class="line">        echo &quot;Test iteration $i failed, check &#x27;failure_$i.log&#x27; for details.&quot;</span><br><span class="line">        mv output.log &quot;failure_$i.log&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报告测试结果</span></span><br><span class="line">echo &quot;Testing completed: $max_tests iterations run.&quot;</span><br><span class="line">echo &quot;Successes: $success_count&quot;</span><br><span class="line">echo &quot;Failures: $fail_count&quot;</span><br></pre></td></tr></table></figure><p>再次进行测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./manyTest_2B.sh</span><br></pre></td></tr></table></figure><p>结果:</p><p><img src="/../../images/lab2-2B-test2.png" alt="lab2-2B-test2"></p><h1 id="6-代码优化"><a href="#6-代码优化" class="headerlink" title="6 代码优化"></a>6 代码优化</h1><p>代码优化的初衷是看到了官网的描述:</p><blockquote><p>The “ok 6.5840&#x2F;raft 35.557s” means that Go measured the time taken for the 2B tests to be 35.557 seconds of real (wall-clock) time. The “user 0m2.556s” means that the code consumed 2.556 seconds of CPU time, or time spent actually executing instructions (rather than waiting or sleeping). If your solution uses much more than a minute of real time for the 2B tests, or much more than 5 seconds of CPU time, you may run into trouble later on. Look for time spent sleeping or waiting for RPC timeouts, loops that run without sleeping or waiting for conditions or channel messages, or large numbers of RPCs sent.</p></blockquote><p>我之前的时间花了<code>75.5s</code>, 因此准备优化, 不过优化后发现也没多大改善, 主要原因是没有实现<strong>快速回退</strong>, 目前回退是一个一个的, 当然慢, 不过这个是<code>2C</code>的后话了</p><ul><li><strong>优化1: 使用条件变量</strong><br>将<code>CommitChecker</code>改为条件变量控制而不是轮询, 这里就不贴代码了, 很简单</li><li><strong>优化1: 使用timer</strong><br>尽管课程不推荐<strong>timer</strong>, 但<code>ticker</code>如果是轮训的话, 应该是不如定时器快的, 因此试了下定时器的实现<br>这里也不贴代码了, 很简单</li></ul><p>优化后再次测试:</p><p><img src="/../../images/lab2-2B-test3.png" alt="lab2-2B-test2"></p><p>快了<code>6s</code>, 有一定程度提升, 但倒数第二个测试<br><code>Test (2B): leader backs up quickly over incorrect follower logs ...</code><br>还是很慢, 应该是暂时还没实现快速回退的原因</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文将介绍&lt;code&gt;lab2B&lt;/code&gt;部分的实现, &lt;code&gt;lab2B&lt;/code&gt;要求实现&lt;code&gt;raft&lt;/code&gt;中的日志复制和提交两部分的内容, 相比&lt;code&gt;lab2A&lt;/code&gt;, &lt;code&gt;lab2B&lt;/code&gt;的&lt;code&gt;Hint</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="Lab笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/Lab%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.8540(6.824) Lab2: Raft 2A</title>
    <link href="http://example.com/2024/01/01/MIT6.8540/Lab2_Raft_2A/"/>
    <id>http://example.com/2024/01/01/MIT6.8540/Lab2_Raft_2A/</id>
    <published>2024-01-01T07:29:17.000Z</published>
    <updated>2024-01-06T17:22:48.036Z</updated>
    
    <content type="html"><![CDATA[<p>Lab2的内容是实现<code>Raft</code>算法, <code>Raft</code>算法是一种分布式系统中的一致性的共识算法, 于2014年提出。本次实现的<code>Raft</code>是下一个<code>K/V</code>实验的基础, 因此十分重要。就个人体验而言，本次实验的难度比之前的<code>MapReduce</code>复杂不少, 因此强烈建议先大致浏览一遍<code>Raft</code>的<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">原论文</a></p><p>由于这个<code>Lab</code>难度较大, 内容较多, 我将按照文档的任务分块进行, 这一部分先介绍第一个任务: <code>2A: leader election</code></p><p><code>Lab文档</code>见: <a href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html">https://pdos.csail.mit.edu/6.824/labs/lab-raft.html</a></p><p>我的代码: <a href="https://github.com/ToniXWD/MIT6.8540/tree/lab2A">https://github.com/ToniXWD/MIT6.8540/tree/lab2A</a></p><h1 id="1-任务描述"><a href="#1-任务描述" class="headerlink" title="1 任务描述"></a>1 任务描述</h1><p>首先贴一张原论文的图, 这张图描述了每个<code>RPC的逻辑, 非常重要</code>:</p><p><img src="/../../images/raft-figure2.png" alt="raft-figure2"></p><p><code>2A</code>部分要求完成的是<code>Raft</code>中的<code>Leader选取</code>和<code>心跳函数</code>, 通过阅读论文和文档, 我们知道<code>Raft</code>的运行状况是这样的:</p><ul><li>正常运行<br><code>Leader</code>不断发送心跳函数给<code>Follower</code>, <code>Follower</code>回复, 这个心跳是通过<code>AppendEntries RPC</code>实现的, 只不过其中<code>entries[]</code>是空的。</li><li>选举<ol><li>当指定的心跳间隔到期时， <code>Follower</code>转化为<code>Candidate</code>并开始进行投票选举, 会为自己投票并自增<code>term</code></li><li>每一个收到投票请求的<code>Server</code>(即包括了<code>Follower</code>, <code>Candidate</code>或旧的<code>Leader</code>), 判断其<code>RPC</code>的参数是否符合<code>Figure2</code>中的要求, 符合则投票</li><li>除非遇到了轮次更靠后的投票申请, 否则投过票的<code>Server</code>不会再进行投票</li><li>超过一半的<code>Server</code>的投票将选举出新的<code>Leader</code>, 新的<code>Leader</code>通过心跳<code>AppendEntries RPC</code>宣告自己的存在, 收到心跳的<code>Server</code>更新自己的状态</li><li>若超时时间内无新的<code>Leader</code>产生, 再进行下一轮投票, 为了避免这种情况, 应当给不同<code>Server</code>的投票超时设定随机值</li></ol></li></ul><h1 id="2-代码逻辑"><a href="#2-代码逻辑" class="headerlink" title="2 代码逻辑"></a>2 代码逻辑</h1><p>通过分析可知, 需要实现的功能包括:</p><ol><li>一个协程不断检测一个投票间隔内是接收到心跳或<code>AppendEntries RPC</code>(其实是一个东西), 如果没有接受到, 则发起投票</li><li>处理投票的协程, 发起投票并收集投票结果以改变自身角色</li><li>不断发送心跳的<code>Leader</code>的心跳发射器协程</li><li>处理投票请求的<code>RPC</code></li><li>处理心跳的<code>RPC</code></li></ol><p>官方提供的代码里指明用<code>ticker</code>实现选举, 并给出了<code>RPC</code>的实现案例</p><h1 id="3-结构体设计"><a href="#3-结构体设计" class="headerlink" title="3 结构体设计"></a>3 结构体设计</h1><p>第一步就是先将<code>Figure 2.5</code>的字段填入各个结构体。</p><h2 id="3-1-Raft结构体"><a href="#3-1-Raft结构体" class="headerlink" title="3.1 Raft结构体"></a>3.1 <code>Raft</code>结构体</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">Follower = <span class="literal">iota</span></span><br><span class="line">Candidate</span><br><span class="line">Leader</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Entry <span class="keyword">struct</span> &#123;</span><br><span class="line">Term <span class="type">int</span></span><br><span class="line">Cmd  <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">mu        sync.Mutex          <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">peers     []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">persister *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">me        <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">dead      <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Your data here (2A, 2B, 2C).</span></span><br><span class="line"><span class="comment">// Look at the paper&#x27;s Figure 2 for a description of what</span></span><br><span class="line"><span class="comment">// state a Raft server must maintain.</span></span><br><span class="line"></span><br><span class="line">currentTerm <span class="type">int</span></span><br><span class="line">votedFor    <span class="type">int</span></span><br><span class="line">log         []Entry</span><br><span class="line"></span><br><span class="line">commitIndex <span class="type">int</span></span><br><span class="line">lastApplied <span class="type">int</span></span><br><span class="line">nextIndex   []<span class="type">int</span></span><br><span class="line">matchIndex  []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下不是Figure 2中的field</span></span><br><span class="line">timeStamp time.Time <span class="comment">// 记录收到消息的时间(心跳或append)</span></span><br><span class="line">role      <span class="type">int</span></span><br><span class="line"></span><br><span class="line">muVote    sync.Mutex <span class="comment">// 保护投票数据</span></span><br><span class="line">voteCount <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了<code>Figure 2</code>中的字段外, 还有 <code>role</code>, <code>timeStamp</code>, <code>muVote</code>, <code>voteCount</code>四个自定义字段:</p><ol><li><code>role</code>: 一个枚举量, 记录当前实例的角色, 取值包括: <code>Follower</code>, <code>Candidate</code>, <code>Leader</code></li><li><code>voteCount</code>: 得票计数</li><li><code>muVote</code>: 用于保护<code>voteCount</code>的锁, 因为投票时只需要更改<code>voteCount</code>, 而全部使用<code>mu</code>明细会增加锁的竞争, 这里是细化锁的粒度</li><li><code>timeStamp</code>: 记录最后一次收到合法消息的时间戳, 每次判断是否要选举时, 通过判断与这个时间戳的差值来决定是否达到超时</li></ol><p><strong>为什么不使用定时器<code>time.Timer</code>?</strong><br>主要原因是官方的<code>Hint</code>中明确表示:</p><blockquote><p> Don’t use Go’s time.Timer or time.Ticker, which are difficult to use correctly.</p></blockquote><p>个人实际使用后确实出现了很多不明所以的bug, 因此就选择记录时间戳<code>timeStamp</code> + <code>Sleep</code>的方式实现</p><h2 id="3-2-RPC结构体"><a href="#3-2-RPC结构体" class="headerlink" title="3.2 RPC结构体"></a>3.2 RPC结构体</h2><p>RPC结构体直接照搬<code>Figure 2</code>:</p><ol><li><code>RequestVote RPC</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RequestVoteArgs <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your data here (2A, 2B).</span></span><br><span class="line">Term         <span class="type">int</span> <span class="comment">// candidate’s term</span></span><br><span class="line">CandidateId  <span class="type">int</span> <span class="comment">// candidate requesting vote</span></span><br><span class="line">LastLogIndex <span class="type">int</span> <span class="comment">// index of candidate’s last log entry (§5.4)</span></span><br><span class="line">LastLogTerm  <span class="type">int</span> <span class="comment">// term of candidate’s last log entry (§5.4)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example RequestVote RPC reply structure.</span></span><br><span class="line"><span class="comment">// field names must start with capital letters!</span></span><br><span class="line"><span class="keyword">type</span> RequestVoteReply <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your data here (2A).</span></span><br><span class="line">Term        <span class="type">int</span>  <span class="comment">// currentTerm, for candidate to update itself</span></span><br><span class="line">VoteGranted <span class="type">bool</span> <span class="comment">// true means candidate received vote</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><code>AppendEntries RPC</code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AppendEntriesArgs <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your data here (2A, 2B).</span></span><br><span class="line">Term         <span class="type">int</span>     <span class="comment">// leader’s term</span></span><br><span class="line">LeaderId     <span class="type">int</span>     <span class="comment">// so follower can redirect clients</span></span><br><span class="line">PrevLogIndex <span class="type">int</span>     <span class="comment">// index of log entry immediately preceding new ones</span></span><br><span class="line">PrevLogTerm  <span class="type">int</span>     <span class="comment">// term of prevLogIndex entry</span></span><br><span class="line">Entries      []Entry <span class="comment">// log entries to store (empty for heartbeat; may send more than one for efficiency)</span></span><br><span class="line">LeaderCommit <span class="type">int</span>     <span class="comment">// leader’s commitIndex</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example RequestVote RPC reply structure.</span></span><br><span class="line"><span class="comment">// field names must start with capital letters!</span></span><br><span class="line"><span class="keyword">type</span> AppendEntriesReply <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your data here (2A).</span></span><br><span class="line">Term    <span class="type">int</span>  <span class="comment">// currentTerm, for leader to update itself</span></span><br><span class="line">Success <span class="type">bool</span> <span class="comment">// true if follower contained entry matching prevLogIndex and prevLogTerm</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="4-投票设计"><a href="#4-投票设计" class="headerlink" title="4 投票设计"></a>4 投票设计</h1><h2 id="4-1-投票发起方"><a href="#4-1-投票发起方" class="headerlink" title="4.1 投票发起方"></a>4.1 投票发起方</h2><ol><li><code>ticker</code>函数判断是否需要投票:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ticker() &#123;</span><br><span class="line">rd := rand.New(rand.NewSource(<span class="type">int64</span>(rf.me)))</span><br><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your code here (2A)</span></span><br><span class="line"><span class="comment">// Check if a leader election should be started.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pause for a random amount of time between 50 and 350</span></span><br><span class="line"><span class="comment">// milliseconds.</span></span><br><span class="line">rdTimeOut := GetRandomElectTimeOut(rd)</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> rf.role != Leader &amp;&amp; time.Since(rf.timeStamp) &gt; time.Duration(rdTimeOut)*time.Millisecond &#123;</span><br><span class="line"><span class="comment">// 超时</span></span><br><span class="line"><span class="keyword">go</span> rf.Elect()</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">time.Sleep(ElectTimeOutCheckInterval)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这里<code>timeStamp</code>就是上一次正常收到消息的时间, 判断当前的时间差再与随机获取的超时时间比较即可</li></ol><p>另外, 根据官方的提示可知:</p><blockquote><p>You may find Go’s rand useful.</p></blockquote><p>确定超时间隔时, 需要为不同的<code>server</code>设置不同的种子, 否则他们大概率会同时开启选票申请, 这里我直接使用其序号<code>rf.me</code>作为随机种子。</p><ol start="2"><li><code>Elect</code>函数负责处理具体的投票任务:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Elect() &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"></span><br><span class="line">rf.currentTerm += <span class="number">1</span>       <span class="comment">// 自增term</span></span><br><span class="line">rf.role = Candidate       <span class="comment">// 成为候选人</span></span><br><span class="line">rf.votedFor = rf.me       <span class="comment">// 给自己投票</span></span><br><span class="line">rf.voteCount = <span class="number">1</span>          <span class="comment">// 自己有一票</span></span><br><span class="line">rf.timeStamp = time.Now() <span class="comment">// 自己给自己投票也算一种消息</span></span><br><span class="line"></span><br><span class="line">args := &amp;RequestVoteArgs&#123;</span><br><span class="line">Term:         rf.currentTerm,</span><br><span class="line">CandidateId:  rf.me,</span><br><span class="line">LastLogIndex: <span class="built_in">len</span>(rf.log) - <span class="number">1</span>,</span><br><span class="line">LastLogTerm:  rf.log[<span class="built_in">len</span>(rf.log)<span class="number">-1</span>].Term,</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> rf.collectVote(i, args)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这个函数的任务很简单:</li></ol><ul><li>更新<code>term</code></li><li>标记自身角色转换</li><li>为自己投票</li><li>初始化票数为1</li><li>更新时间戳</li></ul><p>其余的部分很简单, 就是构造<code>RPC</code>的请求结构体, 异步地对每个<code>server</code>发起投票申请</p><blockquote><p>易错点:<br>忘记<code>更新时间戳</code>, 因为自己给自己投票也算一种消息, 应当更新时间戳, 否则下一轮投票很快又来了</p></blockquote><ol start="3"><li><code>collectVote</code>函数处理每个<code>server</code>的回复并统计票数<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> collectVote(serverTo <span class="type">int</span>, args *RequestVoteArgs) &#123;</span><br><span class="line">voteAnswer := rf.GetVoteAnswer(serverTo, args)</span><br><span class="line"><span class="keyword">if</span> !voteAnswer &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">rf.muVote.Lock()</span><br><span class="line"><span class="keyword">if</span> rf.voteCount &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">rf.muVote.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.voteCount += <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> rf.voteCount &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> rf.role == Follower &#123;</span><br><span class="line"><span class="comment">// 有另外一个投票的协程收到了更新的term而更改了自身状态为Follower</span></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">rf.muVote.Unlock()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">rf.role = Leader</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="keyword">go</span> rf.SendHeartBeats()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.muVote.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> GetVoteAnswer(server <span class="type">int</span>, args *RequestVoteArgs) <span class="type">bool</span> &#123;</span><br><span class="line">sendArgs := *args</span><br><span class="line">reply := RequestVoteReply&#123;&#125;</span><br><span class="line">ok := rf.sendRequestVote(server, &amp;sendArgs, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sendArgs.Term != rf.currentTerm &#123;</span><br><span class="line"><span class="comment">// 易错点: 函数调用的间隙被修改了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line"><span class="comment">// 已经是过时的term了</span></span><br><span class="line">rf.currentTerm = reply.Term</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.role = Follower</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> reply.VoteGranted</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><code>collectVote</code>调用<code>GetVoteAnswer</code>, 其中<code>GetVoteAnswer</code>负责处理具体某一个<code>server</code>的回复:</li><li>如果<code>RPC</code>调用失败, 直接返回</li><li>如果<code>server</code>回复了更大的<code>term</code>, 表示当前这一轮的投票已经废弃, 按照回复更新<code>term</code>、自身角色和投票数据 返回<code>false</code></li><li>然后才是返回<code>server</code>是否赞成了投票</li></ol><p><code>collectVote</code>处理逻辑为:</p><ol><li>如果发现当前投票已经结束了(即票数过半), 返回</li><li>否则按照投票结果对自身票数自增</li><li>自增后如果票数过半, 检查检查状态后转换自身角色为<code>Leader</code></li><li>转换自身角色为<code>Leader</code>, 开始发送心跳</li></ol><p>这里特别说明为什么收集投票时需要<code>muVote</code>这个锁保护<code>voteCount</code>, 因为除了最后一个超过半票的一个协程, 其余协程只需要访问<code>voteCount</code>, 因此额外设计了<code>muVote</code>这个锁保护它。</p><blockquote><p>易错点:</p><ol><li>由于不同函数调用的间隙, 状态可能被别的协程改变了, 因此<code>GetVoteAnswer</code>中如果发现<code>sendArgs.Term != rf.currentTerm</code>, 表示已经有<code>Leader</code>诞生了并通过心跳改变了自己的<code>Term</code>, 所以放弃投票数据收集</li><li><code>collectVote</code>中也存在类似的问题, 因为<code>collectVote</code>也是与<code>RPC心跳的handler</code>并发的, 可能新的<code>Leader</code>已经产生, 并通过心跳改变了自己的<code>role</code>为<code>Follower</code>, 如果不检查的话, 将导致多个<code>Leader</code>的存在</li><li>尽管向多个<code>server</code>发送的<code>RequestVoteArgs</code>内容是相同的, 但我们不同使用同一个指针, 而是应该复制一个结构体 否则会报错, 原因暂时没看源码, 未知(先鸽了)</li></ol></blockquote><h2 id="4-2-投票接收方"><a href="#4-2-投票接收方" class="headerlink" title="4.2 投票接收方"></a>4.2 投票接收方</h2><p>投票的接收方则严格按照<code>Figure 2</code>设计, 代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example RequestVote RPC handler.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line"><span class="comment">// Your code here (2A, 2B).</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line"><span class="comment">// 旧的term</span></span><br><span class="line"><span class="comment">// 1. Reply false if term &lt; currentTerm (§5.1)</span></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v 拒绝向 server %v投票: 旧的term: %v,\n\targs= %+v\n&quot;</span>, rf.me, args.CandidateId, args.Term, args)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码到这里时, args.Term &gt;= rf.currentTerm</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line"><span class="comment">// 已经是新一轮的term, 之前的投票记录作废</span></span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// at least as up-to-date as receiver’s log, grant vote (§5.2, §5.4)</span></span><br><span class="line"><span class="keyword">if</span> rf.votedFor == <span class="number">-1</span> || rf.votedFor == args.CandidateId &#123;</span><br><span class="line"><span class="comment">// 首先确保是没投过票的</span></span><br><span class="line"><span class="keyword">if</span> args.Term &gt; rf.currentTerm ||</span><br><span class="line">(args.LastLogIndex &gt;= <span class="built_in">len</span>(rf.log)<span class="number">-1</span> &amp;&amp; args.LastLogTerm &gt;= rf.log[<span class="built_in">len</span>(rf.log)<span class="number">-1</span>].Term) &#123;</span><br><span class="line"><span class="comment">// 2. If votedFor is null or candidateId, and candidate’s log is least as up-to-date as receiver’s log, grant vote (§5.2, §5.4)</span></span><br><span class="line">rf.currentTerm = args.Term</span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">rf.votedFor = args.CandidateId</span><br><span class="line">rf.role = Follower</span><br><span class="line">rf.timeStamp = time.Now()</span><br><span class="line"></span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">reply.VoteGranted = <span class="literal">true</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v 同意向 server %v投票\n\targs= %+v\n&quot;</span>, rf.me, args.CandidateId, args)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;server %v 拒绝向 server %v投票: 已投票\n\targs= %+v\n&quot;</span>, rf.me, args.CandidateId, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">reply.VoteGranted = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码的逻辑是(对<code>Figure 2 </code>做了一定自己理解的展开):</p><ol><li>如果<code>args.Term &lt; rf.currentTerm</code>, 直接拒绝投票, 并告知更新的投票</li><li>如果<code>args.Term &gt; rf.currentTerm</code>, 更新<code>rf.votedFor = -1</code>, 表示自己没有投票, 之前轮次的投票作废</li><li>如果满足下面两个情况之一, 投票, 然后更新<code>currentTerm</code>, <code>votedFor</code>,<code>role</code>, <code>timeStamp </code><ol><li><code>args.Term &gt; rf.currentTerm</code></li><li><code>term == currentTerm</code>且<code>LastLogTerm</code>和<code>LastLogIndex</code>位置的条目存在且<code>term</code>合法, 并且未投票或者投票对象是自己</li></ol></li><li>其他情况不投票</li></ol><blockquote><p>易错点<br><code>args.Term &gt; rf.currentTerm</code>的情况需要设置<code>rf.votedFor = -1</code>, 因为当前的<code>server</code>可能在正处于旧的<code>term</code>的选举中,并投给了别人, 应当废除旧<code>term</code>的投票, 将其置为未投票的状态, 否则将错失应有的投票</p></blockquote><h1 id="5-心跳设计-AppendEntries-RPC"><a href="#5-心跳设计-AppendEntries-RPC" class="headerlink" title="5 心跳设计(AppendEntries RPC)"></a>5 心跳设计(<code>AppendEntries RPC</code>)</h1><h2 id="5-1-心跳发射器"><a href="#5-1-心跳发射器" class="headerlink" title="5.1 心跳发射器"></a>5.1 心跳发射器</h2><p>当一个<code>Leader</code>诞生时, 立即启动心跳发射器, 其不断地调用<code>AppendEntries RPC</code>, 只是<code>Entries</code>是空的而已, 其代码相对简单:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> SendHeartBeats() &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;server %v 开始发送心跳\n&quot;</span>, rf.me)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="comment">// if the server is dead or is not the leader, just return</span></span><br><span class="line"><span class="keyword">if</span> rf.role != Leader &#123;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"><span class="comment">// 不是leader则终止心跳的发送</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">args := &amp;AppendEntriesArgs&#123;</span><br><span class="line">Term:         rf.currentTerm,</span><br><span class="line">LeaderId:     rf.me,</span><br><span class="line">PrevLogIndex: <span class="number">0</span>,</span><br><span class="line">PrevLogTerm:  <span class="number">0</span>,</span><br><span class="line">Entries:      <span class="literal">nil</span>,</span><br><span class="line">LeaderCommit: rf.commitIndex,</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(rf.peers); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i == rf.me &#123;</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> rf.handleHeartBeat(i, args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Duration(HeartBeatTimeOut) * time.Millisecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>易错点:<br>同前文描述, 尽管向多个<code>server</code>发送的<code>AppendEntriesArgs</code>内容是相同的, 但我们不能使用同一个指针, 而是应该复制一个结构体 否则会报错</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> handleHeartBeat(serverTo <span class="type">int</span>, args *AppendEntriesArgs) &#123;</span><br><span class="line">reply := &amp;AppendEntriesReply&#123;&#125;</span><br><span class="line">sendArgs := *args <span class="comment">// 复制一份args结构体, (可能有未知的错误)</span></span><br><span class="line">ok := rf.sendAppendEntries(serverTo, &amp;sendArgs, reply)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> sendArgs.Term != rf.currentTerm &#123;</span><br><span class="line"><span class="comment">// 函数调用间隙值变了</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> reply.Term &gt; rf.currentTerm &#123;</span><br><span class="line">DPrintf(<span class="string">&quot;server %v 旧的leader收到了心跳函数中更新的term: %v, 转化为Follower\n&quot;</span>, rf.me, reply.Term)</span><br><span class="line">rf.currentTerm = reply.Term</span><br><span class="line">rf.votedFor = <span class="number">-1</span></span><br><span class="line">rf.role = Follower</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>handleHeartBeat</code>负责处理每一个发出的心跳函数的回复, 只需要考虑的就是自身的<code>term</code>被更新了, 需要更改自身状态, 其逻辑和前文相同, 不赘述</p><blockquote><p>易错点<br>这里也存在函数调用间隙字段被修改的情况, 也需要检查<code>sendArgs.Term != rf.currentTerm</code>的情况</p></blockquote><h2 id="5-2-心跳接受方"><a href="#5-2-心跳接受方" class="headerlink" title="5.2 心跳接受方"></a>5.2 心跳接受方</h2><p>心跳接受方实际上就是<code>AppendEntries RPC</code>的<code>handler</code>, 由于目前日志部分的字段还没有设计, 因此这里的代码不涉及持久化:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) &#123;</span><br><span class="line"><span class="comment">// Your code here (2A, 2B).</span></span><br><span class="line"><span class="comment">// 新leader发送的第一个消息</span></span><br><span class="line">rf.mu.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.Term &lt; rf.currentTerm &#123;</span><br><span class="line"><span class="comment">// 这是来自旧的leader的消息</span></span><br><span class="line"><span class="comment">// 1. Reply false if term &lt; currentTerm (§5.1)</span></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">reply.Success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码执行到这里就是 args.Term &gt;= rf.currentTerm 的情况</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是旧 leader的话需要记录访问时间</span></span><br><span class="line">rf.timeStamp = time.Now()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.Term &gt; rf.currentTerm &#123;</span><br><span class="line"><span class="comment">// 新leader的第一个消息</span></span><br><span class="line">rf.currentTerm = args.Term <span class="comment">// 更新iterm</span></span><br><span class="line">rf.votedFor = <span class="number">-1</span>           <span class="comment">// 易错点: 更新投票记录为未投票</span></span><br><span class="line">rf.role = Follower</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.Entries == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 心跳函数</span></span><br><span class="line">DPrintf(<span class="string">&quot;server %v 接收到 leader &amp;%v 的心跳\n&quot;</span>, rf.me, args.LeaderId)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> args.Entries != <span class="literal">nil</span> &amp;&amp;</span><br><span class="line">(args.PrevLogIndex &gt;= <span class="built_in">len</span>(rf.log) || rf.log[args.PrevLogIndex].Term != args.PrevLogTerm) &#123;</span><br><span class="line"><span class="comment">// 校验PrevLogIndex和PrevLogTerm不合法</span></span><br><span class="line"><span class="comment">// 2. Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm (§5.3)</span></span><br><span class="line"></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">reply.Success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3. If an existing entry conflicts with a new one (same index</span></span><br><span class="line"><span class="comment">// but different terms), delete the existing entry and all that</span></span><br><span class="line"><span class="comment">// follow it (§5.3)</span></span><br><span class="line"><span class="comment">// 4. Append any new entries not already in the log</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 补充apeend的业务</span></span><br><span class="line"></span><br><span class="line">reply.Success = <span class="literal">true</span></span><br><span class="line">reply.Term = rf.currentTerm</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> args.LeaderCommit &gt; rf.commitIndex &#123;</span><br><span class="line"><span class="comment">// 5.If leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry)</span></span><br><span class="line">rf.commitIndex = <span class="type">int</span>(math.Min(<span class="type">float64</span>(args.LeaderCommit), <span class="type">float64</span>(<span class="built_in">len</span>(rf.log)<span class="number">-1</span>)))</span><br><span class="line">&#125;</span><br><span class="line">rf.mu.Unlock()</span><br><span class="line">&#125;<span class="string">`</span></span><br></pre></td></tr></table></figure><p><code>AppendEntries</code>严格按照<code>Figure 2</code>实现:</p><ol><li>如果<code>term &lt; currentTerm</code>表示这是一个旧<code>leader</code>的消息, 告知其更新的<code>term</code>并返回<code>false</code></li><li>如果自己的日志中<code>prevLogIndex</code>处不存在有效的日志, 或者与<code>prevLogTerm</code>不匹配, 返回<code>false</code></li><li>如果现存的日志与请求的信息冲突, 删除冲突的日志(这一部分不涉及)</li><li>添加日志(这一部分不涉及)</li><li>如果<code>leaderCommit &gt; commitIndex</code>, 确认者较小值并更新</li></ol><p>同时, 收到<code>AppendEntries</code>需要更新对应的时间戳<code>rf.timeStamp</code></p><blockquote><p>易错点</p><ol><li>如果<code>args.Term &gt; rf.currentTerm</code>, 表示这是新的<code>Leader</code>发送的消息, 由于自身可能正在进行选举投票, 因此需要更改<code>rf.role = Followe &amp;&amp; rf.votedFor = -1</code>以终止其不应该继续的投票, 同时更新<code>rf.votedFor = -1</code>, <code>-1</code>表示未投过票。</li></ol></blockquote><h1 id="6-测试"><a href="#6-测试" class="headerlink" title="6 测试"></a>6 测试</h1><h2 id="6-1-常规测试"><a href="#6-1-常规测试" class="headerlink" title="6.1 常规测试"></a>6.1 常规测试</h2><p>执行测试命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -v -run 2A</span><br></pre></td></tr></table></figure><p>结果如下:</p><p><img src="/../../images/lab2-2A-test1.png" alt="lab2-2A-test1"></p><h2 id="6-2-多次测试"><a href="#6-2-多次测试" class="headerlink" title="6.2 多次测试"></a>6.2 多次测试</h2><p><code>raft</code>的许多特性导致其一次测试并不准确, 有些bug需要多次测试才会出现, 编写如下脚本命名为<code>manyTest_2A.sh</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化计数器</span></span><br><span class="line">count=0</span><br><span class="line">success_count=0</span><br><span class="line">fail_count=0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置测试次数</span></span><br><span class="line">max_tests=50</span><br><span class="line"></span><br><span class="line">for ((i=1; i&lt;=max_tests; i++))</span><br><span class="line">do</span><br><span class="line">    echo &quot;Running test iteration $i of $max_tests...&quot;</span><br><span class="line"></span><br><span class="line">    # 运行 go 测试命令</span><br><span class="line">    go test -v -run 2A &amp;&gt; output.log</span><br><span class="line"></span><br><span class="line">    # 检查 go 命令的退出状态</span><br><span class="line">    if [ &quot;$?&quot; -eq 0 ]; then</span><br><span class="line">        # 测试成功</span><br><span class="line">        success_count=$((success_count+1))</span><br><span class="line">        echo &quot;Test iteration $i passed.&quot;</span><br><span class="line">        # 如果想保存通过的测试日志，取消下面行的注释</span><br><span class="line">        # mv output.log &quot;success_$i.log&quot;</span><br><span class="line">    else</span><br><span class="line">        # 测试失败</span><br><span class="line">        fail_count=$((fail_count+1))</span><br><span class="line">        echo &quot;Test iteration $i failed, check &#x27;failure_$i.log&#x27; for details.&quot;</span><br><span class="line">        mv output.log &quot;failure_$i.log&quot;</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">报告测试结果</span></span><br><span class="line">echo &quot;Testing completed: $max_tests iterations run.&quot;</span><br><span class="line">echo &quot;Successes: $success_count&quot;</span><br><span class="line">echo &quot;Failures: $fail_count&quot;</span><br></pre></td></tr></table></figure><p>再次进行测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./manyTest_2A.sh</span><br></pre></td></tr></table></figure><p>结果:</p><p><img src="/../../images/lab2-2A-test2.png" alt="lab2-2A-test2"></p><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>代码在<code>leader</code>选举过程中存在<code>bug</code>, 但任然能通过测例, 修复后的代码和<code>bug</code>分析见 下一篇文章: <a href="/2024/01/06/MIT6.8540/Lab2_Raft_2B/">Lab2_Raft_2B.md</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Lab2的内容是实现&lt;code&gt;Raft&lt;/code&gt;算法, &lt;code&gt;Raft&lt;/code&gt;算法是一种分布式系统中的一致性的共识算法, 于2014年提出。本次实现的&lt;code&gt;Raft&lt;/code&gt;是下一个&lt;code&gt;K/V&lt;/code&gt;实验的基础, 因此十分重要。就个</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="Lab笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/Lab%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.8540(6.824) Lec03笔记: GFS</title>
    <link href="http://example.com/2023/12/30/MIT6.8540/Lec03%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/12/30/MIT6.8540/Lec03%E7%AC%94%E8%AE%B0/</id>
    <published>2023-12-30T09:11:45.000Z</published>
    <updated>2024-01-03T06:17:14.132Z</updated>
    
    <content type="html"><![CDATA[<p>本节课是解释谷歌的分布式文件系统<code>GFS</code>, 强烈建议阅读其<a href="https://pdos.csail.mit.edu/6.824/papers/gfs.pdf">论文</a></p><h1 id="1-GFS简介"><a href="#1-GFS简介" class="headerlink" title="1 GFS简介"></a>1 GFS简介</h1><p><code>GFS</code>（<code>Google File System</code>）是<code>Google</code>特别为应对大规模数据处理而设计的分布式文件系, 其设计目的是满足对处理大量数据集、高吞吐量的数据访问、可靠性、可扩展性的需求。其特性包括:</p><ol><li><p><strong>分布式架构</strong>：<code>GFS</code>是一个分布式的文件系统，它将数据存储在多个网络连接的机器上。这种设计可以提供高容错性和高数据可靠性。</p></li><li><p><strong>容错能力</strong>：<code>GFS</code>通过副本机制来确保数据的安全。即使某些硬件组件或机器出现故障，系统仍能确保数据不丢失，并继续提供服务。</p></li><li><p><strong>一致性模型</strong>：<code>GFS</code>采用了一致性模型，以容忍网络延迟和系统故障，同时保持数据的一致性。</p></li><li><p><strong>大文件优化</strong>：<code>GFS</code>被设计来存储大文件。它将每个文件分割成多个固定大小的块（<code>chunks</code>），每个块一般大小为64MB或更大。这种设计简化了文件管理，并且对于大规模数据处理非常有效。</p></li><li><p><strong>高吞吐量</strong>：<code>GFS</code>针对高吞吐量的数据访问进行了优化，尤其是顺序读写操作，这对于数据挖掘和内容索引等操作非常重要。</p></li><li><p><strong>主&#x2F;从架构</strong>：<code>GFS</code>采用了<strong>主&#x2F;从架构</strong>，有一个主服务器（Master）负责管理文件系统的命名空间、控制元数据和调度访问请求。数据被存储在多个分布式的块服务器（<code>Chunkserver</code>）上。</p></li><li><p><strong>写入模型</strong>：<code>GFS</code>的写入模型设计用于最小化由于远程写入导致的网络拥堵。它采用了<strong>写入一次，多次读取</strong>的模式，这意味着一旦写入，文件就不再修改，只允许追加操作。</p></li><li><p><strong>客户端和服务器交互</strong>：<code>GFS</code>客户端和服务器之间的交互尽可能地简单，并且大部分复杂的操作逻辑都在服务器端完成。</p></li></ol><p><code>GFS</code>的设计论文被广泛研究，并激发了其他分布式文件系统的开发，如<code>Apache Hadoop</code>的<code>HDFS</code>（<code>Hadoop Distributed File System</code>）等。</p><h1 id="2-GFS架构"><a href="#2-GFS架构" class="headerlink" title="2 GFS架构"></a>2 GFS架构</h1><h2 id="2-1-架构图"><a href="#2-1-架构图" class="headerlink" title="2.1 架构图"></a>2.1 架构图</h2><p>下图所示为摘自论文中的<code>GFS</code>架构:</p><p><img src="/../../images/GFS_structure.png" alt="GFS_structure"></p><p>架构图中包括如下术语:</p><ol><li><code>Master</code><br><code>GFS</code>中的中心节点，负责管理文件系统的全局视图。<code>Master</code>节点保存了所有文件的元数据，这包括文件和目录的命名空间结构、每个文件的<code>chunks</code>信息、每个<code>chunk</code>的位置以及每个操作的日志。<code>Master</code>调度客户端对<code>chunks</code>的读写请求，并处理命名空间的修改和访问控制。</li><li><code>Chunkserver</code><br><code>Chunkserver</code>是GFS中的工作节点，负责存储实际的文件数据。文件数据被分割成多个<code>chunks</code>，每个<code>chunk</code>通常大小为64MB（可进行配置）。每个<code>Chunkserver</code>可能会存储数千个这样的<code>chunks</code>，并负责处理来自客户端的读写请求。它们向<code>Master</code>报告存储的<code>chunks</code>的状态，并根据<code>Master</code>的指示执行诸如创建副本或删除旧副本等操作。本质上, <code>Chunkserver</code>就是一个<code>Linux</code>的管理文件的进程。</li><li><code>Client</code><br><code>Client</code>指的是使用GFS存储数据的应用程序。客户端通过<code>GFS</code>提供的<code>API</code>(其实就是链接一个库)与文件系统进行交互。客户端会先与<code>Master</code>节点通信以获取文件元数据和<code>chunks</code>的位置信息，然后直接与一个或多个<code>chunkservers</code>通信进行数据的读写操作。</li><li><code>Chunk</code><br>文件分割的基本单位，是数据存储的块。每个<code>chunk</code>由<code>Chunkserver</code>存储和管理，具有固定的大小，例如64MB。通过使用固定大小的<code>chunks</code>，<code>GFS</code>能够简化存储管理，并且优化大规模数据的读写效率。文件有多少个<code>Chunk</code>, 每个<code>Chunk</code>在什么位置, 这些信息都存在<code>Master</code>的内存中。</li><li><code>Chunk Handle</code><br><code>Chunk Handle</code>是<code>GFS</code>分配给每个chunk的唯一标识符。它是一个全局唯一的64位值，用于标识和引用存储在<code>chunkservers</code>上的特定<code>chunk</code>。<code>Chunk Handle</code>在<code>chunk</code>的整个生命周期中保持不变，即使其副本在不同的<code>chunkservers</code>之间移动或复制。</li><li><code>Chunk Location</code><br><code>Chunk Location</code>是指存储特定<code>chunk</code>的<code>Chunkserver</code>的网络地址。Master节点跟踪每个<code>chunk</code>的所有副本的位置，并将这些位置信息提供给客户端，以便客户端可以直接与存储所需<code>chunks</code>的<code>Chunkserver</code>建立连接进行数据读写。</li></ol><h2 id="2-2-架构特点"><a href="#2-2-架构特点" class="headerlink" title="2.2 架构特点"></a>2.2 架构特点</h2><p><code>GFS</code>的架构特点可以总结如下:</p><ol><li>单<code>Master</code><br>所有文件系统元数据(包括文件系统命名空间、文件名与<code>chunk</code>的映射关系、<code>chunk</code>的位置、<code>chunk</code>版本号、日志等)都存储在单个<code>Master</code>节点的内存中</li><li>文件分块<br>件被切分成固定大小的<code>chunks</code>, <code>chunkservers</code>将<code>chunks</code>存储在本地磁盘上作为<code>Linux</code>文件, <code>chunks</code>在多个<code>chunkservers</code>中备份存储</li><li>心跳同步<br><code>chunkservers</code>与<code>master</code>通过心跳函数进行信息交互</li><li>数据和指令分开传送<br><code>client</code>与<code>Master</code>节点交互来进行元数据操作，比如打开文件、获取文件信息、获取<code>chunk</code>位置等。之后， <code>client</code>直接与Chunkserver节点交互来进行实际的数据读写</li><li>租约（<code>Leases</code>）机制<br>(此机制未在架构图中体现)<code>Master</code>节点给某个<code>chunk</code>的一个副本授予租约，该副本被称为<code>primary chunk</code>。持有租约的<code>Chunkserver</code>有责任在写操作中协调其他副本（<code>secondary chunks</code>）的更新顺序。</li></ol><h1 id="3-GFS如何保证一致性"><a href="#3-GFS如何保证一致性" class="headerlink" title="3 GFS如何保证一致性?"></a>3 GFS如何保证一致性?</h1><p><code>GFS</code>采用了一种宽松的一致性模型来在分布式的环境中保持系统性能和可用性。</p><h2 id="3-1-原子性命名空间操作"><a href="#3-1-原子性命名空间操作" class="headerlink" title="3.1 原子性命名空间操作"></a>3.1 原子性命名空间操作</h2><ul><li><strong>文件命名空间的变更</strong>（例如，创建文件）是<strong>原子性</strong>操作，由<code>master</code>服务器独家处理。</li><li><strong>命名空间锁定</strong>和<strong>操作日志</strong>（记录操作的全局总顺序）保证了这些变更的原子性和正确性。</li></ul><h2 id="3-2-数据变更后的文件区域状态"><a href="#3-2-数据变更后的文件区域状态" class="headerlink" title="3.2 数据变更后的文件区域状态"></a>3.2 数据变更后的文件区域状态</h2><ul><li>在数据变更后，文件区域的状态取决于变更的类型、变更是否成功，以及是否存在并发变更。</li><li>如果所有客户端无论读取哪个副本都看到相同的数据，那么这个文件区域就是一致的。</li><li>如果数据变更后文件区域是一致的，并且客户端可以完整地看到变更写入的内容，那么这个区域就是已定义的。</li><li>当变更在没有并发写入者的干扰下成功时，受影响的区域是已定义的（也就是一致的）。</li><li>并发的成功变更会使区域变得未定义但仍然一致：所有客户端看到的是相同的数据，但可能不反映任何单一变更所写入的内容。通常包含来自多个变更的混合片段。</li><li>失败的变更会使区域变得不一致（因此也是未定义的）：不同的客户端可能在不同时间看到不同的数据。</li></ul><h2 id="3-3-数据变更：写操作和记录追加"><a href="#3-3-数据变更：写操作和记录追加" class="headerlink" title="3.3 数据变更：写操作和记录追加"></a>3.3 数据变更：写操作和记录追加</h2><ul><li><strong>写操作</strong>在应用程序指定的偏移量处执行。</li><li><strong>记录追加</strong>是一种原子操作，即使存在并发变更，也会在GFS选择的偏移量处至少追加一次数据。</li><li><code>GFS</code>可能在中间插入填充或重复的记录，这些被视为不一致。</li><li>在成功的变更之后，变更的文件区域是<strong>已定义</strong>的，并包含最后一次变更的数据。</li></ul><h2 id="3-4-确保一致性的手段"><a href="#3-4-确保一致性的手段" class="headerlink" title="3.4 确保一致性的手段"></a>3.4 确保一致性的手段</h2><ul><li>在序列成功的变更后，变更的文件区域保证是已定义的，并且包含最后一次变更写入的数据。</li><li><code>GFS</code>通过在所有副本上以相同的顺序应用变更来实现这一点。</li><li>使用块版本号来检测任何因为在其<code>chunkserve</code>r关闭时错过变更而变得陈旧的副本。这些陈旧副本不会参与变更，也不会提供给寻求块位置的客户端。这些副本会在最早的机会被垃圾回收。</li></ul><h2 id="3-5-处理故障"><a href="#3-5-处理故障" class="headerlink" title="3.5 处理故障"></a>3.5 处理故障</h2><ul><li><code>GFS</code>通过定期的<code>master</code>与所有块服务器之间的握手以及校验和来识别失败的块服务器和数据损坏。</li><li>数据会尽快从有效副本中恢复，且在<code>GFS</code>能够反应之前，只有当所有副本丢失时，块才会不可逆转地丢失。即使在这种情况下，它也会变得不可用，而不是损坏：应用程序会收到清晰的错误而不是损坏的数据。</li></ul><h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><ul><li>依赖<strong>追加</strong>操作：而非覆盖操作来变更文件，这不仅可以应对一致性和并发问题，而且比随机写入更高效、更能抵御应用程序故障。</li><li>使用<strong>检查点</strong>（<code>Checkpointing</code>）：允许写入者在失败后能够部分地重新开始，同时使读取者避免处理尚未完成的文件数据。</li><li>写入自验证、自识别的记录：通过额外的信息如校验和来确保记录的有效性，以及通过唯一标识符来处理可能的重复记录。</li></ul><blockquote><p>PS: 这一部分论文中感觉有些泛泛而谈, 缺乏距离和图示, 感觉有些迷糊</p></blockquote><h1 id="4-租约-Leases-机制"><a href="#4-租约-Leases-机制" class="headerlink" title="4 租约(Leases)机制"></a>4 租约(<code>Leases</code>)机制</h1><h2 id="4-1-租约-Leases-机制的工作流程"><a href="#4-1-租约-Leases-机制的工作流程" class="headerlink" title="4.1 租约(Leases)机制的工作流程"></a>4.1 租约(<code>Leases</code>)机制的工作流程</h2><p>租约机制主要是用于协调分布式环境下的多个对相同<code>chunk</code>的变更操作, 因为多个变更操作的变更顺序很重要, 所有副本在应用变更时都遵循这个顺序。<code>Leases</code>的设计思路是将某一时间段内的处理任务交付给某一个<code>chunkserver</code>完成, 称为其获得了租约(<code>lease</code>), </p><p>具体流程为:</p><ol><li><code>client</code>询问<code>master</code>哪个数据块服务器持有当前对于该数据块的租约，以及其他副本的位置。如果没有任何副本持有租约，<code>master</code>会选择一个副本授予租约（未展示）, 这个被授予租约的<code>server</code>称为<code>primary replica</code>, 其协调的<code>server</code>称为<code>secondary replica</code>。</li><li><code>master</code>回复<code>client</code>其<code>primary replica</code>的身份和其他（次级）副本的位置。<code>client</code>缓存这些数据以用于未来的变更。只有当<code>primary replica</code>变得无法联系，或者回复说它不再持有租约时，<code>client</code>才需要再次联系<code>master</code>。</li><li><code>client</code>将数据推送到所有副本。<code>client</code>可以按任何顺序这么做。每个数据块服务器都会将数据存储在一个内部的<code>LRU</code>缓冲区中，直到数据被使用或者过时。通过将数据流与控制流解耦，我们可以根据网络拓扑优化昂贵的数据流的调度，而不考虑哪个数据块服务器是<code>primary replica</code>。第3.2节将进一步讨论这一点。</li><li>所有副本确认收到数据后，<code>client</code>向<code>primary replica</code>发送写请求。该请求标识了之前推送给所有副本的数据。<code>primary replica</code>为它接收到的所有变更分配连续的序列号，可能来自多个<code>client</code>，这提供了必要的序列化。它按照序列号顺序将变更应用到自己的本地状态。</li><li><code>primary replica</code>将写请求转发给所有次级副本。每个次级副本按照<code>primary replica</code>分配的相同序列号顺序应用变更。</li><li>所有次级副本都回复<code>primary replica</code>，表明它们已经完成了操作。</li><li><code>primary replica</code>回复<code>client</code>。在任何副本遇到的任何错误都会报告给<code>client</code>。如果出现错误，写操作可能已经在<code>primary replica</code>和任意子集的次级副本上成功。（如果在<code>primary replica</code>上失败，它不会被分配序列号并转发。）<code>client</code>请求被视为失败，而且被修改的区域处于不一致状态。我们的<code>client</code>代码通过重试失败的变更来处理此类错误。在回退到从写操作开始的重试之前，它会在步骤（3）到（7）中尝试几次。</li></ol><h2 id="4-2-流程图"><a href="#4-2-流程图" class="headerlink" title="4.2 流程图"></a>4.2 流程图</h2><p>下图所示为摘自论文中的读写流程实例:</p><p><img src="/../../images/lease_process.png" alt="lease_process"></p><blockquote><p>需要补充说明的是数据流动并不是随意的, 为了充分利用每台机器的网络带宽，数据是沿着数据块服务器的链线性推送的, 即每台机器都将数据转发到网络拓扑中尚未接收数据的“最近”的机器。</p></blockquote><h1 id="5-Master节点-命名空间与锁"><a href="#5-Master节点-命名空间与锁" class="headerlink" title="5 Master节点: 命名空间与锁"></a>5 <code>Master</code>节点: 命名空间与锁</h1><p>与许多传统文件系统不同，<code>GFS</code>没有列出该目录中所有文件的每个目录的数据结构。它也不支持文件或目录的别名（即硬链接或符号链接）。<code>GFS</code>在逻辑上将其名称空间表示为一个查找表，将完整路径名映射到元数据。通过前缀压缩，可以在内存中有效地表示这个表。名称空间树中的每个节点（无论是绝对文件名还是绝对目录名）都有一个关联的读写锁。</p><p>每个操作在运行前都会获取一组锁。通常，如果它涉及到<code>/d1/d2/.../dn/leaf</code>，它将获得目录名<code>/d1、/d1/d2、...、/d1/d2/.../dn</code>的读锁，以及完整路径名<code>/d1/d2/.../dn/leaf</code>的读锁或写锁。请注意，<code>leaf</code>可能是文件或目录，具体取决于操作。</p><p><strong>一个获取锁的例子</strong></p><blockquote><p>需求:如何防止以下情况: 当创建<code>/home/user</code>文件夹的快照到<code>/save/user</code>时, 文件<code>/home/user/foo被创建</code>。</p></blockquote><p>快照操作获取的锁:</p><ul><li><code>/home</code>和<code>/save</code>的读锁</li><li><code>/home/user</code>和<code>/save/user</code>的写锁。<br>文件创建获取的锁</li><li><code>/home</code>和<code>/home/user</code>的读锁</li><li><code>/home/user/foo</code>的写锁。</li></ul><p>可以看出, 上述2个操作存在<code>/home/user</code>的锁冲突, 因此将被序列化。</p><p><strong>误区说明</strong><br>文件创建不需要对父目录的写锁，因为没有<code>目录</code>或类似<code>inode</code>的数据结构需要防止修改。名称上的读锁足以防止父目录被删除。</p><h1 id="6-小结"><a href="#6-小结" class="headerlink" title="6 小结"></a>6 小结</h1><p><code>GFS</code>论文中涉及很多的细节在此处并没有完全列出, 例如确保内容完整性的<code>checksum</code>, 主节点的<code>recover</code>等, 因为这些内容较为琐碎且个人认为不算<code>GFS</code>最出色的特性, 个人认为<code>GFS</code>最值得学习的特性包括:</p><ol><li>单<code>master</code>结构, <code>master</code>尽量只负责处理逻辑</li><li>租约机制: 将任务指派给<code>server</code>解决, 用租约解决潜在的不一致问题</li><li>数据和逻辑指令分别传送: 简化了传送的内容与逻辑复杂度</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本节课是解释谷歌的分布式文件系统&lt;code&gt;GFS&lt;/code&gt;, 强烈建议阅读其&lt;a href=&quot;https://pdos.csail.mit.edu/6.824/papers/gfs.pdf&quot;&gt;论文&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-GFS简介&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="GFS" scheme="http://example.com/tags/GFS/"/>
    
  </entry>
  
  <entry>
    <title>SQL进阶-1</title>
    <link href="http://example.com/2023/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E8%BF%9B%E9%98%B6-1/"/>
    <id>http://example.com/2023/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/SQL%E8%BF%9B%E9%98%B6-1/</id>
    <published>2023-12-27T14:33:41.000Z</published>
    <updated>2023-12-29T05:42:02.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-字符串操作"><a href="#1-字符串操作" class="headerlink" title="1 字符串操作"></a>1 字符串操作</h1><h2 id="1-1-通配符"><a href="#1-1-通配符" class="headerlink" title="1.1 通配符"></a>1.1 通配符</h2><p>以下是SQL中使用<code>LIKE</code>操作符时支持的2种通配符：</p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td><code>%</code></td><td>匹配任意数量的字符，甚至可以是零个字符。</td></tr><tr><td><code>_</code></td><td>匹配任意单一字符。</td></tr></tbody></table><h2 id="1-2-escape关键字"><a href="#1-2-escape关键字" class="headerlink" title="1.2 escape关键字"></a>1.2 <code>escape</code>关键字</h2><p>当需要在 <code>LIKE</code> 子句中搜索 <code>%</code> 或 <code>_</code> 本身时，<code>ESCAPE</code> 关键字让数据库知道紧随其后的 <code>%</code> 或 <code>_</code> 是要被直接匹配的字符，而不是作为通配符。</p><p>下面是使用 <code>ESCAPE</code> 关键字的一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找包含下划线字符 &#x27;_&#x27; 的所有名称</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Employees <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%\_%&#x27;</span> <span class="keyword">ESCAPE</span> <span class="string">&#x27;\&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，反斜杠 <code>\</code> 被用作转义字符。这意味着 <code>\_</code> 在 <code>LIKE</code> 子句中被解释为普通的下划线字符 <code>_</code>，而不是通配符。因此，这个查询将会返回 <code>name</code> 字段中包含实际下划线字符 <code>_</code> 的所有记录。</p><p>要正确地使用 <code>ESCAPE</code> 关键字，你需要：</p><ol><li>选择一个不会在搜索模式中作为普通字符出现的字符作为转义字符。</li><li>在 <code>ESCAPE</code> 子句中指定这个转义字符。</li><li>在你的 <code>LIKE</code> 模式中，将该转义字符放在你要作为普通字符搜索的 <code>%</code> 或 <code>_</code> 之前。</li></ol><p>不同的数据库系统可能对转义字符的默认值有不同的规定，有些系统甚至可能不需要显式声明 <code>ESCAPE</code> 子句，除非你想要改变默认的转义字符。始终建议查看特定数据库的文档以确定其行为。</p><h1 id="2-集合操作"><a href="#2-集合操作" class="headerlink" title="2 集合操作"></a>2 集合操作</h1><h2 id="2-1-集合交集、并集和差集"><a href="#2-1-集合交集、并集和差集" class="headerlink" title="2.1 集合交集、并集和差集"></a>2.1 集合交集、并集和差集</h2><p>集合运算允许对两个查询结果集进行数学上的集合操作。以下是SQL支持的主要集合运算符：</p><table><thead><tr><th>集合运算符</th><th>描述</th></tr></thead><tbody><tr><td><code>UNION</code></td><td>将两个或多个查询结果合并为一个结果集，同时移除重复的行。</td></tr><tr><td><code>UNION ALL</code></td><td>将两个或多个查询结果合并为一个结果集，包含所有行，不移除重复的行。</td></tr><tr><td><code>INTERSECT</code></td><td>返回两个查询结果的交集，即两个结果集中都存在的行。</td></tr><tr><td><code>INTERSECT ALL</code></td><td>返回两个查询结果的交集，即两个结果集中都存在的行, 不移除重复的行。</td></tr><tr><td><code>EXCEPT</code></td><td>返回第一个查询结果中存在而在第二个查询结果中不存在的行。</td></tr><tr><td><code>EXCEPT ALL</code></td><td>返回第一个查询结果中存在而在第二个查询结果中不存在的行， 不移除重复的行。</td></tr></tbody></table><blockquote><p>集合运算要求各查询结果的列数和数据类型必须匹配。</p></blockquote><p>下面是一个使用集合运算符的例子，假定有两个表格 <code>Table1</code> 和 <code>Table2</code>, 其列数和数据类型相同：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- case1 返回两个表中都有的唯一记录</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> Table1</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> Table2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- case2 返回两个表中所有记录，包括重复项</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> Table1</span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> Table2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- case3 返回两个表中共同的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> Table1</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> Table2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- case4 返回两个表中共同的记录, 不去重</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> Table1</span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> Table2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- case5 返回只存在于第一个表中的记录</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> Table1</span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> Table2;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- case6 返回只存在于第一个表中的记录, 不去重</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> Table1</span><br><span class="line"><span class="keyword">EXCEPT</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s) <span class="keyword">FROM</span> Table2;</span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>集合运算中的<code>all</code>的情况如下:</p><ol><li>在<code>case2</code>中, 假设<code>Table1</code>中某个相同记录有4个, <code>Table2</code>中相同记录有3个, 结果的相同记录就会有7个(取二者之和)</li><li>在<code>case4</code>中, 假设<code>Table1</code>中某个相同记录有4个, <code>Table2</code>中相同记录有3个, 结果的相同记录就会有3个(取最小值)</li><li>在<code>case6</code>中, 假设<code>Table1</code>中某个相同记录有4个, <code>Table2</code>中相同记录有3个, 结果的相同记录就会有1个(第一个减去第二个, 前提不为负)</li></ol><h2 id="2-2-比较运算"><a href="#2-2-比较运算" class="headerlink" title="2.2 比较运算"></a>2.2 比较运算</h2><p><code>SQL</code> 中，有些关键字用来表示特定的集合关系操作。这些关键字通常用在子查询中，用来比较一个值与一组值的关系。以下是一些常用的集合关系操作符，以及它们的用途和语法的简要总结：</p><table><thead><tr><th>操作符</th><th>描述</th><th>用法示例</th></tr></thead><tbody><tr><td><code>SOME</code> 或 <code>ANY</code></td><td>检查是否至少有一个子查询的返回值满足给定条件</td><td><code>value operator SOME (subquery)</code></td></tr><tr><td><code>ALL</code></td><td>检查是否所有子查询的返回值都满足给定条件</td><td><code>value operator ALL (subquery)</code></td></tr><tr><td><code>EXISTS</code></td><td>检查子查询是否返回了任何行</td><td><code>EXISTS (subquery)</code></td></tr><tr><td><code>IN</code></td><td>检查表达式的值是否在子查询或列表中的一个值</td><td><code>value IN (subquery or value list)</code></td></tr><tr><td><code>NOT IN</code></td><td>检查表达式的值是否不在子查询或列表中的任何一个值</td><td><code>value NOT IN (subquery or value list)</code></td></tr></tbody></table><p>请注意，<code>EXCEPT</code> 不是一个集合关系操作，而是一个集合运算符，用于返回两个集合的差集；在此表中未包含。</p><p>以下是一些详细的用法示例：</p><p><strong>SOME 或 ANY</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查表中是否有至少一个元素的列值大于10</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="operator">&gt;</span> <span class="keyword">SOME</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> another_table);</span><br></pre></td></tr></table></figure><p><strong>ALL</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查表中的元素是否其列值都大于另一个表中所有元素的列值</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="operator">&gt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> another_table);</span><br></pre></td></tr></table></figure><p><strong>EXISTS</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 仅当子查询返回至少一行时，查询结果才会包含行</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> another_table <span class="keyword">WHERE</span> <span class="keyword">condition</span>);</span><br></pre></td></tr></table></figure><p><strong>IN</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查某个列的值是否在子查询或列表中指定的值集中</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> another_table);</span><br></pre></td></tr></table></figure><p><strong>NOT IN</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查某个列的值是否不在子查询或列表中指定的值集中</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> another_table);</span><br></pre></td></tr></table></figure><p><strong>补充:&lt;&gt;</strong><br>在 SQL 中，<code>&lt;&gt;</code> 是不等于的比较运算符。当它与 <code>SOME</code> 或 <code>ALL</code> 关键字结合使用时，它们的含义如下：</p><p><strong><code>&lt;&gt; SOME</code></strong></p><p><code>&lt;&gt; SOME (subquery)</code>是在检查主查询中的值是否不等于子查询返回的值集中的至少一个值。这意味着只要主查询中的值与子查询中返回的任一值不相等，条件就满足。实际上，**<code>&lt;&gt; SOME</code> 是 <code>EXISTS</code> 的同义词**，因为通常只要子查询中存在至少一个不同的值，这个条件就为真。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查主表中至少有一行的 column_name 不等于子查询返回的任一行的 column_name</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> main_table</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="operator">&lt;&gt;</span> <span class="keyword">SOME</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> sub_table);</span><br></pre></td></tr></table></figure><p><strong><code>&lt;&gt; ALL</code></strong></p><p><code>&lt;&gt; ALL (subquery)</code>是在检查主查询中的值是否不等于子查询返回的所有值。这意味着只有当主查询中的值与子查询中返回的每个值都不相等时，条件才满足。它是一种更严格的比较，因为它要求与子查询返回的每个值都不匹配。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 检查主表中所有行的 column_name 是否都不等于子查询返回的任何一行的 column_name</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> main_table</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="operator">&lt;&gt;</span> <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> column_name <span class="keyword">FROM</span> sub_table);</span><br></pre></td></tr></table></figure><p>在使用这些运算符时，重要的是要注意子查询可能返回的 <code>NULL</code> 值。<code>NULL</code> 在 SQL 中表示未知的值，因此任何与 <code>NULL</code> 的比较操作都会返回 <code>UNKNOWN</code>。这可能会影响 <code>SOME</code> 和 <code>ALL</code> 运算符的行为，因为 <code>UNKNOWN</code> 不等同于 <code>TRUE</code> 或 <code>FALSE</code>。</p><p>使用集合关系操作符的时候，子查询通常返回一个列的值集合，主查询中的表达式或列与这个值集进行比较。你可以使用比较操作符如 <code>=</code>、<code>&lt;</code>、<code>&gt;</code> 等来定义这些比较的具体条件。</p><blockquote><p>经典误区<br><code>&lt;&gt; SOME</code> 是 <code>EXISTS</code> 的同义词, 而并不等价于<code>NOT IN</code>, 但<code>=SOME</code>等价于<code>IN</code><br><code>&lt;&gt; ALL</code>等价于<code>NOT IN</code>, 但<code>=ALL</code>不等价于<code>IN</code></p></blockquote><h1 id="3-unknown、空值和重复性测试"><a href="#3-unknown、空值和重复性测试" class="headerlink" title="3 unknown、空值和重复性测试"></a>3 <code>unknown</code>、空值和重复性测试</h1><h2 id="3-1-unknown是什么"><a href="#3-1-unknown是什么" class="headerlink" title="3.1 unknown是什么"></a>3.1 <code>unknown</code>是什么</h2><p>在处理 <code>WHERE</code> 子句中的条件时，每个条件的结果通常可以是 <code>TRUE</code>、<code>FALSE</code> 或 <code>UNKNOWN</code>。</p><p><code>UNKNOWN</code> 是 SQL 中的一个特殊的逻辑结果，它出现在比较涉及到 <code>NULL</code> 值时。在 SQL 中，<code>NULL</code> 表示一个未知的或缺失的值。因为 <code>NULL</code> 本质上表示“无数据”，所以当你尝试使用比较操作符（如 <code>=</code>、<code>&lt;</code>、<code>&gt;</code> 等）进行条件比较时，如果任一操作数是 <code>NULL</code>，结果就不是 <code>TRUE</code> 或 <code>FALSE</code>，而是 <code>UNKNOWN</code>。</p><p>这里有一些例子来说明 <code>UNKNOWN</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 假设 column_name 是 NULL</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="operator">=</span> <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="comment">-- 结果未知（UNKNOWN），因为 column_name 是 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="operator">!=</span> <span class="string">&#x27;value&#x27;</span>;</span><br><span class="line"><span class="comment">-- 结果同样未知（UNKNOWN），因为 column_name 是 NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 IS NULL 来检查 NULL 值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> column_name <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br><span class="line"><span class="comment">-- 结果为 TRUE，如果 column_name 是 NULL</span></span><br></pre></td></tr></table></figure><p>当有 <code>UNKNOWN</code> 结果时，这行数据不会被包含在 <code>WHERE</code> 子句过滤后的结果集中。只有条件为 <code>TRUE</code> 的行才会返回。</p><p>在 SQL 中处理 <code>NULL</code> 和 <code>UNKNOWN</code> 的正确方法通常涉及到使用 <code>IS NULL</code> 或 <code>IS NOT NULL</code> 操作符，或者在比较之前使用函数例如 <code>COALESCE</code> 或 <code>NVL</code>（取决于数据库系统）来处理潜在的 <code>NULL</code> 值。SQL <code>中，NULL</code> 表示一个未知的或缺失的值。因为 NULL 本质上表示“无数据”，所以当你尝试使用比较操作符（如 &#x3D;、&lt;、&gt; 等）进行条件比较时，如果任一操作数是 <code>NULL</code>，结果就不是 <code>TRUE</code> 或 <code>FALSE，而是</code> <code>UNKNOWN。</code></p><p>这是因为 <code>SQL</code> 的三值逻辑（true, false, unknown）是为了处理可能的未知或缺失的信息，它与传统的布尔逻辑不同，后者只有两个值：true 和 false。在 <code>SQL</code> 的三值逻辑中，只有当比较的结果确定为真时，行才会满足 <code>WHERE</code> 子句的条件。</p><h2 id="3-2-unknown与逻辑运算"><a href="#3-2-unknown与逻辑运算" class="headerlink" title="3.2 unknown与逻辑运算"></a>3.2 <code>unknown</code>与逻辑运算</h2><p>在 SQL 中，逻辑运算符 <code>AND</code>、<code>OR</code>、<code>NOT</code> 与 <code>TRUE</code>、<code>FALSE</code> 和 <code>UNKNOWN</code> 之间的运算遵循三值逻辑规则。在这种逻辑下，如果任何操作数是 <code>UNKNOWN</code>，那么结果可能也是 <code>UNKNOWN</code>，除了某些特定情况。以下是逻辑运算符与这些逻辑值的结合结果：</p><h3 id="AND-运算"><a href="#AND-运算" class="headerlink" title="AND 运算"></a>AND 运算</h3><table><thead><tr><th>Expression</th><th>TRUE</th><th>FALSE</th><th>UNKNOWN</th></tr></thead><tbody><tr><td><strong>TRUE</strong></td><td>TRUE</td><td>FALSE</td><td>UNKNOWN</td></tr><tr><td><strong>FALSE</strong></td><td>FALSE</td><td>FALSE</td><td>FALSE</td></tr><tr><td><strong>UNKNOWN</strong></td><td>UNKNOWN</td><td>FALSE</td><td>UNKNOWN</td></tr></tbody></table><h3 id="OR-运算"><a href="#OR-运算" class="headerlink" title="OR 运算"></a>OR 运算</h3><table><thead><tr><th>Expression</th><th>TRUE</th><th>FALSE</th><th>UNKNOWN</th></tr></thead><tbody><tr><td><strong>TRUE</strong></td><td>TRUE</td><td>TRUE</td><td>TRUE</td></tr><tr><td><strong>FALSE</strong></td><td>TRUE</td><td>FALSE</td><td>UNKNOWN</td></tr><tr><td><strong>UNKNOWN</strong></td><td>TRUE</td><td>UNKNOWN</td><td>UNKNOWN</td></tr></tbody></table><h3 id="NOT-运算"><a href="#NOT-运算" class="headerlink" title="NOT 运算"></a>NOT 运算</h3><table><thead><tr><th>Expression</th><th>Result</th></tr></thead><tbody><tr><td><strong>TRUE</strong></td><td>FALSE</td></tr><tr><td><strong>FALSE</strong></td><td>TRUE</td></tr><tr><td><strong>UNKNOWN</strong></td><td>UNKNOWN</td></tr></tbody></table><p>在 <code>AND</code> 运算中，如果任一操作数为 <code>FALSE</code>，则结果总是 <code>FALSE</code>，无论另一个操作数是什么。如果两个操作数都是 <code>TRUE</code>，结果才是 <code>TRUE</code>。如果操作数之一是 <code>UNKNOWN</code>，而另一个是 <code>TRUE</code>，结果是 <code>UNKNOWN</code>。</p><p>在 <code>OR</code> 运算中，如果任一操作数为 <code>TRUE</code>，则结果总是 <code>TRUE</code>，无论另一个操作数是什么。只有当两个操作数都是 <code>FALSE</code> 时，结果才是 <code>FALSE</code>。如果一个操作数是 <code>UNKNOWN</code> 而另一个是 <code>FALSE</code>，结果是 <code>UNKNOWN</code>。</p><p><code>NOT</code> 运算是一个一元运算符，它简单地反转其单一操作数的值：<code>NOT TRUE</code> 是 <code>FALSE</code>，<code>NOT FALSE</code> 是 <code>TRUE</code>，而 <code>NOT UNKNOWN</code> 仍然是 <code>UNKNOWN</code>。</p><p><strong>记忆小妙招</strong><br>可以如下定义三者的优先级: <code>TRUE</code> &gt; <code>UNKNOWN</code> &gt; <code>FALSE</code></p><ul><li><code>AND</code>: 取优先级更低的那一个</li><li><code>OR</code>: 取优先级更高的那一个</li><li><code>NOT</code>: 取对称的优先级</li></ul><p>可以看出, 以上的结果满足表格定义</p><h2 id="3-3-聚集函数对空值的处理"><a href="#3-3-聚集函数对空值的处理" class="headerlink" title="3.3 聚集函数对空值的处理"></a>3.3 聚集函数对空值的处理</h2><ol><li><code>count(*)</code> 不忽略空值</li><li>其余所有聚集函数都忽略空值</li></ol><h2 id="3-4-重复性测试"><a href="#3-4-重复性测试" class="headerlink" title="3.4 重复性测试"></a>3.4 重复性测试</h2><p><code>UNIQUE</code> 在子查询的结果中判断是否存在重复元组, 无重复返回<code>true</code>, 否则返回&#96;false。以下是一个简单的例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line">    <span class="keyword">FROM</span> students</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">unique</span> (<span class="keyword">SELECT</span> id <span class="keyword">FROM</span> course);</span><br></pre></td></tr></table></figure><p>如果<code>cource</code>表中<code>id</code>没有重复项, 则执行对<code>students</code>中<code>name</code>的选择。<br>同时, 还有<code>NOT UNIQUE</code>的用法, 与之&#x3D;相反就是了。</p><blockquote><p>在DDL中, <code>UNIQUE</code> 是一种约束，用于确保列或一组列中的所有值都是唯一的，即不重复的 ,与此处的用法不同</p></blockquote><h1 id="5-子查询与CTE"><a href="#5-子查询与CTE" class="headerlink" title="5 子查询与CTE"></a>5 子查询与<code>CTE</code></h1><h2 id="5-1-lateral关键字"><a href="#5-1-lateral关键字" class="headerlink" title="5.1 lateral关键字"></a>5.1 <code>lateral</code>关键字</h2><p><code>lateral</code> 作用是允许子查询引用在它之前声明的表，从而在子查询中使用来自外部查询的列或表达式。</p><blockquote><p><code>lateral</code>在<code>SQL:2003</code>之后才可以使用</p></blockquote><p>下面是一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> instructor I1, <span class="keyword">lateral</span> (<span class="keyword">SELECT</span> <span class="built_in">avg</span>(salary) <span class="keyword">as</span> avg_salary</span><br><span class="line">    <span class="keyword">FROM</span> instructor I2</span><br><span class="line">    <span class="keyword">WHERE</span> I2.dept_name<span class="operator">=</span>I1.dept_name)</span><br></pre></td></tr></table></figure><h2 id="5-2-CTE"><a href="#5-2-CTE" class="headerlink" title="5.2 CTE"></a>5.2 <code>CTE</code></h2><p><code>CTE</code>又称为<code>with子查询</code>中, 用于创建临时结果集。<code>CTE</code> 类似于临时表，仅在查询执行期间存在，并且对于查询的其余部分可见。</p><p>CTE 通常用于提高查询的可读性和可维护性，尤其是对于复杂的查询。CTE 的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> cte_name (column1, column2, ...) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="comment">-- CTE 查询体</span></span><br><span class="line">    <span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line">    <span class="keyword">FROM</span> some_table</span><br><span class="line">    <span class="keyword">WHERE</span> <span class="keyword">condition</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">-- 主查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> cte_name;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>cte_name</code> 是 CTE 的名称，可以在主查询中引用。</li><li><code>(column1, column2, ...)</code> 是可选的列名列表，用于为 CTE 结果集的列命名。</li><li>CTE 查询体是实际的查询，它定义了临时结果集。</li></ul><p>下面是一个例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> MyCTE (EmployeeIDAlias, FirstNameAlias, LastNameAlias) <span class="keyword">AS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        EmployeeID,</span><br><span class="line">        FirstName,</span><br><span class="line">        LastName</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">        Employees</span><br><span class="line">    <span class="keyword">WHERE</span></span><br><span class="line">        DepartmentID <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    EmployeeIDAlias <span class="keyword">AS</span> ID,</span><br><span class="line">    FirstNameAlias <span class="keyword">AS</span> <span class="keyword">First</span>,</span><br><span class="line">    LastNameAlias <span class="keyword">AS</span> <span class="keyword">Last</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    MyCTE;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-case字句"><a href="#5-case字句" class="headerlink" title="5 case字句"></a>5 case字句</h1><p>引入一道题目:<a href="https://www.hackerrank.com/challenges/binary-search-tree-1/problem">Binary Tree Nodes</a></p><p>给定一个表BST，包含两列:N和P，其中N表示二叉树中一个节点的值，P是N的父节点。<br><img src="/../../../images/Binary-Tree-Nodes-1.png" alt="Binary-Tree-Nodes-1"><br>编写一个查询，查找按节点值排序的二叉树的节点类型。为每个节点输出以下命令之一:<br>Root: 如果节点为根节点。<br>Leaf: 如果节点为叶子节点。<br>Inner: 如果节点为中间节点。</p><ul><li>Sample Input<br><img src="/../../../images/Binary-Tree-Nodes-2.png" alt="Binary-Tree-Nodes-2"></li><li>Sample Output<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 Leaf</span><br><span class="line">2 Inner</span><br><span class="line">3 Leaf</span><br><span class="line">5 Root</span><br><span class="line">6 Leaf</span><br><span class="line">8 Inner</span><br><span class="line">9 Leaf</span><br></pre></td></tr></table></figure></li><li>Explanation<br><img src="/../../../images/Binary-Tree-Nodes-3.png" alt="Binary-Tree-Nodes-3"></li></ul><p>解法: 使用<code>Case</code>字句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> N, <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> P <span class="keyword">IS</span> <span class="keyword">null</span> <span class="keyword">THEN</span> <span class="string">&#x27;Root&#x27;</span></span><br><span class="line">    <span class="keyword">WHEN</span> N <span class="keyword">IN</span> (<span class="keyword">SELECT</span> P <span class="keyword">FROM</span> BST <span class="keyword">WHERE</span> P <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>) <span class="keyword">THEN</span> <span class="string">&#x27;Inner&#x27;</span></span><br><span class="line">    <span class="keyword">ELSE</span> <span class="string">&#x27;Leaf&#x27;</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> node_type</span><br><span class="line"><span class="keyword">FROM</span> BST</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> N;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-字符串操作&quot;&gt;&lt;a href=&quot;#1-字符串操作&quot; class=&quot;headerlink&quot; title=&quot;1 字符串操作&quot;&gt;&lt;/a&gt;1 字符串操作&lt;/h1&gt;&lt;h2 id=&quot;1-1-通配符&quot;&gt;&lt;a href=&quot;#1-1-通配符&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据库" scheme="http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="SQL" scheme="http://example.com/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.8540(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)</title>
    <link href="http://example.com/2023/12/25/MIT6.8540/Lec02%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/12/25/MIT6.8540/Lec02%E7%AC%94%E8%AE%B0/</id>
    <published>2023-12-25T09:01:51.000Z</published>
    <updated>2024-01-02T07:23:03.268Z</updated>
    
    <content type="html"><![CDATA[<p>这节课主要是对分布式整体的概念和<code>Go</code>的一些相关介绍, 包括线程、RPC、同步原语、管道等，相对简单， 简单记录一下， 顺带附上我进行Lab1实验时相关知识的补充</p><h1 id="1-同步原语"><a href="#1-同步原语" class="headerlink" title="1 同步原语"></a>1 同步原语</h1><p>课程举了一个投票的例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">finished := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">cond := sync.NewCond(&amp;mu)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">vote := requestVote()</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> vote &#123;</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">finished++</span><br><span class="line">cond.Broadcast()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">for</span> count &lt; <span class="number">5</span> &amp;&amp; finished != <span class="number">10</span> &#123;</span><br><span class="line">cond.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count &gt;= <span class="number">5</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;received 5+ votes!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;lost&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestVote</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line"><span class="keyword">return</span> rand.Int() % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="1-1-锁"><a href="#1-1-锁" class="headerlink" title="1.1 锁"></a>1.1 <strong>锁</strong></h1><p>整体而言<code>go</code>中锁的语法和<code>C/C++</code>区别不大, 但这里介绍一下<code>defer</code>:</p><ul><li><code>defer</code> 语句后面跟着的是一个函数调用，这个调用不会立即执行。而是延迟到包含它的函数执行完毕时才执行</li><li>如果有多个 <code>defer</code> 语句，它们的调用顺序是后进先出的，即最后一个 <code>defer</code> 的函数调用将会第一个被执行</li><li><strong>重点:<code>defer</code> 的调用不会在每次循环结束时执行，而是会在包围 defer 的函数返回时才执行</strong> &#x3D;&gt; 如果有锁需要释放的话, 需要在循环体内手动释放?</li></ul><h1 id="1-2-条件变量"><a href="#1-2-条件变量" class="headerlink" title="1.2 条件变量"></a>1.2 <strong>条件变量</strong></h1><p>还是相同的例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">finished := <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">cond := sync.NewCond(&amp;mu)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">vote := requestVote()</span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> vote &#123;</span><br><span class="line">count++</span><br><span class="line">&#125;</span><br><span class="line">finished++</span><br><span class="line">cond.Broadcast()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mu.Lock()</span><br><span class="line"><span class="keyword">for</span> count &lt; <span class="number">5</span> &amp;&amp; finished != <span class="number">10</span> &#123;</span><br><span class="line">cond.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count &gt;= <span class="number">5</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;received 5+ votes!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;lost&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestVote</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line"><span class="keyword">return</span> rand.Int() % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没啥好讲的…<br>条件变量的三个主要方法是：</p><ul><li><code>Wait</code>：调用这个方法会阻塞调用协程，直到其他协程在相同的条件变量上调用 Signal 或 Broadcast。</li><li><code>Signal</code>：唤醒等待该条件变量的一个协程（如果存在的话）。</li><li><code>Broadcast</code>：唤醒等待该条件变量的所有协程。</li></ul><h2 id="1-3-WaitGroup协程同步"><a href="#1-3-WaitGroup协程同步" class="headerlink" title="1.3 WaitGroup协程同步"></a>1.3 <code>WaitGroup</code>协程同步</h2><p><code>sync.WaitGroup </code>用于等待一组协程的完成。一个 <code>WaitGroup</code> 等待一系列的事件，主要的用法包括三个方法：</p><ul><li><code>Add</code> 方法: 在启动协程之前，使用 <code>Add</code> 方法来设置要等待的事件数量。通常这个值设置为即将启动的协程的数量。</li><li><code>Done</code> 方法: 当协程的工作完成时，调用 <code>Done</code> <code>方法。Done</code> 方法减少 <code>WaitGroup</code> 的内部计数器，通常等价于 <code>Add(-1)</code>。</li><li><code>Wait</code> 方法: 使用 Wait 方法来阻塞，直到所有的事件都已通过调用 <code>Done</code> 方法来报告完成。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有三个并行的任务需要执行</span></span><br><span class="line">    tasks := <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Add方法来设置WaitGroup的计数器</span></span><br><span class="line">    wg.Add(tasks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= tasks; i++ &#123;</span><br><span class="line">        <span class="comment">// 启动一个协程</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done() <span class="comment">// 确保在协程的末尾调用Done来递减计数器</span></span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;Task %d finished\n&quot;</span>, i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait会阻塞，直到WaitGroup的计数器减为0</span></span><br><span class="line">    wg.Wait()</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><ol><li>不要复制 <code>WaitGroup</code>。如果需要将 WaitGroup 传递给函数，应使用指针。</li><li>避免在协程内部调用 <code>Add</code> 方法，因为这可能会导致计数器不准确。最好在启动协程之前添加所需的计数。</li><li>使用 <code>Done</code> 方法是减少 <code>WaitGroup</code> 计数器的推荐方式，它等价于 <code>Add(-1)</code>。</li></ol><h1 id="2-通道"><a href="#2-通道" class="headerlink" title="2 通道"></a>2 通道</h1><h2 id="2-1-案例"><a href="#2-1-案例" class="headerlink" title="2.1 案例"></a>2.1 案例</h2><p>还是投票…<br><code>go</code>的通道可以实现无锁的并发访问, 核心在于其保证通道写入在不同协程间不会冲突</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch &lt;- requestVote()</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">v := &lt;-ch</span><br><span class="line"><span class="keyword">if</span> v &#123;</span><br><span class="line">count += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count &gt;= <span class="number">5</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;received 5+ votes!&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;lost&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestVote</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line"><span class="keyword">return</span> rand.Int()%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-带缓冲的通道"><a href="#2-2-带缓冲的通道" class="headerlink" title="2.2 带缓冲的通道"></a>2.2 带缓冲的通道</h2><p>另外, 通道还支持带缓冲:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufferedCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>) <span class="comment">// 缓冲大小为2</span></span><br></pre></td></tr></table></figure><p>两种通道区别如下:</p><ul><li>不带缓冲的通道在发送操作和接收操作之间进行同步：发送会阻塞，直到有另一个协程来接收数据；接收会阻塞，直到有另一个协程发送数据。</li><li>带缓冲的通道有一个固定大小的缓冲区。发送操作只在缓冲区满时阻塞，接收操作只在缓冲区空时阻塞。</li></ul><h2 id="2-3-SELECT和通道"><a href="#2-3-SELECT和通道" class="headerlink" title="2.3 SELECT和通道"></a>2.3 SELECT和通道</h2><p><code>select</code>允许协程在多个通道操作上等待。select 会阻塞，直到其中一个通道操作可以执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-ch1:</span><br><span class="line">    <span class="comment">// 从ch1接收消息</span></span><br><span class="line"><span class="keyword">case</span> ch2 &lt;- msg:</span><br><span class="line">    <span class="comment">// 发送消息到ch2</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果以上都不可执行，则执行默认操作（非阻塞）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-Context控制上下文"><a href="#3-Context控制上下文" class="headerlink" title="3 Context控制上下文"></a>3 Context控制上下文</h1><h2 id="3-1-Context-接口"><a href="#3-1-Context-接口" class="headerlink" title="3.1 Context 接口"></a>3.1 Context 接口</h2><p><code>Context 类型</code>用于创建和操纵上下文的函数,用于定义截止日期、取消信号以及其他请求范围的值的接口。它设计用来传递给请求范围的数据、取消信号和截止时间到不同的协程中，以便于管理它们的生命周期。先来看<code>Context 接口</code>:<br><code>Context</code> 接口定义了四个方法：</p><ol><li><code>Deadline</code>：返回 <code>Context</code> 被取消的时间，也就是完成工作的截止时间（如果有的话）。</li><li><code>Done</code>：返回一个 <code>Channel</code>，这个 <code>Channel</code> 会在当前工作应当被取消时关闭。</li><li><code>Err</code>：返回 <code>Context</code> 结束的原因，它只会在 <code>Done</code> 返回的 <code>Channel</code> 被关闭后返回非空值。</li><li><code>Value</code>：从 <code>Context</code> 中检索键对应的值。</li></ol><h3 id="3-2-操纵上下文的函数"><a href="#3-2-操纵上下文的函数" class="headerlink" title="3.2 操纵上下文的函数"></a>3.2 操纵上下文的函数</h3><p><code>context</code> 包提供了几个用于创建和操纵上下文的函数：</p><ol><li><code>context.Background</code>：返回一个空的 <code>Context</code>。这个 <code>Context</code> 通常被用作整个程序或请求的顶层 <code>Context</code>。</li><li><code>context.TODO</code>：不确定应该使用哪个 <code>Context</code> 或者还没有可用的 <code>Context</code> 时，使用这个函数。这在编写初始化代码或者不确定要使用什么上下文时特别有用。</li><li><code>context.WithCancel</code>：创建一个新的 <code>Context</code>，这个 <code>Context</code> 会包含一个取消函数，可用于取消这个 <code>Context</code> 及其子树。</li><li><code>context.WithDeadline</code>：创建一个新的 <code>Context</code>，这个 <code>Context</code> 会在指定的时间到达时自动取消。</li><li><code>context.WithTimeout</code>：创建一个新的 <code>Context</code>，这个 <code>Context</code> 会在指定的时间段后自动取消。</li></ol><h2 id="3-3-案例"><a href="#3-3-案例" class="headerlink" title="3.3 案例"></a>3.3 案例</h2><h3 id="3-3-1-简单案例"><a href="#3-3-1-简单案例" class="headerlink" title="3.3.1 简单案例"></a>3.3.1 简单案例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operation</span><span class="params">(ctx context.Context, duration time.Duration)</span></span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(duration): <span class="comment">// 模拟一个耗时操作</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Operation done.&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 检测 context 的取消事件</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Operation canceled:&quot;</span>, ctx.Err())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个可取消的 context</span></span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个新的协程中运行 operation 函数</span></span><br><span class="line"><span class="keyword">go</span> operation(ctx, <span class="number">5</span>*time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟在 operation 运行一段时间后取消操作</span></span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">cancel() <span class="comment">// 取消 context</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 operation 一些时间来处理取消事件</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个案例中, 将<code>ctx</code>显式传递给在子协程, 使其可以受外部的协程控制。</p><h3 id="3-3-2-复杂案例socks5代理"><a href="#3-3-2-复杂案例socks5代理" class="headerlink" title="3.3.2 复杂案例socks5代理"></a>3.3.2 复杂案例<code>socks5代理</code></h3><p>这里给出一个<code>字节跳动后端青训营</code>实现的<code>socks5代理</code>中对<code>context</code> 的使用, 完整代码看<a href="https://github.com/wangkechun/go-by-example/tree/master/proxy/v4">这里</a>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, _ = io.Copy(dest, reader)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">_, _ = io.Copy(conn, dest)</span><br><span class="line">cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-ctx.Done()</span><br></pre></td></tr></table></figure><blockquote><p><strong>任务需求</strong>:<br>有两个 goroutine 分别用于从客户端读取数据并写入目的端，以及从目的端读取数据并写入客户端, 要求一旦有一个方向的拷贝操作出现错误, 将另一个操作也取消</p></blockquote><ul><li>方案:使用<code>WithCancel</code>和<code>&lt;-ctx.Done()</code>:</li><li>问题？我第一次看到这个代码时， 有这样的问题<br><code>ctx</code>并没有被显式地传递给2个goroutine, 2个<code>goroutine</code>调用<code>cancel</code>取消的是<code>WithCancel</code>返回的<code>ctx</code>, 而不是自己, 所以这为什么能工作?</li><li>答案:<br><code>cancel</code> 函数与 <code>ctx</code> 相关联，而 <code>cancel</code> 被闭包捕获并在多个 <code>goroutine</code> 中使用。这就是为什么调用<code> cancel()</code> 会影响所有这些 goroutine 的原因，不管 <code>ctx</code> 是否被显式传递。这种行为是 <code>context</code> 包设计的一部分，允许协调不同 <code>goroutine</code> 之间的取消事件。cancel() 被调用时会取消 <code>ctx</code> 上下文，而与这个 <code>ctx</code> 相关联的所有操作（在这个例子中是两个 <code>io.Copy</code> 调用）都会接收到取消通知，即使它们在不同的 <code>goroutine</code> 中执行，且 <code>ctx</code> 没有显式地传递给它们。</li></ul><h2 id="3-4-注意事项"><a href="#3-4-注意事项" class="headerlink" title="3.4 注意事项"></a>3.4 注意事项</h2><ul><li>不应该把 <code>Context</code> 存储在结构体中，它应该通过参数传递。</li><li><code>Context</code> 是协程安全的，你可以把一个 <code>Context</code> 传递给多个协程，每个协程都可以安全地读取和监听它。</li><li>一旦一个 <code>Context</code> 被取消，它的所有子 <code>Context</code> 都会被取消。</li><li><code>Context</code> 的 <code>Value</code> 方法应该被用于传递请求范围的数据，而不是函数的可选参数。</li></ul><p><code>Context</code> 在处理跨越多个协程的取消信号、超时以及传递请求范围数据时起到了关键作用，是 Go 并发编程中的重要组件。</p><h1 id="4-RPC"><a href="#4-RPC" class="headerlink" title="4 RPC"></a>4 RPC</h1><blockquote><p>这本来是在<code>Lab 1</code>过程中补的知识, 但介于这里写了这么多<code>Go</code>, 就放在一起了</p></blockquote><p>Go 标准库中的 <code>net/rpc</code> 包提供了创建 <code>RPC</code> 客户端和服务器的机制。<br>RPC 允许客户端程序调用在服务器上运行的程序的函数或方法，就好像它是本地可用的一样。客户端和服务器之间的通信通常是透明的，客户端程序仅需知道需要调用的远程方法和必须提供的参数。<br> <code>net/rpc</code> 包使用了 Go 的编码和解码接口，允许使用 <code>encoding/gob</code> 包来序列化和反序列化数据（尽管也可以使用其他编码，如 <code>JSON</code>）。<code>RPC</code> 调用默认是通过 <code>TCP</code> 或者 <code>UNIX</code> 套接字传输的，但是你可以实现自己的传输方式。</p><h2 id="4-1-服务器端"><a href="#4-1-服务器端" class="headerlink" title="4.1 服务器端"></a>4.1 服务器端</h2><p>要创建一个 <code>Go RPC</code> 服务器，你需要创建一些方法，这些方法必须满足以下条件：</p><ol><li>方法是导出的（首字母大写）。<del>Lab1 被坑惨了</del></li><li>方法有两个参数，都是导出类型或内建类型。</li><li>方法的第二个参数是指针, 相当于写出。</li><li>方法返回一个 <code>error</code> 类型。</li></ol><p>然后，将这个类型的实例注册为 RPC 服务：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Arith <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span></span> Multiply(args *Args, reply *<span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">    *reply = args.A * args.B</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arith := <span class="built_in">new</span>(Arith)</span><br><span class="line">    rpc.Register(arith)</span><br><span class="line">    rpc.HandleHTTP()</span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:1234&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-2-客户端"><a href="#4-2-客户端" class="headerlink" title="4.2 客户端"></a>4.2 客户端</h2><p>客户端需要使用 <code>rpc.Dial</code> 函数连接到 RPC 服务器，然后可以通过 <code>Call</code> 方法进行同步调用或 <code>Go</code> 方法进行异步调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;server address&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Synchronous call</span></span><br><span class="line">args := &amp;Args&#123;<span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">var</span> reply <span class="type">int</span></span><br><span class="line">err = client.Call(<span class="string">&quot;Arith.Multiply&quot;</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;arith error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Arith: %d*%d=%d&quot;</span>, args.A, args.B, reply)</span><br></pre></td></tr></table></figure><h2 id="4-3-缺点"><a href="#4-3-缺点" class="headerlink" title="4.3 缺点"></a>4.3 缺点</h2><p><code>net/rpc</code> 包的文档提到，该包已经被标记为<a href="https://golang.org/s/go1.7-rpc">“冻结”（frozen）</a>并不推荐使用。这意味着该包不会有新的发展，尽管它仍然是可用的。因此，应该考虑使用更现代的解决方案，如 <a href="https://grpc.io/">gRPC</a>，它支持多种语言，提供了更复杂的特性，例如双向流和集成认证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这节课主要是对分布式整体的概念和&lt;code&gt;Go&lt;/code&gt;的一些相关介绍, 包括线程、RPC、同步原语、管道等，相对简单， 简单记录一下， 顺带附上我进行Lab1实验时相关知识的补充&lt;/p&gt;
&lt;h1 id=&quot;1-同步原语&quot;&gt;&lt;a href=&quot;#1-同步原语&quot; class</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.8540(6.824) Lec01笔记: MapReduce论文解读</title>
    <link href="http://example.com/2023/12/24/MIT6.8540/Lec01%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/12/24/MIT6.8540/Lec01%E7%AC%94%E8%AE%B0/</id>
    <published>2023-12-24T09:34:02.000Z</published>
    <updated>2024-01-02T07:22:26.084Z</updated>
    
    <content type="html"><![CDATA[<p>本次课程包括了分布式系统的引入内容和<code>MapReduce</code>, 前者是引入性质的内容就不过多介绍了, 这里介绍<code>MapReduce</code></p><h1 id="1-MapReduce是什么"><a href="#1-MapReduce是什么" class="headerlink" title="1 MapReduce是什么?"></a>1 MapReduce是什么?</h1><p><code>MapReduce</code>是一种编程模型, 用于处理和大数据。其思想是使程序员能通过简单的<code>Map</code>函数和<code>Reduce</code>函数的编写就能完成分布式计算的任务, 而不需要知道任何有关分布式的事情，<code>MapReduce</code>框架会处理剩下的事情。</p><h1 id="2-MapReduce结构"><a href="#2-MapReduce结构" class="headerlink" title="2 MapReduce结构"></a>2 MapReduce结构</h1><p><img src="/../../images/Lec02_MapReduce_Fig.png" alt="Alt text"></p><p>上图所示是论文中对<code>MapReduce</code>架构描述, <code>MapReduce</code>中有如下术语:</p><ul><li><code>Worker</code>: 分布式系统中不同计算机上运行的进程</li><li><code>Master</code>: 也是一个计算机上的进程, 负责协调整个处理过程，包括分配任务、监控进度和处理失败的工作节点</li><li><code>Task</code>: 计算任务, 包括<code>Reduce</code>和<code>Map</code></li><li><code>Map</code>: 一个用用户程序提供的函数, 用于将输入的<code>key:value</code>转化为一组<code>mid-key:mid-value</code></li><li><code>Reduce</code>: 一个用用户程序提供的函数, 用于将输入的<code>mid-key:[]mid-value</code>转化为输出<code>output</code></li></ul><p>通常, <code>Master</code>将<code>Map</code>和<code>Reduce</code>作为任务分配给<code>Worker</code>进行计算, 称为<code>Map Task</code>和<code>Reduce Task</code>, 以下是其一次<code>MapReduce</code>任务(称为<code>Job</code>)执行的过程:</p><ol><li>文件分片<br>通常是在任务开始之前由<code>Master</code>完成的。这是初始化阶段的一部分</li><li><code>Master</code>分配<code>Map Task</code><br><code>Master</code>将分片信息分配给<code>Worker</code>节点, 例如: 最开始将<code>切割的文件名和文件内容</code>作为<code>key:value</code>通过<code>RPC</code>提供给<code>worker</code>使其利用提供的<code>map func</code>进行计算, 这也是<code>lab 1</code>中的工作方式</li><li><code>Map Task</code>执行<br><code>Map Task</code>的计算过程除了利用<code>map func</code>进行计算外, 还需要将输出的多个<code>mid-key:mid-value</code>分割成片存储于不同的本地文件, 不同的分片将提供给不同的<code>Reduce Task</code>, 通常使用<code>Hash</code>函数并对取<code>Reduce Task</code>的数量模得到分片序号。执行<code>Map Task</code>的<code>Worker</code>在执行结束后报告<code>Master</code>某个<code>Map Task</code>的执行情况</li><li><code>Master</code>等待所有的<code>Map Task</code>执行成功<br><code>Master</code>根据<code>Worker</code>对<code>Map Task</code>的执行情况的报告进行决策, 保证所有的<code>Map Task</code>执行成功</li><li><code>Master</code>分配<code>Reduce Task</code><br><code>Master</code>会给<code>Worker</code>分配某个<code>Reduce Task</code>， <code>Worker</code>根据其任务序号读取之前所有<code>Map Task</code>对应分片的内容，这也是为什么要等待所有的<code>Map Task</code>执行成功后才执行<code>Reduce Task</code>，这样才能保证<code>Reduce Task</code>不遗漏<code>mid-key</code>, 整合这分片文件后遍历所有的<code>mid-key:[]mid-value</code>并应用<code>reduce func</code>, 并存储输出结果。同样， 执行<code>Reduce Task</code>的<code>Worker</code>在执行结束后报告<code>Master</code>某个<code>Reduce Task</code>的执行情况</li><li><code>Master</code>协调所有的<code>Reduce Task</code>执行成功<br><code>Master</code>根据<code>Worker</code>对<code>Reduce Task</code>的执行情况的报告进行决策, 保证所有的<code>Reduce Task</code>执行成功</li></ol><p>最后, 不同的<code>Job</code>可以链式执行, 前一个<code>Job</code>的输出可以作为下一个<code>Job</code>的输入, 以此实现负责而庞大的计算任务</p><h1 id="3-容错与恢复"><a href="#3-容错与恢复" class="headerlink" title="3 容错与恢复"></a>3 容错与恢复</h1><ul><li>心跳信号<br><code>Worker</code>只需要向<code>Master</code>发送心跳信号表示自身的存活, 如果Master在预定时间内没有收到来自某个<code>Worker</code>的心跳，它就会将该<code>Worker</code>标记为失效，并将其上运行的所有<code>Map</code>和<code>Reduce</code>任务重新调度到其他节点上。不过这种设计不太会再<code>lab 1</code>中出现, 因为这样会使<code>Master</code>记录太多有关<code>Task</code>和<code>Worker</code>的信息, 设计相对复杂</li><li>超时重试<br>如果一个<code>Worker</code>节点在执行<code>Map</code>或<code>Reduce</code>任务耗时过长，<code>Master</code>会检测到这种情况。<code>Master</code>将其认定为失败, 可以将失败的任务重新分配给其他健康的<code>Worker</code>节点执行。这种重试机制可以处理机器故障、软件错误或其他导致任务失败的问题。</li><li><code>checkpoints</code><br><code>Master</code>会周期性地写入<code>checkpoints</code>到磁盘以预备可能的崩溃恢复</li><li>原子重命名<br>将<code>Map</code>和<code>Reduce</code>任务的输出写入到一个命名好的临时文件，并且只在任务成功完成时才对其进行重命名，来实现任务的幂等性。</li><li>文件系统备份<br>在<code>MapReduce</code>框架中，输入数据通常存储在一个分布式文件系统（如<code>GFS</code>）中，该文件系统会将数据块复制到多个节点上。这种数据副本机制确保了即使某些机器发生故障，数据仍然可用。</li></ul><h1 id="4-一个wc执行流程的案例"><a href="#4-一个wc执行流程的案例" class="headerlink" title="4 一个wc执行流程的案例"></a>4 一个wc执行流程的案例</h1><p>此处给出一个统计单词出现数量任务执行流程的案例, 助于理解</p><p><img src="/../../images/MapReduce_process.png" alt="img"></p><blockquote><p>假设单词<code>a</code>的哈希值为0, <code>b</code>的哈希值为1</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次课程包括了分布式系统的引入内容和&lt;code&gt;MapReduce&lt;/code&gt;, 前者是引入性质的内容就不过多介绍了, 这里介绍&lt;code&gt;MapReduce&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;1-MapReduce是什么&quot;&gt;&lt;a href=&quot;#1-MapReduce</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
    <category term="MapReduce" scheme="http://example.com/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>Vim入门到入土</title>
    <link href="http://example.com/2023/12/24/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/Vim%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/"/>
    <id>http://example.com/2023/12/24/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/Vim%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/</id>
    <published>2023-12-23T16:05:28.000Z</published>
    <updated>2023-12-29T05:07:12.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-Vim的操纵模式"><a href="#0-Vim的操纵模式" class="headerlink" title="0 Vim的操纵模式"></a>0 Vim的操纵模式</h1><p>Vim实际上可以看出一门语言, 其移动和读写有自己的模式, 了解这个思维实际上比掌握后续的命令更重要, 这里先给出其不同操作的操作模式:</p><ul><li><strong>common mode</strong></li></ul><ol><li><code>&#123;count&#125;&#123;motion&#125;&#123;operator&#125;</code> 或 <code>&#123;operator&#125;&#123;count&#125;&#123;motion&#125;</code><ul><li><code>count</code>: 执行次数</li><li><code>motion</code>: 定位</li><li><code>operator</code>: 执行的动作<br>这个操作模式是完成最基本的动作<br>例如:<code>d5w</code>就表示删除往后的5个单词<br>其中<code>&#123;count&#125;</code>可以省略, 也就是1,</li></ul></li><li><code>&#123;operator&#125;&#123;a|i&#125;&#123;text-object&#125;</code><ul><li><code>operator</code>: 同样是执行的动作</li><li><code>&#123;a|i&#125;</code>: <code>a</code>表示包括指定的文本对象包括空白字符, <code>i</code>表示包括指定的文本对象不包括空白字符</li><li><code>&#123;text-object&#125;</code>:<ul><li><code>w</code>: word</li><li><code>s</code>: sentence</li><li><code>b</code>|<code>(</code>: ()包裹的内容</li><li><code>B</code>|<code>&#123;</code>: {}包裹的内容</li><li><code>&quot;|&#39;</code>: 被引号包裹的内容<br>例如: <code>daw</code> 删除后续包括空白字符的文本对象</li></ul></li></ul></li></ol><ul><li><strong>visual mode</strong></li></ul><ol><li><code>&#123;trigger visual mode&#125;&#123;motion&#125;&#123;operator&#125;</code><br>与<strong>common mode</strong>的第一种操作模式类似, 只不过提前进入<code>visual mode</code></li></ol><ul><li><strong>ex命令</strong></li></ul><ol><li><p><code>:[range]command[options]</code><br> 对指定范围的内容执行<code>command</code>, <code>options</code>不固定<br> 例如: <code>:10,12d a</code> 表示删除10-12行的内容</p></li><li><p>搜索替换: <code>:[range]s/&#123;pattern&#125;/&#123;substitute&#125;/&#123;flags&#125;</code></p><ul><li><code>range</code>: 范围</li><li><code>s</code>: 就是具体的一个<code>command</code></li><li><code>pattern</code>: 模式, 支持正则表达式</li><li><code>substitute</code>:替换内容</li><li><code>flags</code>:</li><li><code>g</code>: 全局替换</li><li><code>i</code>: 无视大小写</li><li><code>c</code>: 替换前确认</li></ul></li></ol><h1 id="1-打开-关闭"><a href="#1-打开-关闭" class="headerlink" title="1 打开&#x2F;关闭"></a>1 打开&#x2F;关闭</h1><h2 id="1-1-新标签页"><a href="#1-1-新标签页" class="headerlink" title="1.1 新标签页"></a>1.1 新标签页</h2><p>在Vim中，可以使用<code>tabnew</code>命令来创建一个新的标签页（tab page）。标签页类似于编辑器中的分页，允许你在同一个Vim实例中同时打开多个文件，并在它们之间进行切换。以下是如何使用<code>tabnew</code>命令的一些示例：</p><ol><li><p>打开一个新的空白标签页：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">tabnew</span></span><br></pre></td></tr></table></figure><p>这将创建一个新的空白标签页，你可以在其中开始编辑新的文件。</p></li><li><p>打开一个特定的文件在新的标签页中：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">tabnew</span> filename</span><br></pre></td></tr></table></figure><p>这将在一个新的标签页中打开名为”filename”的文件。可以替换”filename”为你想要打开的实际文件的路径。</p></li><li><p>在不同的标签页之间切换：</p><ul><li>切换到下一个标签页：按下<code>gt</code>键。</li><li>切换到上一个标签页：按下<code>gT</code>键。</li><li>可以按下<code>&#123;N&#125;gt</code>，其中<code>&#123;N&#125;</code>是标签页的序号。例如，如果要切换到第三个标签页，可以按下<code>3gt</code>。</li></ul></li><li><p>关闭当前的标签页：<br><code>:tabclose</code>:   将关闭当前的标签页，并且如果标签页中有未保存的更改，Vim会提示你保存它们。</p></li><li><p>查看所有的标签页：<br><code>:tabs</code> :   这将显示所有打开的标签页，并且会在当前标签页前面标记一个”%”。</p></li><li><p>使用<code>:tabnext</code>和<code>:tabprev</code>命令：<br>使用<code>:tabnext</code>和<code>:tabprev</code>命令来切换到下一个或上一个标签页：</p><ul><li><code>:tabnext</code>: 切换到下一个标签页</li><li><code>:tabprev</code>: 要切换到上一个标签页</li></ul></li><li><p>退出当前标签页</p><ul><li><code>:q</code>: 退出当前标签页</li><li><code>:qa</code>: 退出所有标签页</li><li><code>tabo</code>: 退出其他标签页</li></ul></li><li><p>打开或新建文件<br><code>:edit &#123;relative-path-to-file&#125;</code></p></li></ol><h2 id="1-2-split分割页"><a href="#1-2-split分割页" class="headerlink" title="1.2 split分割页"></a>1.2 split分割页</h2><ol><li>新建分割页<br><code>:sp &#123;relative-path-to-file&#125;</code>: 水平分页<br><code>:vsp &#123;relative-path-to-file&#125;</code>: 垂直分页</li><li>当前分隔页的副本<br><code>&lt;CTRL-W&gt; S</code> 水平方向<br><code>&lt;CTRL-W&gt; V </code>t垂直方向</li></ol><h2 id="1-3-文件IO"><a href="#1-3-文件IO" class="headerlink" title="1.3 文件IO"></a>1.3 文件IO</h2><ol><li><code>:w</code> 保存文件</li><li><code>:wq</code> 保存文件并退出</li><li><code>:q!</code> 强制退出</li></ol><h1 id="2-基本字符和单词操作"><a href="#2-基本字符和单词操作" class="headerlink" title="2 基本字符和单词操作"></a>2 基本字符和单词操作</h1><h2 id="2-1-基本定位操作"><a href="#2-1-基本定位操作" class="headerlink" title="2.1 基本定位操作"></a>2.1 基本定位操作</h2><ol><li><p><code>j</code>、<code>k</code>、<code>h</code>、<code>l</code>：这些是光标移动操作。</p><ul><li><code>j</code>：向下移动一行。</li><li><code>k</code>：向上移动一行。</li><li><code>h</code>：向左移动一个字符。</li><li><code>l</code>：向右移动一个字符。</li></ul></li><li><p><code>w</code> 向前移动一个单词。按下<code>w</code>键会将光标移动到下一个单词的开头。</p></li><li><p><code>b</code> 向后移动一个单词。按下<code>b</code>键会将光标移动到前一个单词的开头。</p></li><li><p><code>e</code> 移动到单词的末尾。按下<code>e</code>键会将光标移动到当前单词的末尾。</p></li><li><p><code>0</code> 移动到行的开头。按下<code>0</code>键会将光标移动到当前行的开头。</p></li><li><p><code>$</code> 移动到行的末尾。按下<code>$</code>键会将光标移动到当前行的末尾。</p></li><li><p><code>^</code> 移动到行的第一个非空字符。按下<code>^</code>键会将光标移动到当前行的第一个非空字符处。</p></li><li><p><code>Ctrl-d</code> 向下滚动半屏。按下<code>Ctrl-d</code>键会将屏幕内容向下滚动半个屏幕。</p></li><li><p><code>Ctrl-u</code> 向上滚动半屏。按下<code>Ctrl-u</code>键会将屏幕内容向上滚动半个屏幕。</p></li><li><p><code>G</code> 移动到文件的最后一行。按下<code>G</code>键会将光标移动到文件的最后一行。</p></li><li><p><code>gg</code> 移动到文件的第一行。按下<code>gg</code>键会将光标移动到文件的第一行。</p></li><li><p><code>L</code> 将光标移动到屏幕的底部行。</p></li><li><p><code>M</code> 将光标移动到屏幕的中间行。</p></li><li><p><code>H</code> 将光标移动到屏幕的顶部行。</p></li></ol><h2 id="2-2-组合定位"><a href="#2-2-组合定位" class="headerlink" title="2.2 组合定位"></a>2.2 组合定位</h2><p>在Vim中，<code>f</code>、<code>F</code>、<code>t</code>和<code>T</code>是用于在当前行内搜索字符的命令，结合它们可以实现各种组合操作。以下是这些命令的详细解释 </p><ol><li><p><code>f&#123;char&#125;</code>：在当前行内查找下一个出现的字符<code>&#123;char&#125;</code>，光标会停在找到的字符上。例如，如果你想查找下一个出现的字母<code>a</code>，可以按下<code>fa</code>。</p></li><li><p><code>F&#123;char&#125;</code>：在当前行内查找上一个出现的字符<code>&#123;char&#125;</code>，光标会停在找到的字符上。例如，如果你想查找上一个出现的字母<code>a</code>，可以按下<code>Fa</code>。</p></li><li><p><code>t&#123;char&#125;</code>：在当前行内查找下一个出现的字符<code>&#123;char&#125;</code>，光标会停在找到的字符前一个位置。例如，如果你想查找下一个出现的字母<code>a</code>，可以按下<code>ta</code>。</p></li><li><p><code>T&#123;char&#125;</code>：在当前行内查找上一个出现的字符<code>&#123;char&#125;</code>，光标会停在找到的字符前一个位置。例如，如果你想查找上一个出现的字母<code>a</code>，可以按下<code>Ta</code>。</p></li></ol><p>这些命令通常与其他操作一起使用，以便在文本中快速导航和编辑。例如，如果你想删除从光标位置到下一个出现字母<code>a</code>的字符之间的文本，你可以使用<code>dt&#123;char&#125;</code>，其中<code>&#123;char&#125;</code>是你想要删除的字符。这些命令的组合允许你在Vim中以精确的方式执行各种文本编辑任务。</p><p><strong>重点: 如何连续进行重复的定位操作?</strong></p><p>答案: 使用<code>;</code>和<code>,</code>:</p><ul><li><code>;</code>: 重复到下一个定位的位置, 例如使用<code>fa</code>后跳转到了往后第一个<code>a</code>出现的位置, 在使用<code>;</code>可以到第二个<code>a</code>出现的位置, 以此类推</li><li><code>,</code>: <code>;</code>的反向操作</li></ul><h1 id="3-插入与删除"><a href="#3-插入与删除" class="headerlink" title="3 插入与删除"></a>3 插入与删除</h1><h2 id="3-1-基本插入"><a href="#3-1-基本插入" class="headerlink" title="3.1 基本插入"></a>3.1 基本插入</h2><ol><li><p><code>i</code>：进入插入模式。按下<code>i</code>键会使光标位于当前位置，你可以在光标前插入文本。</p></li><li><p><code>I</code>：进入插入模式并移到行首。按下<code>I</code>键会将光标移到当前行的第一个非空字符位置，然后你可以开始插入文本。</p></li><li><p><code>a</code>：进入插入模式并移到光标后面。按下<code>a</code>键会使光标位于当前位置的下一个字符后面，你可以在光标后插入文本。</p></li><li><p><code>A</code>：进入插入模式并移到行尾。按下<code>A</code>键会将光标移到当前行的末尾，你可以在行尾插入文本。</p></li><li><p><code>o</code>：在下面插入新行并进入插入模式。按下<code>o</code>键会在当前行的下面插入一个新的空行，并将光标移动到新行的起始位置，你可以在新行中插入文本。</p></li><li><p><code>O</code>：在上面插入新行并进入插入模式。按下<code>O</code>键会在当前行的上面插入一个新的空行，并将光标移动到新行的起始位置，你可以在新行中插入文本。</p></li></ol><p>这些命令允许你在插入模式中灵活地编辑文本。你可以使用它们来快速插入、编辑和调整文本，提高编辑效率。要退出插入模式并返回正常模式，只需按下<code>Esc</code>键。</p><h2 id="3-2-基本删除"><a href="#3-2-基本删除" class="headerlink" title="3.2 基本删除"></a>3.2 基本删除</h2><ol><li><p><code>x</code>：删除光标下的字符。按下<code>x</code>键会删除光标所在位置的字符。</p></li><li><p><code>X</code>：删除光标前面的字符。按下<code>X</code>键会删除光标前一个位置的字符。</p></li><li><p><code>dd</code>：删除当前行。按下<code>dd</code>键会删除光标所在行的所有内容，并将其剪切到剪贴板。</p></li><li><p><code>D</code>：删除从光标位置到行尾的内容。按下<code>D</code>键会删除从光标位置到行尾的所有字符。</p></li><li><p><code>dw</code>：删除从光标位置到下一个单词的开头。按下<code>dw</code>键会删除从光标位置到下一个单词的开头的所有字符。</p></li><li><p><code>de</code>：de命令将删除光标位置到当前单词的末尾的文本，包括当前单词的最后一个字符。这个命令通常用于删除一个单词的内容。</p></li><li><p><code>db</code>：删除从光标位置到前一个单词的开头。按下<code>db</code>键会删除从光标位置到前一个单词的开头的所有字符。</p></li><li><p><code>:n1,n2d</code>：删除从行号<code>n1</code>到行号<code>n2</code>的所有行。例如，<code>:1,5d</code>会删除第1行到第5行的所有行。</p></li><li><p><code>:d&#123;n&#125;</code>：删除第<code>n</code>行。例如，<code>:d10</code>会删除第10行。</p></li><li><p><code>dG</code>：删除从光标位置到文件末尾的所有行。</p></li><li><p><code>dgg</code>：删除从光标位置到文件开头的所有行。</p></li><li><p><code>:1,$d</code>：删除整个文件的内容。</p></li></ol><p>这些是一些基本的删除命令，它们可以帮助你在Vim中快速删除文本。请注意，删除的文本通常会被复制到剪贴板，因此可以使用粘贴命令（如<code>p</code>）将其恢复到其他位置。如果你需要撤销删除操作，可以使用撤销命令（如<code>u</code>）来撤销最后的编辑操作。</p><h2 id="3-3-基本替换"><a href="#3-3-基本替换" class="headerlink" title="3.3 基本替换"></a>3.3 基本替换</h2><p>在Vim中，替换命令是用于替换文本的关键操作之一。<code>c</code>命令（”change”）是用于删除并进入插入模式的命令，通常与其他操作一起使用来替换文本。以下是基本的替换命令以及与<code>c</code>命令相关的一些衍生命令和组合：</p><ol><li><p><code>c&#123;motion&#125;</code>：使用<code>c</code>命令可以替换<code>&#123;motion&#125;</code>范围内的文本。例如：</p><ul><li><code>cw</code>：替换当前单词。</li><li><code>c2w</code>：替换下两个单词。</li><li><code>c$</code>：替换光标位置到行尾的文本。</li></ul></li><li><p><code>cc</code>：替换整行。按下<code>cc</code>键会删除当前行并进入插入模式，允许你替换整行文本。</p></li><li><p><code>C</code>：替换从光标位置到行尾的文本。按下<code>C</code>键会删除从光标位置到行尾的文本并进入插入模式。</p></li><li><p><code>s</code>：替换当前字符。按下<code>s</code>键会删除光标下的字符并进入插入模式，允许你替换当前字符。</p></li><li><p><code>S</code>：替换整行。按下<code>S</code>键会删除整行并进入插入模式，允许你替换整行文本。</p></li><li><p><code>r&#123;char&#125;</code>：这是一个简单的字符替换命令。按下<code>r</code>键后，再紧跟一个字符<code>&#123;char&#125;</code>，会将光标下的当前字符替换为指定的字符。例如，如果你想将当前字符替换为<code>x</code>，只需按下<code>rx</code>。替换完成后，光标会自动移动到下一个字符。这是一个快速替换单个字符的方式。</p></li><li><p><code>R</code>：这是替换模式命令。按下<code>R</code>键后，会进入替换模式，此时你可以连续输入字符，替换光标所在位置及其后续字符。替换模式允许你在一段文本中进行逐字符替换，直到你按下<code>Esc</code>键退出替换模式。这对于逐字符编辑文本非常有用。</p></li><li><p><code>:s/&#123;pattern&#125;/&#123;replacement&#125;/g</code>：使用替换命令来替换所有匹配<code>&#123;pattern&#125;</code>的文本。例如，<code>:s/old/new/g</code>会将所有匹配<code>old</code>的文本替换为<code>new</code>。</p></li><li><p><code>:s/&#123;pattern&#125;/&#123;replacement&#125;/gc</code>：与上述命令类似，但会在替换前要求确认。你可以选择是否替换每个匹配项。</p></li><li><p><code>:%s/&#123;pattern&#125;/&#123;replacement&#125;/g</code>：在整个文件中替换所有匹配<code>&#123;pattern&#125;</code>的文本。注意，正则表达式中的特殊字符需要使用<code>\</code>转义。</p></li></ol><h2 id="3-4-复制和粘贴"><a href="#3-4-复制和粘贴" class="headerlink" title="3.4 复制和粘贴"></a>3.4 复制和粘贴</h2><ol><li><code>y</code> 复制当前字符</li><li><code>yy</code> 负责一整行</li><li><code>yw</code> 复制一个单词</li><li><code>y2w</code> 复制2个单词</li><li><code>p</code> 粘贴</li></ol><h1 id="4-查找内容和替换"><a href="#4-查找内容和替换" class="headerlink" title="4 查找内容和替换"></a>4 查找内容和替换</h1><h2 id="4-1-查找"><a href="#4-1-查找" class="headerlink" title="4.1 查找"></a>4.1 查找</h2><ol><li>查找指定内容</li></ol><ul><li>向后查找内容 <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/*** <span class="built_in">search</span> <span class="keyword">for</span> content***</span><br></pre></td></tr></table></figure>n 查找下一个<br>N 查找上一个 <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- 向前查找内容</span><br><span class="line">?*** <span class="built_in">search</span> <span class="keyword">for</span> content***</span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>辅助查找指令 <ol><li><code>c-G</code> 查看当前位置信息</li><li><code>*G</code> 向前查找内容</li></ol></li></ol><h2 id="4-2-查找并替换"><a href="#4-2-查找并替换" class="headerlink" title="4.2 查找并替换"></a>4.2 查找并替换</h2><ol><li><code>:s/&#123;&#123;old&#125;&#125;/&#123;&#123;new&#125;&#125;</code> 用new替换old,普通替换, 替换范围为当前行的第一个</li><li><code>:s/&#123;&#123;old&#125;&#125;/&#123;&#123;new&#125;&#125;</code> 用new替换old,普通替换, 替换范围为当前行的所有</li><li><code>:%s/&#123;&#123;old&#125;&#125;/&#123;&#123;new&#125;&#125;/g</code> 用new替换old,普通替换, 替换范围为所有文档范围</li><li><code>:%s/&#123;&#123;old&#125;&#125;/&#123;&#123;new&#125;&#125;/gc</code> 用new替换old,普通替换, 替换范围为所有文档范围, 并在每一次替换时进行确认</li><li><code>:&#123;&#123;#&#125;&#125;,&#123;&#123;#&#125;&#125;s/old/new/g</code> <code>#</code>指定了替换操的行范围<br>范围除了数字外还包括:<br> <code>$</code>: 将光标移到文件的最后一行,<br> <code>0</code>: 将光标移到文件的第一行<br> <code>%</code>: 整个文件<br> <code>&#39;&lt;,&#39;&gt;</code>: <code>visual mode</code>下选择的内容</li></ol><h1 id="5-组合操作"><a href="#5-组合操作" class="headerlink" title="5 组合操作"></a>5 组合操作</h1><h2 id="5-1-跳转组合命令"><a href="#5-1-跳转组合命令" class="headerlink" title="5.1 跳转组合命令"></a>5.1 跳转组合命令</h2><ol><li><code>c-o</code> 返回上一个位置</li><li><code>c-i</code> 重新跳转到某位置</li></ol><h2 id="5-2-基本命令组合"><a href="#5-2-基本命令组合" class="headerlink" title="5.2 基本命令组合"></a>5.2 基本命令组合</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span><span class="keyword">j</span> 向下移动<span class="number">10</span>次</span><br><span class="line"><span class="number">10</span>de 向后删除<span class="number">10</span>个单词</span><br><span class="line">c2w 向后删除<span class="number">2</span>个单词并进入编辑模式</span><br></pre></td></tr></table></figure><h2 id="5-3-括号组合操作"><a href="#5-3-括号组合操作" class="headerlink" title="5.3 括号组合操作"></a>5.3 括号组合操作</h2><p>对于常见的括号包括 [], {}, (), &lt;&gt;, “”, ‘’<br>以{}为例:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`ci&#123;` 删除&#123;&#125;内的内容并进入编辑模式</span><br><span class="line">`<span class="keyword">di</span>&#123;` 删除&#123;&#125;内的内容</span><br></pre></td></tr></table></figure><h1 id="6-Visual-mode-操作"><a href="#6-Visual-mode-操作" class="headerlink" title="6 Visual mode 操作"></a>6 Visual mode 操作</h1><ol><li><code>v</code> 进入模式</li><li><code>V</code> 选择整行</li><li><code>~</code>:反转大小写</li></ol><h1 id="7-其他操作"><a href="#7-其他操作" class="headerlink" title="7 其他操作"></a>7 其他操作</h1><h2 id="7-1-导入其他文件内容"><a href="#7-1-导入其他文件内容" class="headerlink" title="7.1 导入其他文件内容"></a>7.1 导入其他文件内容</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r filename</span><br></pre></td></tr></table></figure><p>将导入 filename 指定文件的内容</p><h2 id="7-2-配置项设置"><a href="#7-2-配置项设置" class="headerlink" title="7.2 配置项设置"></a>7.2 配置项设置</h2><ol><li><code>:set nu</code> 显示行号</li><li><code>:set nonu</code> 取消显示行号</li><li><code>:set ic</code> 输入时忽略大小写</li><li><code>:set noic</code> 取消输入时忽略大小写</li><li><code>:set hls is</code> 高亮匹配查找的内容</li><li><code>:nohlsearch</code> 取消高亮匹配查找的内容</li><li><code>:set nocp</code> 确保vim没有在兼容模式</li></ol><h2 id="7-3-执行命令行命令"><a href="#7-3-执行命令行命令" class="headerlink" title="7.3 执行命令行命令"></a>7.3 执行命令行命令</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:! <span class="keyword">command</span></span><br></pre></td></tr></table></figure><p>执行<code>command</code>操作<br>以下是几个特殊的指令<br><code>@:</code>: 重复上一个指令<br><code>@@</code>: 继续重复</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-Vim的操纵模式&quot;&gt;&lt;a href=&quot;#0-Vim的操纵模式&quot; class=&quot;headerlink&quot; title=&quot;0 Vim的操纵模式&quot;&gt;&lt;/a&gt;0 Vim的操纵模式&lt;/h1&gt;&lt;p&gt;Vim实际上可以看出一门语言, 其移动和读写有自己的模式, 了解这个思维实际</summary>
      
    
    
    
    <category term="实用工具" scheme="http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="vim" scheme="http://example.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>WSL入门到入土</title>
    <link href="http://example.com/2023/12/23/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/WSL%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2023/12/23/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E7%AC%94%E8%AE%B0/WSL%E4%BD%BF%E7%94%A8/</id>
    <published>2023-12-23T14:04:07.000Z</published>
    <updated>2023-12-29T05:41:46.163Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-wsl是什么"><a href="#1-wsl是什么" class="headerlink" title="1 wsl是什么?"></a>1 wsl是什么?</h1><p><code>wsl</code>的官方文档点这里: <a href="https://learn.microsoft.com/zh-cn/windows/wsl/">https://learn.microsoft.com/zh-cn/windows/wsl/</a><br>官方称之为<code>适用于 Linux 的 Windows 子系统文档</code>, 我们把他当成一个和<code>windows</code>为什么我们要使用wsl呢？对于我个人而言，<code>wsl</code>相比<code>VMWarwe</code>存在如下几个优势：</p><ol><li>文件与环境共享<br><code>WSL</code> 与 <code>Windows</code> 系统紧密集成，允许用户在 <code>Windows</code> 和 <code>Linux</code> 系统之间无缝地运行命令和程序，共享文件系统，甚至可以在 <code>Windows</code> 中运行 Linux 应用。例如, 你可以在<code>wsl</code>中使用<code>explorer.exe .</code>使用资源管理器打开虚拟机中的文件夹。你可以使用<code>mnt/</code>路径访问宿主机文件系统等待。</li><li>VSCode完美兼容<br>VSCode的插件完美兼容wsl， 你可以在wsl的终端输入<code>code .</code>直接唤起VSCode, 此外Docker Desktop也使用wsl2作为后端</li><li>支持CUDA<br>NVIDIA官方提供了wsl的cuda程序包, 这意味着可以在wsl中运行各种主流的深度学习框架, 如Pytorch和TensorFlow</li><li>轻量<br>相比<code>VMWarwe</code>, wsl消耗的系统资源更少, <del>甚至可以开着wsl打FIFA</del></li></ol><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h1><h2 id="2-1-前置要求"><a href="#2-1-前置要求" class="headerlink" title="2.1 前置要求"></a>2.1 前置要求</h2><h3 id="2-1-1-启用Windows功能"><a href="#2-1-1-启用Windows功能" class="headerlink" title="2.1.1 启用Windows功能"></a>2.1.1 启用Windows功能</h3><p>系统搜索<strong>启用或关闭Windows功能</strong>，如下图开启功能<br><img src="/../../images/enable_win_func.png" alt="en../imagesble_win_func"></p><h3 id="2-1-2-BIOS开启CPU虚拟化功能"><a href="#2-1-2-BIOS开启CPU虚拟化功能" class="headerlink" title="2.1.2 BIOS开启CPU虚拟化功能"></a>2.1.2 BIOS开启CPU虚拟化功能</h3><p>不同的主板厂商BIOS界面设置不同，大体上的位置可参考下图<br><img src="/../../images/enable-virtualization.png" alt="enable-virtualization"></p><h2 id="2-2-下载Linux-内核更新包-可选"><a href="#2-2-下载Linux-内核更新包-可选" class="headerlink" title="2.2 下载Linux 内核更新包(可选)"></a>2.2 下载Linux 内核更新包(可选)</h2><p>如果后续操作失败了, 需要下载Linux 内核更新包: <a href="https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package">https://learn.microsoft.com/zh-cn/windows/wsl/install-manual#step-4---download-the-linux-kernel-update-package</a></p><h2 id="2-3-安装指令"><a href="#2-3-安装指令" class="headerlink" title="2.3 安装指令"></a>2.3 安装指令</h2><p>参考 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">https://learn.microsoft.com/zh-cn/windows/wsl/install</a> 即可, 简单说就是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wsl --install</span><br><span class="line">wsl --install</span><br><span class="line"></span><br><span class="line">安装 WSL 默认版本和默认 Linux 发行版。</span><br><span class="line">wsl --list [--online]</span><br><span class="line"><span class="comment"># 列出已安装的 Linux 发行版，使用 --online 参数可显示可供安装的发行版列表。</span></span><br><span class="line"></span><br><span class="line">wsl --set-default &lt;DistributionName&gt;</span><br><span class="line"><span class="comment"># 设置默认的 Linux 发行版。</span></span><br></pre></td></tr></table></figure><p>其中, <code>--</code>参数都可以用<code>-</code>加首字母代替。<br>另外， win10环境下强推<a href="https://learn.microsoft.com/zh-cn/windows/terminal/install">Windows 终端</a></p><h1 id="3-基本命令"><a href="#3-基本命令" class="headerlink" title="3 基本命令"></a>3 基本命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">wsl</span><br><span class="line"><span class="comment"># 启动默认的 Linux 发行版的默认 shell。</span></span><br><span class="line"></span><br><span class="line">wsl &lt;<span class="built_in">command</span>&gt;</span><br><span class="line"><span class="comment"># 在默认的 Linux 发行版中运行指定的命令。</span></span><br><span class="line"></span><br><span class="line">wsl -d &lt;DistributionName&gt;</span><br><span class="line"><span class="comment"># 启动指定的 Linux 发行版。</span></span><br><span class="line"><span class="comment"># 实际上, 使用`Windows 终端`直接拉选项卡是最常用的方法</span></span><br><span class="line"></span><br><span class="line">wsl -u &lt;UserName&gt;</span><br><span class="line"><span class="comment"># 以指定的用户身份启动 WSL。</span></span><br><span class="line"></span><br><span class="line">wsl --set-version &lt;DistributionName&gt; &lt;VersionNumber&gt;</span><br><span class="line"><span class="comment"># 设置指定发行版的 WSL 版本（如 wsl --set-version Ubuntu 2 切换到 WSL 2）。</span></span><br><span class="line"></span><br><span class="line">wsl --shutdown</span><br><span class="line"><span class="comment"># 立即终止所有运行的 WSL Linux 发行版并关闭虚拟机。</span></span><br><span class="line"></span><br><span class="line">wsl --unregister &lt;DistributionName&gt;</span><br><span class="line"><span class="comment"># 注销并删除指定的 Linux 发行版, 同时会删除磁盘文件。</span></span><br><span class="line"></span><br><span class="line">wsl --update</span><br><span class="line"><span class="comment"># 更新 WSL 的 Linux 内核。</span></span><br><span class="line"></span><br><span class="line">wsl --status</span><br><span class="line"><span class="comment"># 显示 WSL 的状态以及默认的 WSL 版本和发行版。</span></span><br><span class="line"></span><br><span class="line">wsl --<span class="built_in">help</span></span><br><span class="line"><span class="comment"># 显示所有可用的 WSL 命令和用法选项。</span></span><br></pre></td></tr></table></figure><h1 id="4-网络配置"><a href="#4-网络配置" class="headerlink" title="4 网络配置"></a>4 网络配置</h1><h2 id="4-1-代理设置"><a href="#4-1-代理设置" class="headerlink" title="4.1 代理设置"></a>4.1 代理设置</h2><p>设置代理只需要导出环境变量即可, 以<code>Clash</code>代理的7890端口为例:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:7890</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>类似的, 可以使用如下命令配置git代理:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy <span class="variable">$&#123;PROXY_HTTP&#125;</span></span><br><span class="line">git config --global https.proxy <span class="variable">$&#123;PROXY_HTTP&#125;</span></span><br></pre></td></tr></table></figure><p>如同Linux物理机一样, 在<code>.bashrc</code>中配置环境变量即可永久生效</p><h2 id="4-2-固定IP"><a href="#4-2-固定IP" class="headerlink" title="4.2 固定IP"></a>4.2 固定IP</h2><p>默认情况下, WSL实例的 IP 地址不是固定的。每次 WSL 实例启动时，它通常会从 Windows 主机的一个虚拟网络适配器获得一个新的 IP 地址。这个虚拟网络适配器充当 DHCP 服务器，为 WSL 实例分配 IP 地址。<br>最常用的方案是与宿主机共享IP, 这可以通过配置<code>wslconfig文件</code>做到:<br>在用户目录下的<code>.wslconfig文件</code>中添加如下内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[experimental]</span><br><span class="line">networkingMode=mirrored</span><br><span class="line">dnsTunneling=true</span><br><span class="line">firewall=true</span><br><span class="line">autoProxy=true</span><br></pre></td></tr></table></figure><p>此后启动wsl, 其与 <code>Windows</code> 主机的网络互通而且 IP 地址相同了</p><p>另外还有别的方式固定IP</p><ol><li>使用桥接模式, 参考这篇文章: <a href="https://blog.csdn.net/keyiis_sh/article/details/113819244">https://blog.csdn.net/keyiis_sh/article/details/113819244</a></li><li>配置虚拟网络, 参考这篇文章: <a href="http://www.manongjc.com/detail/28-qmgskvmcxbjzfaj.html">http://www.manongjc.com/detail/28-qmgskvmcxbjzfaj.html</a></li></ol><h2 id="4-3-端口映射"><a href="#4-3-端口映射" class="headerlink" title="4.3 端口映射"></a>4.3 端口映射</h2><p>端口映射命令如下:<br>建立映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenport=80 listenaddress=0.0.0.0 connectport=80 connectaddress=172.29.41.233</span><br></pre></td></tr></table></figure><p>其中<code>172.29.41.233</code>是wsl中的ip地址, 第一个80表示宿主机端口,第二个80表示wsl端口</p><p>查看已有的映射</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy show all</span><br></pre></td></tr></table></figure><p>移除映射:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netsh interface portproxy delete v4tov4 listenport=80 listenaddress=0.0.0.0</span><br></pre></td></tr></table></figure><h1 id="5-磁盘管理"><a href="#5-磁盘管理" class="headerlink" title="5 磁盘管理"></a>5 磁盘管理</h1><h2 id="5-1-安装或迁移wsl到其他磁盘"><a href="#5-1-安装或迁移wsl到其他磁盘" class="headerlink" title="5.1 安装或迁移wsl到其他磁盘"></a>5.1 安装或迁移wsl到其他磁盘</h2><p>wsl默认安装在C盘, …<br>WSL会在宿主机上创建一个虚拟硬盘文件（通常是一个名为 ext4.vhdx 的文件），用于存储 Linux 发行版的文件系统, 而这个文件貌似是以追加写入的方式运行的, 因此容量会越来越大。<strong>因此将其安装在非系统盘是十分必要的。</strong><br>最简单的方式是手动迁移vhdx文件，注销Linux发行版， 再重新导入。<strong>此操作对于老旧版本的wsl是不适用的！</strong></p><ul><li><strong>方法1 直接迁移ext4.vhdx文件</strong><br>例如， 我的wsl文件位于<code>&quot;C:\Ubuntu-20.04\ext4.vhdx&quot;</code>下, 先进行如下操作</li></ul><ol><li>复制<code>ext4.vhdx</code>文件到指定路径<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> <span class="string">&quot;C:\Ubuntu-20.04\ext4.vhdx&quot;</span> &lt;targetPath&gt;</span><br></pre></td></tr></table></figure></li><li>注销对应的发行版<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --unregister Ubuntu-20.04</span><br></pre></td></tr></table></figure></li><li>重新导入<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --import-in-place Ubuntu-20.04 &lt;targetPath&gt;</span><br></pre></td></tr></table></figure></li></ol><p>这时wsl发行版已经被迁移到其他磁盘了, 这种方法的优势是原位导入, 也就是<code>&lt;targetPath&gt;</code>就是wsl真正的磁盘文件了, 不过确定是只能用于<code>ext4</code> 文件系统类型格式。</p><ul><li><strong>方法2 导出镜像</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wsl --<span class="built_in">export</span> &lt;Distribution Name&gt; &lt;FileName&gt;</span><br><span class="line"><span class="comment"># 导出:</span></span><br><span class="line"></span><br><span class="line">wsl --import &lt;Distribution Name&gt; &lt;InstallLocation&gt; &lt;FileName&gt;</span><br><span class="line"><span class="comment"># 导入</span></span><br></pre></td></tr></table></figure>通过<code>--import</code>可以看出, 这种方法是将<FileName><code>安装</code>到了<code>&lt;InstallLocation&gt;</code>, 可以看作多复制了一份, 因此如果我们的wsl无比庞大时, 这样的操作是很费时间的</li></ul><h2 id="5-2-清理vhdx磁盘空间"><a href="#5-2-清理vhdx磁盘空间" class="headerlink" title="5.2 清理vhdx磁盘空间"></a>5.2 清理vhdx磁盘空间</h2><p>如前文所述, WSL 不会自动收缩vhdx文件的大小, 我们需要手动压缩:<br>使用管理员打开<code>powershell</code>:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭WSL</span></span><br><span class="line">wsl <span class="literal">--shutdown</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打开Diskpart窗口</span></span><br><span class="line">diskpart</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="built_in">select</span> vdisk file=<span class="string">&quot;path to ext4.vhdx&quot;</span></span><br><span class="line"> </span><br><span class="line">attach vdisk readonly</span><br><span class="line">compact vdisk</span><br><span class="line">detach vdisk</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 退出</span></span><br><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><h1 id="6-安装CUDA"><a href="#6-安装CUDA" class="headerlink" title="6 安装CUDA"></a>6 安装CUDA</h1><p>此过程较为繁琐, 且方案迭代过快, 因此给出官方文档: <a href="https://docs.nvidia.com/cuda/wsl-user-guide/index.html">https://docs.nvidia.com/cuda/wsl-user-guide/index.html</a><br>以下的过程仅供参考:</p><ol><li><p>确保Windows中安装了NVIDIA的显卡驱动(不需要安装cuda)</p></li><li><p>在官网下载适用于wsl的cuda toolkit,<br>网址: <a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&target_arch=x86_64&Distribution=WSL-Ubuntu&target_version=2.0&target_type=deb_local">https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=WSL-Ubuntu&amp;target_version=2.0&amp;target_type=deb_local</a></p><p>如下选择:</p><p><img src="/../../images/wsl-cuda.png" alt="wsl-cuda"></p></li><li><p>安装官网指令进行安装</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-wsl-ubuntu.pin</span><br><span class="line">sudo <span class="built_in">mv</span> cuda-wsl-ubuntu.pin /etc/apt/preferences.d/cuda-repository-pin-600</span><br><span class="line">wget https://developer.download.nvidia.com/compute/cuda/12.3.1/local_installers/cuda-repo-wsl-ubuntu-12-3-local_12.3.1-1_amd64.deb</span><br><span class="line">sudo dpkg -i cuda-repo-wsl-ubuntu-12-3-local_12.3.1-1_amd64.deb</span><br><span class="line">sudo <span class="built_in">cp</span> /var/cuda-repo-wsl-ubuntu-12-3-<span class="built_in">local</span>/cuda-*-keyring.gpg /usr/share/keyrings/</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install cuda-toolkit-12-3</span><br></pre></td></tr></table></figure></li></ol><h1 id="7-第三方工具LxRunOffline"><a href="#7-第三方工具LxRunOffline" class="headerlink" title="7 第三方工具LxRunOffline"></a>7 第三方工具LxRunOffline</h1><p><code>LxRunOffline</code>是第三方的wsl管理工具,其能更方便我们管理wsl, 例如修改登录用户、安装非微软官方提供的Linux发行版等</p><p>Github仓库： <a href="https://github.com/DDoSolitary/LxRunOffline">https://github.com/DDoSolitary/LxRunOffline</a><br>下载地址： <a href="https://github.com/DDoSolitary/LxRunOffline/releases">https://github.com/DDoSolitary/LxRunOffline/releases</a></p><p>安装建议下载编译好的二进制文件，较为简单就不演示了, 此处介绍其核心功能</p><ol><li><p><code>LxRunOffline</code>最主要的作用就是安装非微软官方提供的Linux发行版:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LxRunOffline i -n archlinux -f &#123;发行版镜像位置&#125;  -d  &lt;安装系统的位置&gt; [-r 附加参数]</span><br></pre></td></tr></table></figure><p>具体的发行版安装看这里: <a href="https://github.com/DDoSolitary/LxRunOffline/wiki">https://github.com/DDoSolitary/LxRunOffline/wiki</a><br>例如这篇文章介绍了如何使用<code>LxRunOffline</code>安装<code>arch</code>: <a href="https://zhuanlan.zhihu.com/p/417410431">https://zhuanlan.zhihu.com/p/417410431</a></p></li><li><p>修改默认登录用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lxrunoffline su -n &lt;发行版名字&gt; -v &lt;账户<span class="built_in">id</span>&gt;</span><br><span class="line">```   </span><br><span class="line">其中`&lt;账户<span class="built_in">id</span>&gt;`可以在`Linux`中通过`<span class="built_in">id</span>`命令查询:</span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">id</span> -u 用户名</span><br></pre></td></tr></table></figure></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/">https://learn.microsoft.com/zh-cn/windows/wsl/</a><br><a href="https://www.cnblogs.com/tuilk/p/16287472.html">https://www.cnblogs.com/tuilk/p/16287472.html</a><br><a href="https://zhuanlan.zhihu.com/p/659074950">https://zhuanlan.zhihu.com/p/659074950</a><br><a href="https://blog.csdn.net/u014752296/article/details/128484185">https://blog.csdn.net/u014752296/article/details/128484185</a><br><a href="https://zhuanlan.zhihu.com/p/417410431">https://zhuanlan.zhihu.com/p/417410431</a><br><a href="https://blog.csdn.net/m0_37605642/article/details/127812965">https://blog.csdn.net/m0_37605642/article/details/127812965</a><br><a href="https://zhuanlan.zhihu.com/p/165508059">https://zhuanlan.zhihu.com/p/165508059</a><br><a href="http://www.manongjc.com/detail/28-qmgskvmcxbjzfaj.html">http://www.manongjc.com/detail/28-qmgskvmcxbjzfaj.html</a><br><a href="https://www.cnblogs.com/trendyshuai/p/17018012.html">https://www.cnblogs.com/trendyshuai/p/17018012.html</a><br><a href="https://blog.csdn.net/keyiis_sh/article/details/113819244">https://blog.csdn.net/keyiis_sh/article/details/113819244</a><br><a href="https://blog.csdn.net/qq_32666519/article/details/127378873">https://blog.csdn.net/qq_32666519/article/details/127378873</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-wsl是什么&quot;&gt;&lt;a href=&quot;#1-wsl是什么&quot; class=&quot;headerlink&quot; title=&quot;1 wsl是什么?&quot;&gt;&lt;/a&gt;1 wsl是什么?&lt;/h1&gt;&lt;p&gt;&lt;code&gt;wsl&lt;/code&gt;的官方文档点这里: &lt;a href=&quot;https://l</summary>
      
    
    
    
    <category term="实用工具" scheme="http://example.com/categories/%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="WSL" scheme="http://example.com/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.8540(6.824) Lab1: MapReduce</title>
    <link href="http://example.com/2023/12/23/MIT6.8540/Lab1_MapReduce/"/>
    <id>http://example.com/2023/12/23/MIT6.8540/Lab1_MapReduce/</id>
    <published>2023-12-23T05:25:18.000Z</published>
    <updated>2023-12-29T06:20:58.681Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-实验介绍"><a href="#1-实验介绍" class="headerlink" title="1 实验介绍"></a>1 实验介绍</h1><p>本次实验是实现一个简易版本的<code>MapReduce</code>编程框架,官方文档在这里:<a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">lab1文档</a>, 强烈建议先阅读<code>MapReduce</code>的<a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">论文</a>, 难度主要体现在设计上, 实际的代码实现倒是相对简单, 这也得益于<code>go</code>的语言特性, 比<code>CMU15445</code>使用Cpp写代码方便多了。实验需要实现的是<code>Coordinator</code>和<code>Worker</code>的设计, 具体实现细节十分自由(<del>无从下手</del>)</p><p>我的代码实现点这里： <a href="https://github.com/ToniXWD/MIT6.8540/tree/lab1">https://github.com/ToniXWD/MIT6.8540/tree/lab1</a></p><h1 id="2-既有框架解读"><a href="#2-既有框架解读" class="headerlink" title="2 既有框架解读"></a>2 既有框架解读</h1><p>解读现有的框架设计是第一步。</p><h2 id="2-1-代码解读"><a href="#2-1-代码解读" class="headerlink" title="2.1 代码解读"></a>2.1 代码解读</h2><ol><li>阅读<code>src/main/mrcoordinator.go</code>可知：<br> 服务进程通过<code>MakeCoordinator</code>启动了一个<code>Coordinator</code> c, <code>c.server()</code>中启用了一个协程用于接受<code>RPC</code>调用:<code>go http.Serve(l, nil)</code>, 需要注意的是, 在 Go 的 <code>net/http</code> 包中, 使用 <code>http.Serve(l, nil)</code> 启动 <code>HTTP</code> 服务器以侦听和处理请求时，服务器会为每个进来的请求自动启动一个新的协程。这意味着每个 RPC 调用都是在其自己的独立协程中被处理的，允许并发处理多个请求。因此, 我们的设计可能需要使用锁等同步原语实现共享资源的保护, 同时<code>Coordinator</code>不会主动与<code>Worker</code>通信(除非自己额外实现), 只能通过<code>Worker</code>的<code>RPC</code>通信来完成任务。同时， 当所有任务完成时， <code>Done</code>方法将会返回<code>false</code>, 从而将<code>Coordinator</code>关闭。</li><li>阅读<code>src/main/mrworker.go</code><br>可以得知，<code>mrworker.go</code>仅仅通过<code>Worker</code>函数来运行, 因此<code>Worker</code>函数需要完成请求任务、执行任务、报告任务执行状态等多种任务。因此可以猜测，Worker需要再这个函数里不断地轮训<code>Coordinator</code>，根据<code>Coordinator</code>的不同回复驱使当前<code>Worker</code>完成各种任务。</li></ol><h2 id="2-2-任务误区解读"><a href="#2-2-任务误区解读" class="headerlink" title="2.2 任务误区解读"></a>2.2 任务误区解读</h2><ol><li><p><code>Map</code>、<code>Reduce</code>任务、<code>Coordinator</code>和<code>Worker</code>的关系如何?<br>这些任务(文中此后称为<code>Task</code>)与<code>Worker</code>是什么关系呢? 是否存在对应关系? 这些对应关系需要记录吗? 通常, 在常见的主从关系中, 主节点需要记录从节点的信息,例如线程id等表名身份的信息, 但在我们的<code>MapReduce</code>中却没有这样的必要, 因为<code>Worker</code>节点是可以扩容的, 而<code>Coordinator</code>与<code>Worker</code>之间只有传递<code>Task</code>相关信息的需求, 因此<code>Coordinator</code>只需要记录<code>Task</code>任务的状态即可, <code>Task</code>分配给<code>Worker</code>后执行可能成功或失败, 因此<code>Coordinator</code>还需要维护任务执行的时间信息, 以便在超时后重新分配任务。因此，<code>Map</code>、<code>Reduce</code>任务、<code>Coordinator</code>和<code>Worker</code>的关系可以参考下图:</p><p><img src="/../../images/MapReduce_relation.png" alt="MapReduce_relation"></p><p> <code>Worker</code>可能在不同时间执行不同的<code>Task</code>, 也可能什么也不做(初始状态或等候所有<code>Map Task</code>完成时可能会闲置)</p></li><li><p><code>Map</code>、<code>Reduce</code>任务有多少个? 如何分配?</p><ul><li><code>Map Task</code>实际上在此实验中被简化了, 每个<code>Map Task</code>的任务就是处理一个<code>.txt</code>文件, 因此<code>Map Task</code>的数量实际上就是<code>.txt</code>文件的数量。 因此, 每个<code>.txt</code>文件对应的<code>Map Task</code>需要<code>Coordinator</code>记录其执行情况并追踪。</li><li><code>Reduce Task</code>的数量是<code>nReduce</code>。由于<code>Map Task</code>会将文件的内容分割为指定的<code>nReduce</code>份, 每一份应当由序号标明, 拥有这样的序号的多个<code>Map Task</code>的输出汇总起来就是对应的<code>Reduce Task</code>的输入。</li></ul></li><li><p>中间文件的格式是怎么样的? <code>Reduce</code>任务如何选择中间文件作为输入?<br>因为<code>Map Task</code>分割采用的是统一的哈希函数<code>ihash</code>, 所以相同的<code>key</code>一定会被<code>Map Task</code>输出到格式相同的中间文件上。例如在<code>wc</code>任务中, <code>Map Task 1</code>和<code>Map Task 2</code>输入文件中都存在<code>hello</code>这个词, <code>Map Task 1</code>中所有的<code>hello</code>会被输出到<code>mr-out-1-5</code>这个中间文件, <code>1</code>代表<code>Map Task</code>序号, <code>5</code>代表被哈希值取模的结果。那么，<code>Map Task 2</code>中所有的<code>hello</code>会被输出到<code>mr-out-2-5</code>这个中间文件。那么<code>Reduce Task 5</code>读取的就是形如<code>mr-out-*-5</code>这样的文件。</p></li></ol><h1 id="3-设计与实现"><a href="#3-设计与实现" class="headerlink" title="3 设计与实现"></a>3 设计与实现</h1><h2 id="3-1-RPC设计"><a href="#3-1-RPC设计" class="headerlink" title="3.1 RPC设计"></a>3.1 <code>RPC</code>设计</h2><h3 id="3-1-1-消息类型"><a href="#3-1-1-消息类型" class="headerlink" title="3.1.1. 消息类型"></a>3.1.1. 消息类型</h3><p>,通信时首先需要确定这个消息是什么类型, 通过前述分析可知, 通信的信息类型包括: </p><ul><li><code>Worker</code>请求任务</li><li><code>Coordinator</code>分配<code>Reduce</code>或<code>Map</code>任务</li><li><code>Worker</code>报告<code>Reduce</code>或<code>Map</code>任务的执行情况(成功或失败)</li><li><code>Coordinator</code>告知<code>Worker</code>休眠（暂时没有任务需要执行）</li><li><code>Coordinator</code>告知<code>Worker</code>退出（所有任务执行成功）</li></ul><p>每一种消息类型会需要附带额外的信息, 例如<code>Coordinator</code>分配任务需要告知任务的ID, <code>Map</code>任务还需要告知<code>NReduce</code>,和输入文件名。<br>综上考虑, 消息类型的定义如下(<code>Send</code>和<code>Reply</code>是从<code>Worker</code>视角出发的):</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    AskForTask      MsgType = <span class="literal">iota</span> <span class="comment">// `Worker`请求任务</span></span><br><span class="line">    MapTaskAlloc                   <span class="comment">// `Coordinator`分配`Map`任务</span></span><br><span class="line">    ReduceTaskAlloc                <span class="comment">// `Coordinator`分配`Reduce`任务</span></span><br><span class="line">    MapSuccess                     <span class="comment">// `Worker`报告`Map`任务的执行成功</span></span><br><span class="line">    MapFailed                      <span class="comment">// `Worker`报告`Map`任务的执行失败</span></span><br><span class="line">    ReduceSuccess                  <span class="comment">// `Worker`报告`Reduce`任务的执行成功</span></span><br><span class="line">    ReduceFailed                   <span class="comment">//`Worker`报告`Reduce`任务的执行失败</span></span><br><span class="line">    Shutdown                       <span class="comment">// `Coordinator`告知`Worker`退出（所有任务执行成功）</span></span><br><span class="line">    Wait                           <span class="comment">//`Coordinator`告知`Worker`休眠（暂时没有任务需要执行）</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MessageSend <span class="keyword">struct</span> &#123;</span><br><span class="line">    MsgType MsgType</span><br><span class="line">    TaskID  <span class="type">int</span> <span class="comment">// `Worker`回复的消息类型如MapSuccess等需要使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MessageReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    MsgType  MsgType</span><br><span class="line">    NReduce  <span class="type">int</span>    <span class="comment">// MapTaskAlloc需要告诉Map Task 切分的数量</span></span><br><span class="line">    TaskID   <span class="type">int</span>    <span class="comment">// 任务Id用于选取输入文件</span></span><br><span class="line">    TaskName <span class="type">string</span> <span class="comment">// MapSuccess专用: 告知输入.txt文件的名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-2-通信函数设计"><a href="#3-1-2-通信函数设计" class="headerlink" title="3.1.2 通信函数设计"></a>3.1.2 通信函数设计</h3><p>在我的设计中，<code>Worker</code>只需要有2个动作: </p><ul><li>向<code>Coordinator</code>请求<code>Task</code></li><li>向<code>Coordinator</code>报告之前的<code>Task</code>的执行情况</li></ul><p>因此, <code>worker.go</code>中通信函数应该是下面的样子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallForReportStatus</span><span class="params">(succesType MsgType, taskID <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 报告Task执行情况</span></span><br><span class="line">    <span class="comment">// declare an argument structure.</span></span><br><span class="line">    args := MessageSend&#123;</span><br><span class="line">        MsgType: succesType,</span><br><span class="line">        TaskID:  taskID,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    err := call(<span class="string">&quot;Coordinator.NoticeResult&quot;</span>, &amp;args, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallForTask</span><span class="params">()</span></span> *MessageReply &#123;</span><br><span class="line">    <span class="comment">// 请求一个Task</span></span><br><span class="line">    <span class="comment">// declare an argument structure.</span></span><br><span class="line">    args := MessageSend&#123;</span><br><span class="line">        MsgType: AskForTask,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// declare a reply structure.</span></span><br><span class="line">    reply := MessageReply&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// send the RPC request, wait for the reply.</span></span><br><span class="line">    err := call(<span class="string">&quot;Coordinator.AskForTask&quot;</span>, &amp;args, &amp;reply)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// fmt.Printf(&quot;TaskName %v, NReduce %v, taskID %v\n&quot;, reply.TaskName, reply.NReduce, reply.TaskID)</span></span><br><span class="line">        <span class="keyword">return</span> &amp;reply</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// log.Println(err.Error())</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>coordinator.go</code>有相应的处理函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> AskForTask(req *MessageSend, reply *MessageReply) <span class="type">error</span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> NoticeResult(req *MessageSend, reply *MessageReply) <span class="type">error</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>这些处理函数则需要进一步的设计。</p><h2 id="3-2-Worker设计"><a href="#3-2-Worker设计" class="headerlink" title="3.2 Worker设计"></a>3.2 <code>Worker</code>设计</h2><h3 id="3-2-1-Worker主函数设计"><a href="#3-2-1-Worker主函数设计" class="headerlink" title="3.2.1 Worker主函数设计"></a>3.2.1 <code>Worker</code>主函数设计</h3><p>由之前的分析可以看出，<code>Woker</code>所做的内容就是不断的请求任务、执行任务和回复任务执行情况，因此，可以很容易地写出<code>Worker</code>函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main/mrworker.go calls this function.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Worker</span><span class="params">(mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue,</span><br><span class="line">reducef <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your worker implementation here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 循环请求</span></span><br><span class="line">replyMsg := CallForTask()</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> replyMsg.MsgType &#123;</span><br><span class="line"><span class="keyword">case</span> MapTaskAlloc:</span><br><span class="line">err := HandleMapTask(replyMsg, mapf)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">_ = CallForReportStatus(MapSuccess, replyMsg.TaskID)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// log.Println(&quot;Worker: Map Task failed&quot;)</span></span><br><span class="line">_ = CallForReportStatus(MapFailed, replyMsg.TaskID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> ReduceTaskAlloc:</span><br><span class="line">err := HandleReduceTask(replyMsg, reducef)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">_ = CallForReportStatus(ReduceSuccess, replyMsg.TaskID)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// log.Println(&quot;Worker: Map Task failed&quot;)</span></span><br><span class="line">_ = CallForReportStatus(ReduceFailed, replyMsg.TaskID)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> Wait:</span><br><span class="line">time.Sleep(time.Second * <span class="number">10</span>)</span><br><span class="line"><span class="keyword">case</span> Shutdown:</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-Map-Task执行函数"><a href="#3-2-2-Map-Task执行函数" class="headerlink" title="3.2.2 Map Task执行函数"></a>3.2.2 <code>Map Task</code>执行函数</h3><p><code>HandleMapTask</code>函数是执行具体的<code>MapTask</code>, 这样部分很简单, 可以从<code>mrsequential.go</code>中偷代码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleMapTask</span><span class="params">(reply *MessageReply, mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue) <span class="type">error</span> &#123;</span><br><span class="line">file, err := os.Open(reply.TaskName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">content, err := io.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行mapf</span></span><br><span class="line">kva := mapf(reply.TaskName, <span class="type">string</span>(content))</span><br><span class="line">sort.Sort(ByKey(kva))</span><br><span class="line"></span><br><span class="line">oname_prefix := <span class="string">&quot;mr-out-&quot;</span> + strconv.Itoa(reply.TaskID) + <span class="string">&quot;-&quot;</span></span><br><span class="line"></span><br><span class="line">key_group := <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">key_group[kv.Key] = <span class="built_in">append</span>(key_group[kv.Key], kv.Value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先清理可能存在的垃圾</span></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> 原子重命名的方法</span></span><br><span class="line">_ = DelFileByMapId(reply.TaskID, <span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, values := <span class="keyword">range</span> key_group &#123;</span><br><span class="line">redId := ihash(key)</span><br><span class="line">oname := oname_prefix + strconv.Itoa(redId%reply.NReduce)</span><br><span class="line"><span class="keyword">var</span> ofile *os.File</span><br><span class="line"><span class="keyword">if</span> _, err := os.Stat(oname); os.IsNotExist(err) &#123;</span><br><span class="line"><span class="comment">// 文件夹不存在</span></span><br><span class="line">ofile, _ = os.Create(oname)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ofile, _ = os.OpenFile(oname, os.O_APPEND|os.O_CREATE|os.O_WRONLY, <span class="number">0644</span>)</span><br><span class="line">&#125;</span><br><span class="line">enc := json.NewEncoder(ofile)</span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> values &#123;</span><br><span class="line">err := enc.Encode(&amp;KeyValue&#123;Key: key, Value: value&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">ofile.Close()</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ofile.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然偷了很多代码, 但是有家店需要注意, 因为之前的<code>Worker</code>可能写入了一部分数据到中间文件后失败的情况, 之后<code>Coordinator</code>重新分配任务时, 文件是可能存在脏数据的, 因此需要先执行清理:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_ = DelFileByMapId(reply.TaskID, <span class="string">&quot;./&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DelFileByMapId</span><span class="params">(targetNumber <span class="type">int</span>, path <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 创建正则表达式，X 是可变的指定数字</span></span><br><span class="line">pattern := fmt.Sprintf(<span class="string">`^mr-out-%d-\d+$`</span>, targetNumber)</span><br><span class="line">regex, err := regexp.Compile(pattern)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取当前目录中的文件</span></span><br><span class="line">files, err := os.ReadDir(path)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历文件，查找匹配的文件</span></span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> files &#123;</span><br><span class="line"><span class="keyword">if</span> file.IsDir() &#123;</span><br><span class="line"><span class="keyword">continue</span> <span class="comment">// 跳过目录</span></span><br><span class="line">&#125;</span><br><span class="line">fileName := file.Name()</span><br><span class="line"><span class="keyword">if</span> regex.MatchString(fileName) &#123;</span><br><span class="line"><span class="comment">// 匹配到了文件，删除它</span></span><br><span class="line">filePath := filepath.Join(path, file.Name())</span><br><span class="line">err := os.Remove(filePath)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DelFileByMapId</code>函数删除特定<code>Map Task</code>的输出文件, 但这样的执行存在一定隐患:</p><ul><li>首先是<code>Coordinator</code>只能重新分配一个<code>Worker</code>执行<code>Coordinator</code>认为死掉的任务, 这一点可以通过加锁和记录时间戳完成, 后续会讲到</li><li>其次, 如果之前死掉的<code>Worker</code>又活了,其可能和现在的<code>Worker</code>的输出又有交叉了</li></ul><p>因此, 目前的实现是存在一定漏洞的, 有以下的改进方案:</p><ol><li>参考官方的提示, 先为当前的中间文件使用临时名, 完成操作后再进行原子重命名</li><li>通过加文件锁的方式保护文件</li></ol><blockquote><p>Ps: 后续有时间再改代码吧</p></blockquote><h3 id="3-2-3-Reduce-Task执行函数"><a href="#3-2-3-Reduce-Task执行函数" class="headerlink" title="3.2.3 Reduce Task执行函数"></a>3.2.3 <code>Reduce Task</code>执行函数</h3><p><code>Reduce Task</code>手机对应序号的中间文件, 汇总后应用指定的<code>reduce函数</code>,实现也比较简单:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleReduceTask</span><span class="params">(reply *MessageReply, reducef <span class="keyword">func</span>(<span class="type">string</span>, []<span class="type">string</span>)</span></span> <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">key_id := reply.TaskID</span><br><span class="line"></span><br><span class="line">k_vs := <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">fileList, err := ReadSpecificFile(key_id, <span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整理所有的中间文件</span></span><br><span class="line"><span class="keyword">for</span> _, file := <span class="keyword">range</span> fileList &#123;</span><br><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line"><span class="keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">k_vs[kv.Key] = <span class="built_in">append</span>(k_vs[kv.Key], kv.Value)</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有的键并排序</span></span><br><span class="line"><span class="keyword">var</span> keys []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> k_vs &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(keys)</span><br><span class="line"></span><br><span class="line">oname := <span class="string">&quot;mr-out-&quot;</span> + strconv.Itoa(reply.TaskID)</span><br><span class="line">ofile, err := os.Create(oname)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> ofile.Close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">output := reducef(key, k_vs[key])</span><br><span class="line">_, err := fmt.Fprintf(ofile, <span class="string">&quot;%v %v\n&quot;</span>, key, output)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DelFileByReduceId(reply.TaskID, <span class="string">&quot;./&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是, 我收集文件内容是使用了<code>map</code>, 而迭代<code>map</code>时, <code>key</code>的顺序是随机的, 因此需要先进行对<code>key</code>排序的操作:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有的键并排序</span></span><br><span class="line"><span class="keyword">var</span> keys []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> k_vs &#123;</span><br><span class="line">keys = <span class="built_in">append</span>(keys, k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(keys)</span><br></pre></td></tr></table></figure><blockquote><p>其实这里也存在漏洞:同样就是死了的<code>Worker</code>突然复活了怎么办的问题，相比<code>Map Task</code>来说, 这里虽然相对不容易出错, 因为这里对多个中间文件只存在读取而不存在写入, 将内容读取到内存中不会有冲突的。出错只可能在将数据在写入到指定的文件时, <code>os.Create(oname)</code>也会存在竞争条件：因为网络等问题，<code>Coordinator</code>启动了多个<code>Worker</code>, 多个<code>Worker</code>同时运行，并且都尝试创建同一个文件名<code>oname</code>, 假设一个Worker先创建了oname并写入了一部分数据，当另一个Worker再次调用os.Create(oname)时，之前的数据将会被清空。这意味着第一个Worker在接下来的写操作中不会出现错误，但它写入的部分数据会丢失，因为第二个Worker已经截断了文件。</p></blockquote><p>因此, 目前的实现是也存在一定漏洞的, 有以下的改进方案:</p><ol><li>参考官方的提示, 先为当前的中间文件使用临时名, 完成操作后再进行原子重命名</li><li>通过加文件锁的方式保护文件</li></ol><h2 id="3-3-Coordinator设计"><a href="#3-3-Coordinator设计" class="headerlink" title="3.3 Coordinator设计"></a>3.3 <code>Coordinator</code>设计</h2><h3 id="3-3-1-TaskInfo设计"><a href="#3-3-1-TaskInfo设计" class="headerlink" title="3.3.1 TaskInfo设计"></a>3.3.1 <code>TaskInfo</code>设计</h3><p>首先需要考虑的是, 如何维护<code>Task</code>的执行信息, <code>Task</code>执行状态包括了: 未执行、执行者、执行失败、执行完成。<br>这里有一个很重要的问题需要考虑， 超时的任务时什么状态呢？因为在我的设计中，<code>Coordinator</code>与<code>Worker</code>是通过<code>RPC</code>来驱动彼此运行的, 当然你也可以启动一个<code>goroutine</code>间隔地检查是否超时, 但为了使设计更简单, 我们可以这样设计检查超时的方案:</p><ol><li>为每个<code>Worker</code>分配<code>Task</code>时需要记录<code>Task</code>被分配的时间戳, 并将其状态置为<code>running</code></li><li>为每个<code>Worker</code>分配<code>Task</code>, 遍历存储<code>TaskInfo</code>的数据结构, 检查每一个状态为<code>running</code>的<code>Task</code>的时间戳是否与当前时间戳差距大于<code>10s</code>, 如果是, 则代表这个<code>Task</code>超时了, 立即将它分配给当前请求的<code>Worker</code>, 并更新其时间戳</li><li>如果导致<code>Task</code>超时的老旧的<code>Woker</code>之后又完成了, 结果也就是这个<code>Task</code>返回了多次执行成功的报告而已, 可忽略</li></ol><blockquote><p>PS: <code>Worker</code>执行失败有2种, 一种是<code>Worker</code>没有崩溃但发现了<code>error</code>, 这时<code>Worker</code>会将错误报告给<code>Coordinator</code>, <code>Coordinator</code>会将其状态设置为<code>failed</code>, 另一种情况是<code>Worker</code>崩溃了, 连通知都做不到, 这就以超时体现出来, 处理好超时即可</p></blockquote><p>因此, 我如下设计<code>TaskInfo</code>的数据结构:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> taskStatus <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 状态</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">idle     taskStatus = <span class="literal">iota</span> <span class="comment">// 闲置未分配</span></span><br><span class="line">running                    <span class="comment">// 正在运行</span></span><br><span class="line">finished                   <span class="comment">// 完成</span></span><br><span class="line">failed                     <span class="comment">//失败</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Map Task 执行状态</span></span><br><span class="line"><span class="keyword">type</span> MapTaskInfo <span class="keyword">struct</span> &#123;</span><br><span class="line">TaskId    <span class="type">int</span>        <span class="comment">// Task 序号</span></span><br><span class="line">Status    taskStatus <span class="comment">// 执行状态</span></span><br><span class="line">StartTime <span class="type">int64</span>      <span class="comment">// 开始执行时间戳</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reduce Task 执行状态</span></span><br><span class="line"><span class="keyword">type</span> ReduceTaskInfo <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// ReduceTask的 序号 由数组下标决定, 不进行额外存储</span></span><br><span class="line">Status    taskStatus <span class="comment">// 执行状态</span></span><br><span class="line">StartTime <span class="type">int64</span>      <span class="comment">// 开始执行时间戳</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line">NReduce     <span class="type">int</span>                     <span class="comment">// the number of reduce tasks to use.</span></span><br><span class="line">MapTasks    <span class="keyword">map</span>[<span class="type">string</span>]*MapTaskInfo <span class="comment">//MapTaskInfo</span></span><br><span class="line">mu          sync.Mutex              <span class="comment">// 一把大锁保平安</span></span><br><span class="line">ReduceTasks []*ReduceTaskInfo       <span class="comment">// ReduceTaskInfo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加<code>TaskInfo</code>的初始化方法, 并在<code>MakeCoordinator</code>中调用:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> initTask(files []<span class="type">string</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> idx, fileName := <span class="keyword">range</span> files &#123;</span><br><span class="line">c.MapTasks[fileName] = &amp;MapTaskInfo&#123;</span><br><span class="line">TaskId: idx,</span><br><span class="line">Status: idle,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> idx := <span class="keyword">range</span> c.ReduceTasks &#123;</span><br><span class="line">c.ReduceTasks[idx] = &amp;ReduceTaskInfo&#123;</span><br><span class="line">Status: idle,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">MakeCoordinator</span><span class="params">(files []<span class="type">string</span>, nReduce <span class="type">int</span>)</span></span> *Coordinator &#123;</span><br><span class="line">c := Coordinator&#123;</span><br><span class="line">NReduce:     nReduce,</span><br><span class="line">MapTasks:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*MapTaskInfo),</span><br><span class="line">ReduceTasks: <span class="built_in">make</span>([]*ReduceTaskInfo, nReduce),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"><span class="comment">// 由于每一个文件名就是一个map task ,需要初始化任务状态</span></span><br><span class="line">c.initTask(files)</span><br><span class="line"></span><br><span class="line">c.server()</span><br><span class="line"><span class="keyword">return</span> &amp;c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-2-RPC-响应函数-AskForTask"><a href="#3-3-2-RPC-响应函数-AskForTask" class="headerlink" title="3.3.2 RPC 响应函数-AskForTask"></a>3.3.2 <code>RPC</code> 响应函数-<code>AskForTask</code></h3><p>这部分算是较为复杂的, 其逻辑如下:</p><ol><li>如果有闲置的任务(<code>idle</code>)和之前执行失败(<code>failed</code>)的<code>Map Task</code>, 选择这个任务进行分配</li><li>如果检查到有超时的任务<code>Map Task</code>, 选择这个任务进行分配</li><li>如果以上的<code>Map Task</code>均不存在, 但<code>Map Task</code>又没有全部执行完成, 告知<code>Worker</code>先等待</li><li><code>Map Task</code>全部执行完成的情况下, 按照<code>1</code>和<code>2</code>相同的逻辑进行<code>Reduce Task</code>的分配</li><li>所有的<code>Task</code>都执行完成了, 告知<code>Worker</code>退出</li></ol><p>因此, <code>AskForTask</code>代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> AskForTask(req *MessageSend, reply *MessageReply) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> req.MsgType != AskForTask &#123;</span><br><span class="line"><span class="keyword">return</span> BadMsgType</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 选择一个任务返回给worker</span></span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"></span><br><span class="line">count_map_success := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> fileName, taskinfo := <span class="keyword">range</span> c.MapTasks &#123;</span><br><span class="line">alloc := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> taskinfo.Status == idle || taskinfo.Status == failed &#123;</span><br><span class="line"><span class="comment">// 选择闲置或者失败的任务</span></span><br><span class="line">alloc = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> taskinfo.Status == running &#123;</span><br><span class="line"><span class="comment">// 判断其是否超时, 超时则重新派发</span></span><br><span class="line">curTime := time.Now().Unix()</span><br><span class="line"><span class="keyword">if</span> curTime-taskinfo.StartTime &gt; <span class="number">10</span> &#123;</span><br><span class="line">taskinfo.StartTime = curTime</span><br><span class="line">alloc = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">count_map_success++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> alloc &#123;</span><br><span class="line"><span class="comment">// 将未分配的任务和已经失败的任务分配给这个worker</span></span><br><span class="line">reply.MsgType = MapTaskAlloc</span><br><span class="line">reply.TaskName = fileName</span><br><span class="line">reply.NReduce = c.NReduce</span><br><span class="line">reply.TaskID = taskinfo.TaskId</span><br><span class="line"></span><br><span class="line"><span class="comment">// log.Printf(&quot;coordinator: apply Map Task: taskID = %v\n&quot;, reply.TaskID)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改状态信息</span></span><br><span class="line">taskinfo.Status = running</span><br><span class="line">taskinfo.StartTime = time.Now().Unix()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> count_map_success &lt; <span class="built_in">len</span>(c.MapTasks) &#123;</span><br><span class="line"><span class="comment">// map任务没有可以分配的, 但都还未完成</span></span><br><span class="line">reply.MsgType = Wait</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">count_reduce_success := <span class="number">0</span></span><br><span class="line"><span class="comment">// 运行到这里说明map任务都已经完成</span></span><br><span class="line"><span class="keyword">for</span> idx, taskinfo := <span class="keyword">range</span> c.ReduceTasks &#123;</span><br><span class="line">alloc := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> taskinfo.Status == idle || taskinfo.Status == failed &#123;</span><br><span class="line">alloc = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> taskinfo.Status == running &#123;</span><br><span class="line"><span class="comment">// 判断其是否超时, 超时则重新派发</span></span><br><span class="line">curTime := time.Now().Unix()</span><br><span class="line"><span class="keyword">if</span> curTime-taskinfo.StartTime &gt; <span class="number">10</span> &#123;</span><br><span class="line">taskinfo.StartTime = curTime</span><br><span class="line">alloc = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">count_reduce_success++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> alloc &#123;</span><br><span class="line"><span class="comment">// 分配给其一个Reduce任务</span></span><br><span class="line">reply.MsgType = ReduceTaskAlloc</span><br><span class="line">reply.TaskID = idx</span><br><span class="line"></span><br><span class="line"><span class="comment">// log.Printf(&quot;coordinator: apply Reduce Task: taskID = %v\n&quot;, reply.TaskID)</span></span><br><span class="line"></span><br><span class="line">taskinfo.Status = running</span><br><span class="line">taskinfo.StartTime = time.Now().Unix()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> count_reduce_success &lt; <span class="built_in">len</span>(c.ReduceTasks) &#123;</span><br><span class="line"><span class="comment">// reduce任务没有可以分配的, 但都还未完成</span></span><br><span class="line">reply.MsgType = Wait</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行到这里说明所有任务都已经完成</span></span><br><span class="line">reply.MsgType = Shutdown</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里, 我对数据的保护是一把大锁保平安, 这其实可以优化的</p></blockquote><h3 id="3-3-3-RPC-响应函数-NoticeResult"><a href="#3-3-3-RPC-响应函数-NoticeResult" class="headerlink" title="3.3.3 RPC 响应函数-NoticeResult"></a>3.3.3 <code>RPC</code> 响应函数-<code>NoticeResult</code></h3><p>这个函数就简单很多了, 只需要改变对应<code>TaskInfo</code>的状态即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> NoticeResult(req *MessageSend, reply *MessageReply) <span class="type">error</span> &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> req.MsgType == MapSuccess &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> c.MapTasks &#123;</span><br><span class="line"><span class="keyword">if</span> v.TaskId == req.TaskID &#123;</span><br><span class="line">v.Status = finished</span><br><span class="line"><span class="comment">// log.Printf(&quot;coordinator: map task%v finished\n&quot;, v.TaskId)</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> req.MsgType == ReduceSuccess &#123;</span><br><span class="line">c.ReduceTasks[req.TaskID].Status = finished</span><br><span class="line"><span class="comment">// log.Printf(&quot;coordinator: reduce task%v finished\n&quot;, req.TaskID)</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> req.MsgType == MapFailed &#123;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> c.MapTasks &#123;</span><br><span class="line"><span class="keyword">if</span> v.TaskId == req.TaskID &#123;</span><br><span class="line">v.Status = failed</span><br><span class="line"><span class="comment">// log.Printf(&quot;coordinator: map task%v failed\n&quot;, v.TaskId)</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> req.MsgType == ReduceFailed &#123;</span><br><span class="line">c.ReduceTasks[req.TaskID].Status = failed</span><br><span class="line"><span class="comment">// log.Printf(&quot;coordinator: reduce task%v failed\n&quot;, req.TaskID)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-4-Done方法"><a href="#3-3-4-Done方法" class="headerlink" title="3.3.4 Done方法"></a>3.3.4 <code>Done</code>方法</h3><p><code>Done</code>方法是最简单的, 遍历<code>TaskInfo</code>的数据结构, 如果全部完成则返回<code>True</code>, </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> Done() <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// Your code here.</span></span><br><span class="line"><span class="comment">// 先确认mapTask完成</span></span><br><span class="line"><span class="keyword">for</span> _, taskinfo := <span class="keyword">range</span> c.MapTasks &#123;</span><br><span class="line"><span class="keyword">if</span> taskinfo.Status != finished &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Println(&quot;Coordinator: All map task finished&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再确认Reduce Task 完成</span></span><br><span class="line"><span class="keyword">for</span> _, taskinfo := <span class="keyword">range</span> c.ReduceTasks &#123;</span><br><span class="line"><span class="keyword">if</span> taskinfo.Status != finished &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Println(&quot;Coordinator: All reduce task finished&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// time.Sleep(time.Second * 5)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个小细节, <code>time.Sleep(time.Second * 5)</code>是为了让<code>Coordinator</code>延迟关闭, 这样可以留出时间告知<code>Worker</code>退出, 也可以直接注释掉它, 让测试跑得更快</p><h1 id="4-测试和优化"><a href="#4-测试和优化" class="headerlink" title="4 测试和优化"></a>4 测试和优化</h1><h2 id="4-1-原实现测试"><a href="#4-1-原实现测试" class="headerlink" title="4.1 原实现测试"></a>4.1 原实现测试</h2><p>运行测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ time bash test-mr.sh</span><br></pre></td></tr></table></figure><p>结果如下图, 耗时3m3s</p><p><img src="/../../images/MapReduce-Test.png" alt="MapReduce-Test"></p><h2 id="4-2-优化"><a href="#4-2-优化" class="headerlink" title="4.2 优化"></a>4.2 优化</h2><h3 id="4-2-1-原子重命名"><a href="#4-2-1-原子重命名" class="headerlink" title="4.2.1 原子重命名"></a>4.2.1 原子重命名</h3><p>按照官方提示, 使用原子重命名避免竞争, 修改<code>HandleMapTask</code>函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleMapTask</span><span class="params">(reply *MessageReply, mapf <span class="keyword">func</span>(<span class="type">string</span>, <span class="type">string</span>)</span></span> []KeyValue) <span class="type">error</span> &#123;</span><br><span class="line">file, err := os.Open(reply.TaskName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">content, err := io.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">kva := mapf(reply.TaskName, <span class="type">string</span>(content))</span><br><span class="line">sort.Sort(ByKey(kva))</span><br><span class="line"></span><br><span class="line">tempFiles := <span class="built_in">make</span>([]*os.File, reply.NReduce)</span><br><span class="line">encoders := <span class="built_in">make</span>([]*json.Encoder, reply.NReduce)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> kva &#123;</span><br><span class="line">redId := ihash(kv.Key) % reply.NReduce</span><br><span class="line"><span class="keyword">if</span> encoders[redId] == <span class="literal">nil</span> &#123;</span><br><span class="line">tempFile, err := ioutil.TempFile(<span class="string">&quot;&quot;</span>, fmt.Sprintf(<span class="string">&quot;mr-map-tmp-%d&quot;</span>, redId))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> tempFile.Close()</span><br><span class="line">tempFiles[redId] = tempFile</span><br><span class="line">encoders[redId] = json.NewEncoder(tempFile)</span><br><span class="line">&#125;</span><br><span class="line">err := encoders[redId].Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, file := <span class="keyword">range</span> tempFiles &#123;</span><br><span class="line"><span class="keyword">if</span> file != <span class="literal">nil</span> &#123;</span><br><span class="line">fileName := file.Name()</span><br><span class="line">file.Close()</span><br><span class="line">newName := fmt.Sprintf(<span class="string">&quot;mr-out-%d-%d&quot;</span>, reply.TaskID, i)</span><br><span class="line"><span class="keyword">if</span> err := os.Rename(fileName, newName); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ time bash test-mr.sh</span><br></pre></td></tr></table></figure><p>结果如下图, 耗时2m52s, 原子重命名节省了原实现中的清理耗费的时间, 节约了差不多10s的样子</p><p><img src="/../../images/MapReduce-Test-2.png" alt="MapReduce-Test-2"></p><h3 id="4-2-2-锁细化"><a href="#4-2-2-锁细化" class="headerlink" title="4.2.2 锁细化"></a>4.2.2 锁细化</h3><p>我们可以发现, 在<code>Worker</code>请求任务时, <code>Map Task</code>是需要先全部执行成功的, 因此我们可以增加一个字段记录<code>Map Task</code>是否全部完成, 同时为<code>MapTaskInfo</code>和<code>ReduceTaskInfo</code>分别实现设计一个锁来取代原来的大锁, 代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Coordinator <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Your definitions here.</span></span><br><span class="line">NReduce       <span class="type">int</span>                     <span class="comment">// the number of reduce tasks to use.</span></span><br><span class="line">MapTasks      <span class="keyword">map</span>[<span class="type">string</span>]*MapTaskInfo <span class="comment">//MapTaskInfo</span></span><br><span class="line">MapSuccess    <span class="type">bool</span>                    <span class="comment">// Map Task 是否全部完成</span></span><br><span class="line">muMap         sync.Mutex              <span class="comment">// Map 锁, 保护 MapTasks</span></span><br><span class="line">ReduceTasks   []*ReduceTaskInfo       <span class="comment">// ReduceTaskInfo</span></span><br><span class="line">ReduceSuccess <span class="type">bool</span>                    <span class="comment">// Reduce Task 是否全部完成</span></span><br><span class="line">muReduce      sync.Mutex              <span class="comment">// Reduce 锁, 保护 ReduceTasks</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Coordinator)</span></span> AskForTask(req *MessageSend, reply *MessageReply) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> req.MsgType != AskForTask &#123;</span><br><span class="line"><span class="keyword">return</span> BadMsgType</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !c.MapSuccess &#123;</span><br><span class="line"><span class="comment">// 选择一个 Map Task 返回给worker</span></span><br><span class="line"></span><br><span class="line">c.muMap.Lock()</span><br><span class="line"></span><br><span class="line">count_map_success := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> fileName, taskinfo := <span class="keyword">range</span> c.MapTasks &#123;</span><br><span class="line">alloc := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> taskinfo.Status == idle || taskinfo.Status == failed &#123;</span><br><span class="line"><span class="comment">// 选择闲置或者失败的任务</span></span><br><span class="line">alloc = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> taskinfo.Status == running &#123;</span><br><span class="line"><span class="comment">// 判断其是否超时, 超时则重新派发</span></span><br><span class="line">curTime := time.Now().Unix()</span><br><span class="line"><span class="keyword">if</span> curTime-taskinfo.StartTime &gt; <span class="number">10</span> &#123;</span><br><span class="line">taskinfo.StartTime = curTime</span><br><span class="line">alloc = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">count_map_success++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> alloc &#123;</span><br><span class="line"><span class="comment">// 将未分配的任务和已经失败的任务分配给这个worker</span></span><br><span class="line">reply.MsgType = MapTaskAlloc</span><br><span class="line">reply.TaskName = fileName</span><br><span class="line">reply.NReduce = c.NReduce</span><br><span class="line">reply.TaskID = taskinfo.TaskId</span><br><span class="line"></span><br><span class="line"><span class="comment">// log.Printf(&quot;coordinator: apply Map Task: taskID = %v\n&quot;, reply.TaskID)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改状态信息</span></span><br><span class="line">taskinfo.Status = running</span><br><span class="line">taskinfo.StartTime = time.Now().Unix()</span><br><span class="line">c.muMap.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.muMap.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> count_map_success &lt; <span class="built_in">len</span>(c.MapTasks) &#123;</span><br><span class="line"><span class="comment">// map任务没有可以分配的, 但都还未完成</span></span><br><span class="line">reply.MsgType = Wait</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.MapSuccess = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !c.ReduceSuccess &#123;</span><br><span class="line"><span class="comment">// 选择一个 Reduce Task 返回给worker</span></span><br><span class="line">c.muReduce.Lock()</span><br><span class="line"></span><br><span class="line">count_reduce_success := <span class="number">0</span></span><br><span class="line"><span class="comment">// 运行到这里说明map任务都已经完成</span></span><br><span class="line"><span class="keyword">for</span> idx, taskinfo := <span class="keyword">range</span> c.ReduceTasks &#123;</span><br><span class="line">alloc := <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> taskinfo.Status == idle || taskinfo.Status == failed &#123;</span><br><span class="line">alloc = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> taskinfo.Status == running &#123;</span><br><span class="line"><span class="comment">// 判断其是否超时, 超时则重新派发</span></span><br><span class="line">curTime := time.Now().Unix()</span><br><span class="line"><span class="keyword">if</span> curTime-taskinfo.StartTime &gt; <span class="number">10</span> &#123;</span><br><span class="line">taskinfo.StartTime = curTime</span><br><span class="line">alloc = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">count_reduce_success++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> alloc &#123;</span><br><span class="line"><span class="comment">// 分配给其一个Reduce任务</span></span><br><span class="line">reply.MsgType = ReduceTaskAlloc</span><br><span class="line">reply.TaskID = idx</span><br><span class="line"></span><br><span class="line"><span class="comment">// log.Printf(&quot;coordinator: apply Reduce Task: taskID = %v\n&quot;, reply.TaskID)</span></span><br><span class="line"></span><br><span class="line">taskinfo.Status = running</span><br><span class="line">taskinfo.StartTime = time.Now().Unix()</span><br><span class="line"></span><br><span class="line">c.muReduce.Unlock()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.muReduce.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> count_reduce_success &lt; <span class="built_in">len</span>(c.ReduceTasks) &#123;</span><br><span class="line"><span class="comment">// reduce任务没有可以分配的, 但都还未完成</span></span><br><span class="line">reply.MsgType = Wait</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.ReduceSuccess = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行到这里说明所有任务都已经完成</span></span><br><span class="line">reply.MsgType = Shutdown</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ time bash test-mr.sh</span><br></pre></td></tr></table></figure><p>结果如下图, 耗时2m39s, 原子重命名节省了原实现中的清理耗费的时间, 又节约了差不多13s的样子<br>另外别忘了<code>NoticeResult</code>也要相应地修改, 由于比较简单就不列出来了, 可以直接看仓库代码。</p><p><img src="/../../images/MapReduce-Test-3.png" alt="MapReduce-Test-3"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-实验介绍&quot;&gt;&lt;a href=&quot;#1-实验介绍&quot; class=&quot;headerlink&quot; title=&quot;1 实验介绍&quot;&gt;&lt;/a&gt;1 实验介绍&lt;/h1&gt;&lt;p&gt;本次实验是实现一个简易版本的&lt;code&gt;MapReduce&lt;/code&gt;编程框架,官方文档在这里:&lt;a hr</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.5840(6.824) 2023" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/"/>
    
    <category term="Lab笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/Lab%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="分布式系统" scheme="http://example.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Go" scheme="http://example.com/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 0: 环境配置</title>
    <link href="http://example.com/2023/12/19/MIT6.S081/0%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://example.com/2023/12/19/MIT6.S081/0%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2023-12-19T13:56:47.000Z</published>
    <updated>2023-12-23T18:04:11.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-课程简介"><a href="#1-课程简介" class="headerlink" title="1 课程简介"></a>1 课程简介</h1><p>MIT6.S081 Operating System Engineering 是麻省理工学院的 <code>PDOS</code> 实验室开设的面向MIT本科生的操作系统课程, 课程前身为MIT6.828。课程主题是介绍 <code>基于 RISCV 架构实现的类Unix OS xv6</code>, 基本上每一部分的内容都有对应的<code>xv6 lab</code>, 涉及页表、中断、内存管理、线程调度、锁、文件系统等OS的基本内容。课程附有专门的教材介绍<code>xv6</code>的设计架构, 并结合了与通用操作系统的比较和相应前沿技术的简单介绍。</p><h1 id="2-资源汇总"><a href="#2-资源汇总" class="headerlink" title="2 资源汇总"></a>2 资源汇总</h1><ol><li>课程官网：<br>2020秋： <a href="https://pdos.csail.mit.edu/6.828/2020/schedule.html">https://pdos.csail.mit.edu/6.828/2020/schedule.html</a><br>2021秋： <a href="https://pdos.csail.mit.edu/6.828/2021/schedule.html">https://pdos.csail.mit.edu/6.828/2021/schedule.html</a></li><li>中文参考文献<br>课程内容翻译（2020秋）： <a href="https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/">https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/</a><br>xv6中文文档（版本较旧）： <a href="https://th0ar.gitbooks.io/xv6-chinese/content/index.html">https://th0ar.gitbooks.io/xv6-chinese/content/index.html</a></li><li>教材、lab指导书、视频、ppt等资源<br>见官网</li></ol><h1 id="3-环境配置"><a href="#3-环境配置" class="headerlink" title="3 环境配置"></a>3 环境配置</h1><p>官网的环境配置参考为： <a href="https://pdos.csail.mit.edu/6.828/2020/tools.html">https://pdos.csail.mit.edu/6.828/2020/tools.html</a><br>我的方案是在 <code>Windows11 wsl2</code> 中进行环境配置</p><h2 id="3-1-wsl2安装Ubuntu22-04"><a href="#3-1-wsl2安装Ubuntu22-04" class="headerlink" title="3.1 wsl2安装Ubuntu22.04"></a>3.1 wsl2安装Ubuntu22.04</h2><p>wsl2的安装参考 <a href="https://learn.microsoft.com/zh-cn/windows/wsl/">微软官方文档</a></p><h3 id="3-1-1-启用Linux子系统功能"><a href="#3-1-1-启用Linux子系统功能" class="headerlink" title="3.1.1 启用Linux子系统功能"></a>3.1.1 启用Linux子系统功能</h3><p>系统搜索<strong>启用或关闭Windows功能</strong>，如下图开启功能<br><img src="/../../images/enable_win_func.png" alt="en../imagesble_win_func"></p><h3 id="3-1-2-BIOS开启CPU虚拟化功能"><a href="#3-1-2-BIOS开启CPU虚拟化功能" class="headerlink" title="3.1.2 BIOS开启CPU虚拟化功能"></a>3.1.2 BIOS开启CPU虚拟化功能</h3><p>不同的主板厂商BIOS界面设置不同，大体上的位置可参考下图<br><img src="/../../images/enable-virtualization.png" alt="enable-virtualization"></p><h3 id="3-1-3-安装wsl2"><a href="#3-1-3-安装wsl2" class="headerlink" title="3.1.3 安装wsl2"></a>3.1.3 安装wsl2</h3><p>最好以管理员模式打开powershell，输入如下命令进行安装</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> wsl <span class="literal">-l</span> <span class="literal">-o</span></span><br><span class="line"><span class="comment"># 改命令会搜索可在线安装的发行版</span></span><br></pre></td></tr></table></figure><p>默认安装Ubuntu20.04</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span></span><br></pre></td></tr></table></figure><p>或安装指定版本</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span> <span class="literal">-d</span> Ubuntu<span class="literal">-20</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure><p>如果使用了<a href="https://learn.microsoft.com/zh-cn/windows/terminal/install">Windows Terminal</a>，其选项卡中会自动添加安装的Linux发行版<br>也可以使用powershell进入虚拟机：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">-d</span> Ubuntu</span><br></pre></td></tr></table></figure><h3 id="3-1-4-Ubuntu换源"><a href="#3-1-4-Ubuntu换源" class="headerlink" title="3.1.4 Ubuntu换源"></a>3.1.4 Ubuntu换源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>将其替换为如下内容</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 默认注释了源码镜像以提高 apt <span class="keyword">update</span> 速度，如有需要可自行取消注释</span><br><span class="line"><span class="keyword">deb</span> https://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src https://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ jammy main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> https://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src https://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ jammy-updates main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> https://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src https://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ jammy-backports main restricted universe multiverse</span><br><span class="line"><span class="keyword">deb</span> https://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src https://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ jammy-security main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"># 预发布软件源，不建议启用</span><br><span class="line"># <span class="keyword">deb</span> https://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ jammy-proposed main restricted universe multiverse</span><br><span class="line"># <span class="keyword">deb</span>-src https://mirrors.tuna.tsinghua.edu.<span class="keyword">cn</span>/ubuntu/ jammy-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>然后更新源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h2 id="3-2-安装riscv交叉编译工具和qemu"><a href="#3-2-安装riscv交叉编译工具和qemu" class="headerlink" title="3.2 安装riscv交叉编译工具和qemu"></a>3.2 安装riscv交叉编译工具和qemu</h2><h3 id="3-2-1-安装riscv交叉编译工具"><a href="#3-2-1-安装riscv交叉编译工具" class="headerlink" title="3.2.1 安装riscv交叉编译工具"></a>3.2.1 安装riscv交叉编译工具</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></table></figure><h3 id="3-2-2-编译安装qemu"><a href="#3-2-2-编译安装qemu" class="headerlink" title="3.2.2 编译安装qemu"></a>3.2.2 编译安装qemu</h3><p>官网指定版本为qemu-5.1.0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> qemu-5.1.0</span><br><span class="line">$ ./configure --disable-kvm --disable-werror --prefix=/usr/local --target-list=<span class="string">&quot;riscv64-softmmu&quot;</span></span><br><span class="line">$ make</span><br><span class="line">$ sudo make install</span><br><span class="line"><span class="comment"># 验证安装</span></span><br><span class="line">$ qemu-system-riscv64 --version</span><br><span class="line"><span class="comment"># 成功则输出如下内容</span></span><br><span class="line">QEMU emulator version 5.1.0</span><br><span class="line">Copyright (c) 2003-2020 Fabrice Bellard and the QEMU Project developers</span><br></pre></td></tr></table></figure><h2 id="3-3-安装gdb"><a href="#3-3-安装gdb" class="headerlink" title="3.3 安装gdb"></a>3.3 安装gdb</h2><p>按照指导书进行环境配置对于基础的代码运行是没有问题，但我发现自己按照指导书操作后无法进行<code>gdb</code>调试, 经过总结后在此处给出我的2种解决方案:</p><h3 id="方案1-安装完整的-riscv-gnu-toolchain"><a href="#方案1-安装完整的-riscv-gnu-toolchain" class="headerlink" title="方案1: 安装完整的 riscv-gnu-toolchain"></a>方案1: 安装完整的 <code>riscv-gnu-toolchain</code></h3><p>安装完整的<code>riscv-gnu-toolchain</code>流程如下, 次方法费时较长, 且占据空间较大, 更推荐第二种方法。</p><ol><li>安装依赖<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc zlib1g-dev libexpat-dev</span><br></pre></td></tr></table></figure></li><li>克隆<code>riscv-gnu-toolchain</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --recursive https://github.com/riscv/riscv-gnu-toolchain</span><br></pre></td></tr></table></figure></li><li>编译安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> riscv-gnu-toolchain</span><br><span class="line">$ ./configure --prefix=/usr/local</span><br><span class="line">$ sudo make</span><br></pre></td></tr></table></figure></li></ol><h3 id="方案2-编译安装-riscv64-unknown-elf-gdb"><a href="#方案2-编译安装-riscv64-unknown-elf-gdb" class="headerlink" title="方案2: 编译安装 riscv64-unknown-elf-gdb"></a>方案2: 编译安装 <code>riscv64-unknown-elf-gdb</code></h3><ol><li>安装依赖<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libncurses5-dev python2 python2-dev texinfo libreadline-dev</span><br></pre></td></tr></table></figure></li><li>下载<code>gdb</code>源码<br>此处我选择gdb-13.1, 该版本在<code>wsl2 Ubuntu22.04</code>上使用正常。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 推荐清华源下载</span></span><br><span class="line">$ wget https://mirrors.tuna.tsinghua.edu.cn/gnu/gdb/gdb-13.1.tar.xz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">$ tar -xvf gdb-13.1.tar.x</span><br></pre></td></tr></table></figure></li><li>编译安装<br>只需要指定编译安装<code>riscv64-unknown-elf</code>并配置相关参数。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> gdb-13.1</span><br><span class="line">$ <span class="built_in">mkdir</span> build &amp;&amp; <span class="built_in">cd</span> build</span><br><span class="line">$ ../configure --prefix=/your_path --target=riscv64-unknown-elf --enable-tui=<span class="built_in">yes</span></span><br><span class="line">$ make -j$(<span class="built_in">nproc</span>)</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure></li></ol><h1 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h1><h2 id="4-1-克隆仓库"><a href="#4-1-克隆仓库" class="headerlink" title="4.1 克隆仓库"></a>4.1 克隆仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2020</span><br><span class="line">$ <span class="built_in">cd</span> xv6-labs-2020</span><br><span class="line">$ git checkout util</span><br></pre></td></tr></table></figure><h2 id="4-2-第一次运行前设置gdbinit"><a href="#4-2-第一次运行前设置gdbinit" class="headerlink" title="4.2 第一次运行前设置gdbinit"></a>4.2 第一次运行前设置<code>gdbinit</code></h2><p>&#x2F;.gdbinit 是 GNU 调试器（GDB）的一个配置文件，它位于用户的主目录中。当 GDB 启动时，它会自动读取这个文件（如果存在的话），并执行文件中的命令。这允许用户自定义 GDB 的启动行为，包括设置断点、定义宏、修改显示格式等。</p><p>在 ~&#x2F;.gdbinit 文件中，用户可以编写 GDB 命令脚本，这些脚本在每次启动 GDB 时自动执行。这可以极大地提高调试效率，尤其是对于那些需要频繁调试并希望每次调试会话都有一组固定设置的用户来说。</p><p>按照指导, 我们如下进行设置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="built_in">set</span> auto-load safe-path / &gt;&gt; ~/.gdbinit</span></span><br></pre></td></tr></table></figure><h2 id="4-3-启动qemu调试"><a href="#4-3-启动qemu调试" class="headerlink" title="4.3 启动qemu调试"></a>4.3 启动qemu调试</h2><p>在一个终端的xv6仓库下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu-gdb</span><br></pre></td></tr></table></figure><p>在另一个终端的xv6仓库下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ riscv64-unknown-elf-gdb</span><br></pre></td></tr></table></figure><p>结果如图所示<br><img src="/../../images/gdb-qemu.png" alt="gdb-qemu"></p><p>进行断点调试, 例如指定函数<code>uvmalloc</code>断点:<br><img src="/../../images/gdb-uvmalloc.png" alt="gdb-uvmalloc"></p><p>可以看出, 运行<code>ls</code>程序后, 程序停留在了<code>uvmalloc</code>函数的入口处, 证明了gdb调试功能正常。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-课程简介&quot;&gt;&lt;a href=&quot;#1-课程简介&quot; class=&quot;headerlink&quot; title=&quot;1 课程简介&quot;&gt;&lt;/a&gt;1 课程简介&lt;/h1&gt;&lt;p&gt;MIT6.S081 Operating System Engineering 是麻省理工学院的 &lt;code&gt;</summary>
      
    
    
    
    <category term="CS课程笔记" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="MIT6.S081" scheme="http://example.com/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-S081/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="C" scheme="http://example.com/tags/C/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
  </entry>
  
  <entry>
    <title>2023开源操作系统训练营三阶段 proj2 练习3</title>
    <link href="http://example.com/2023/12/15/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%B8%89/%E9%98%B6%E6%AE%B53-proj2%E7%BB%83%E4%B9%A03/"/>
    <id>http://example.com/2023/12/15/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%B8%89/%E9%98%B6%E6%AE%B53-proj2%E7%BB%83%E4%B9%A03/</id>
    <published>2023-12-15T12:42:15.000Z</published>
    <updated>2023-12-23T18:05:10.875Z</updated>
    
    <content type="html"><![CDATA[<p><strong>练习实验书</strong>: <a href="https://scpointer.github.io/rcore2oscomp/docs/lab3/intro.html">https://scpointer.github.io/rcore2oscomp/docs/lab3/intro.html</a></p><h1 id="1-编程作业"><a href="#1-编程作业" class="headerlink" title="1 编程作业"></a>1 编程作业</h1><h2 id="1-1-实验3-1"><a href="#1-1-实验3-1" class="headerlink" title="1.1 实验3.1"></a>1.1 实验3.1</h2><blockquote><p>修改代码，使得 busybox ls bin&#x2F;abc 正常输出 bin&#x2F;abc。</p></blockquote><h3 id="1-1-1-对拍结果"><a href="#1-1-1-对拍结果" class="headerlink" title="1.1.1 对拍结果"></a>1.1.1 对拍结果</h3><ul><li>在<code>syscall</code>中使用<code>error!</code>输出日志后运行结果如下:  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">==================================================== busybox <span class="built_in">touch</span> abc ====================================================</span><br><span class="line"></span><br><span class="line">[ 60.140455 0:6 syscall_entry::syscall:38] [syscall] <span class="built_in">id</span> = SET_TID_ADDRESS, args = [1457172, 248, 0, 18446744073708088664, 1, 1], entry</span><br><span class="line">[ 60.172291 0:6 syscall_entry::syscall:47] [syscall] <span class="built_in">id</span> = 96, args = [1457172, 248, 0, 18446744073708088664, 1, 1], <span class="built_in">return</span> 6</span><br><span class="line">[ 60.195900 0:6 syscall_entry::syscall:38] [syscall] <span class="built_in">id</span> = GETUID, args = [1073741394, 47, 1073741394, 98, 1073741394, 1073741394], entry</span><br><span class="line">[ 60.221776 0:6 syscall_entry::syscall:47] [syscall] <span class="built_in">id</span> = 174, args = [1073741394, 47, 1073741394, 98, 1073741394, 1073741394], <span class="built_in">return</span> 0</span><br><span class="line">[ 60.239349 0:6 syscall_entry::syscall:29] [syscall] <span class="built_in">id</span> = UTIMENSAT, args = [18446744073709551516, 1073741384, 0, 0, 0, 0], entry</span><br><span class="line">[ 62.010726 0:6 syscall_entry::syscall:47] [syscall] <span class="built_in">id</span> = 88, args = [18446744073709551516, 1073741384, 0, 0, 0, 0], <span class="built_in">return</span> 0</span><br><span class="line">[ 62.028929 0:6 syscall_entry::syscall:38] [syscall] <span class="built_in">id</span> = EXIT_GROUP, args = [0, 0, 0, 0, 0, 0], entry</span><br><span class="line"></span><br><span class="line">==================================================== busybox <span class="built_in">mv</span> abc bin/ ====================================================</span><br><span class="line"></span><br><span class="line">[ 80.708070 0:6 syscall_entry::syscall:38] [syscall] <span class="built_in">id</span> = SET_TID_ADDRESS, args = [1457172, 248, 0, 18446744073708088664, 1, 1], entry</span><br><span class="line">[ 80.723000 0:6 syscall_entry::syscall:47] [syscall] <span class="built_in">id</span> = 96, args = [1457172, 248, 0, 18446744073708088664, 1, 1], <span class="built_in">return</span> 6</span><br><span class="line">[ 80.743645 0:6 syscall_entry::syscall:38] [syscall] <span class="built_in">id</span> = GETUID, args = [1073741394, 47, 1073741394, 98, 1073741394, 1073741394], entry</span><br><span class="line">[ 80.754384 0:6 syscall_entry::syscall:47] [syscall] <span class="built_in">id</span> = 174, args = [1073741394, 47, 1073741394, 98, 1073741394, 1073741394], <span class="built_in">return</span> 0</span><br><span class="line">[ 80.775450 0:6 syscall_entry::syscall:29] [syscall] <span class="built_in">id</span> = FSTATAT, args = [18446744073709551516, 1073741382, 1073740160, 0, 1073741382, 18446744073709551516], entry</span><br><span class="line">[ 80.806092 0:6 fatfs::<span class="built_in">dir</span>:140] Is a directory</span><br><span class="line">[ 80.834425 0:6 syscall_entry::syscall:47] [syscall] <span class="built_in">id</span> = 79, args = [18446744073709551516, 1073741382, 1073740160, 0, 1073741382, 18446744073709551516], <span class="built_in">return</span> 0</span><br><span class="line">[ 80.856809 0:6 syscall_entry::syscall:21] [syscall] <span class="built_in">id</span> = BRK, args = [0, 64, 1458528, 0, 1457024, 4096], entry</span><br><span class="line">[ 80.865595 0:6 syscall_entry::syscall:47] [syscall] <span class="built_in">id</span> = 214, args = [0, 64, 1458528, 0, 1457024, 4096], <span class="built_in">return</span> 1067450368</span><br><span class="line">[ 80.876861 0:6 syscall_entry::syscall:21] [syscall] <span class="built_in">id</span> = MMAP, args = [0, 4096, 3, 34, 18446744073709551615, 0], entry</span><br><span class="line">[ 80.893941 0:6 syscall_entry::syscall:47] [syscall] <span class="built_in">id</span> = 222, args = [0, 4096, 3, 34, 18446744073709551615, 0], <span class="built_in">return</span> 4096</span><br><span class="line">[ 80.917225 0:6 syscall_entry::syscall:29] [syscall] <span class="built_in">id</span> = FSTATAT, args = [18446744073709551516, 4128, 1073740160, 0, 4128, 18446744073709551516], entry</span><br><span class="line">[ 81.021491 0:6 syscall_entry::syscall:47] [syscall] <span class="built_in">id</span> = 79, args = [18446744073709551516, 4128, 1073740160, 0, 4128, 18446744073709551516], <span class="built_in">return</span> -64</span><br><span class="line">[ 81.042344 0:6 syscall_entry::syscall:29] [syscall] <span class="built_in">id</span> = WRITE, args = [2, 1073740112, 47, 0, 0, 0], entry</span><br><span class="line"><span class="built_in">mv</span>: can<span class="string">&#x27;t stat &#x27;</span>bin/abc<span class="string">&#x27;: No error information</span></span><br><span class="line"><span class="string">[ 81.059920 0:6 syscall_entry::syscall:47] [syscall] id = 64, args = [2, 1073740112, 47, 0, 0, 0], return 47</span></span><br><span class="line"><span class="string">[ 81.072551 0:6 syscall_entry::syscall:38] [syscall] id = EXIT_GROUP, args = [1, 0, 0, 1459576, 0, 1], entry</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">==================================================== busybox ls bin/abc ====================================================</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[ 99.668975 0:6 syscall_entry::syscall:38] [syscall] id = SET_TID_ADDRESS, args = [1457172, 248, 0, 18446744073708088664, 1, 1], entry</span></span><br><span class="line"><span class="string">[ 99.684396 0:6 syscall_entry::syscall:47] [syscall] id = 96, args = [1457172, 248, 0, 18446744073708088664, 1, 1], return 6</span></span><br><span class="line"><span class="string">[ 99.703854 0:6 syscall_entry::syscall:38] [syscall] id = GETUID, args = [1073741394, 47, 1073741394, 98, 1073741394, 1073741394], entry</span></span><br><span class="line"><span class="string">[ 99.720334 0:6 syscall_entry::syscall:47] [syscall] id = 174, args = [1073741394, 47, 1073741394, 98, 1073741394, 1073741394], return 0</span></span><br><span class="line"><span class="string">[ 99.743118 0:6 syscall_entry::syscall:38] [syscall] id = CLOCK_GET_TIME, args = [0, 1073740640, 24, 24, 1457480, 0], entry</span></span><br><span class="line"><span class="string">[ 99.756191 0:6 syscall_entry::syscall:47] [syscall] id = 113, args = [0, 1073740640, 24, 24, 1457480, 0], return 0</span></span><br><span class="line"><span class="string">[ 99.773509 0:6 syscall_entry::syscall:29] [syscall] id = IOCTL, args = [0, 21523, 1073740584, 18446744073709551578, 1457480, 1073740528], entry</span></span><br><span class="line"><span class="string">[ 99.792659 0:6 syscall_entry::syscall:47] [syscall] id = 29, args = [0, 21523, 1073740584, 18446744073709551578, 1457480, 1073740528], return 0</span></span><br><span class="line"><span class="string">[ 99.815217 0:6 syscall_entry::syscall:29] [syscall] id = IOCTL, args = [1, 21523, 1073740648, 2, 0, 1332386], entry</span></span><br><span class="line"><span class="string">[ 99.824071 0:6 syscall_entry::syscall:47] [syscall] id = 29, args = [1, 21523, 1073740648, 2, 0, 1332386], return 0</span></span><br><span class="line"><span class="string">[ 99.836051 0:6 syscall_entry::syscall:29] [syscall] id = IOCTL, args = [1, 21523, 1073740648, 68, 2, 0], entry</span></span><br><span class="line"><span class="string">[ 99.849454 0:6 syscall_entry::syscall:47] [syscall] id = 29, args = [1, 21523, 1073740648, 68, 2, 0], return 0</span></span><br><span class="line"><span class="string">[ 99.863974 0:6 syscall_entry::syscall:21] [syscall] id = BRK, args = [0, 160, 1458528, 0, 1457024, 4096], entry</span></span><br><span class="line"><span class="string">[ 99.879705 0:6 syscall_entry::syscall:47] [syscall] id = 214, args = [0, 160, 1458528, 0, 1457024, 4096], return 1067450368</span></span><br><span class="line"><span class="string">[ 99.895548 0:6 syscall_entry::syscall:21] [syscall] id = MMAP, args = [0, 4096, 3, 34, 18446744073709551615, 0], entry</span></span><br><span class="line"><span class="string">[ 99.903246 0:6 syscall_entry::syscall:47] [syscall] id = 222, args = [0, 4096, 3, 34, 18446744073709551615, 0], return 4096</span></span><br><span class="line"><span class="string">[ 99.919318 0:6 syscall_entry::syscall:29] [syscall] id = FSTATAT, args = [18446744073709551516, 1073741383, 1073740256, 0, 1073741383, 18446744073709551516], entry</span></span><br><span class="line"><span class="string">[100.011304 0:6 syscall_entry::syscall:47] [syscall] id = 79, args = [18446744073709551516, 1073741383, 1073740256, 0, 1073741383, 18446744073709551516], return -64</span></span><br><span class="line"><span class="string">[100.042643 0:6 syscall_entry::syscall:29] [syscall] id = WRITE, args = [2, 1073740208, 34, 0, 0, 0], entry</span></span><br><span class="line"><span class="string">ls: bin/abc: No error information</span></span><br><span class="line"><span class="string">[100.070083 0:6 syscall_entry::syscall:47] [syscall] id = 64, args = [2, 1073740208, 34, 0, 0, 0], return 34</span></span><br><span class="line"><span class="string">[100.090969 0:6 syscall_entry::syscall:38] [syscall] id = EXIT_GROUP, args = [1, 0, 0, 1459576, 0, 1], entry</span></span><br></pre></td></tr></table></figure></li><li>在<code>Linux</code>系统中在相同的位置执行相同的命令, <code>strace</code>输出如下(这里只给出<code>mv abc bin/</code>的结果):  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">ioctl(0, TCGETS, &#123;B38400 opost isig icanon <span class="built_in">echo</span> ...&#125;) = 0</span><br><span class="line"><span class="built_in">stat</span>(<span class="string">&quot;bin/&quot;</span>, &#123;st_mode=S_IFDIR|0755, st_size=4096, ...&#125;) = 0</span><br><span class="line">lstat(<span class="string">&quot;abc&quot;</span>, &#123;st_mode=S_IFREG|0644, st_size=0, ...&#125;) = 0</span><br><span class="line">lstat(<span class="string">&quot;bin/abc&quot;</span>, 0x7fffbdb041a0)        = -1 ENOENT (No such file or directory)</span><br><span class="line">rename(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;bin/abc&quot;</span>)                = 0</span><br><span class="line">lseek(0, 0, SEEK_CUR)                   = -1 ESPIPE (Illegal seek)</span><br><span class="line">close(0)                                = 0</span><br><span class="line">close(1)                                = 0</span><br><span class="line">close(2)                                = 0</span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-1-2-定位并修改错误—未完成rename系统调用"><a href="#1-1-2-定位并修改错误—未完成rename系统调用" class="headerlink" title="1.1.2 定位并修改错误—未完成rename系统调用"></a>1.1.2 定位并修改错误—未完成<code>rename</code>系统调用</h3><p><code>strace</code>输出的内容很多, 这里我们只需要关注<code>rename</code>系统调用前后的内容即可, 其区别总结如下:</p><ol><li><code>strace</code>输出内容包括<code>rename</code>系统调用, 而我们的<code>Starry</code>没有输出响应的系统调用<br> 这意味着执行<code>rename</code>系统调用前发生了错误, 因此关注前一个系统调用<code>lstat</code></li><li><code>FSTATAT</code>返回类型不匹配<br>分析可知, <code>lstat</code>和<code>FSTATAT</code>应该是<code>rename</code>系统调用的前置, <code>strace</code>中其返回值为<code>-1 ENOENT</code>, 而在<code>Starry</code>中返回值为<code>-64</code><br>查阅<code>ulib/axstarry/syscall_utils/src/lib.rs</code>和<code>target/debug/build/axerrno-011bdf3cce8cadef/out/linux_errno.rs</code>可知, <code>-64</code>返回的是: <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target/debug/build/axerrno-011bdf3cce8cadef/out/linux_errno.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Machine is not on the network</span></span><br><span class="line">ENONET = <span class="number">64</span>,</span><br></pre></td></tr></table></figure><code>ENOENT</code>在同目录下, 同样存在: <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// target/debug/build/axerrno-011bdf3cce8cadef/out/linux_errno.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// No such file or directory</span></span><br><span class="line">ENOENT = <span class="number">2</span>,</span><br></pre></td></tr></table></figure>分析我们执行的指令可知, <code>FSTATAT</code>对应的系统调用<code>syscall_fstatat</code>作用是查看目标路径下的文件信息, 在执行该命令前, 其应当是不存在的, 故其应返回<code>ENOENT</code>而不是<code>ENONET</code></li><li>观察<code>syscall_fstatat</code><br>查看<code>syscall_fstatat</code>代码可知, 其对解析出的路径调用<code>get_stat_in_fs</code>完成信息获取</li><li>修改<code>get_stat_in_fs</code><br>由于我们知道其错误返回了<code>ENONET</code>, 故搜索该字段即可迅速定位并完成修改 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是文件</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Ok</span>(file) = <span class="title function_ invoke__">new_fd</span>(real_path.<span class="title function_ invoke__">to_string</span>(), <span class="number">0</span>.<span class="title function_ invoke__">into</span>()) &#123;</span><br><span class="line">    <span class="keyword">match</span> file.<span class="title function_ invoke__">get_stat</span>() &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(stat) =&gt; <span class="title function_ invoke__">Ok</span>(stat),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">            debug!(<span class="string">&quot;get stat error: &#123;:?&#125;&quot;</span>, e);</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(SyscallError::EINVAL)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(SyscallError::ENOENT) <span class="comment">// 修改为ENOENT</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-1-3-定位并修改错误—完成缺失的rename系统调用"><a href="#1-1-3-定位并修改错误—完成缺失的rename系统调用" class="headerlink" title="1.1.3 定位并修改错误—完成缺失的rename系统调用"></a>1.1.3 定位并修改错误—完成缺失的<code>rename</code>系统调用</h3><p>根据提示完成<code>syscall_renameat2</code>系统调用:</p><ul><li>实现<code>flags</code>结构体<br>在<a href="https://man7.org/linux/man-pages/man2/renameat2.2.html">此处</a>找到对应的276号系统调用说明<br>可知, <code>flags</code>包含了:<code>RENAME_EXCHANGE</code>, <code>RENAME_NOREPLACE</code>和<code>RENAME_WHITEOUT</code>, 故实现如下:  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> bitflags::bitflags;</span><br><span class="line"><span class="built_in">bitflags!</span> &#123;</span><br><span class="line"><span class="comment">/// sys_renameat2 用到的标志位</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">RenameFlags</span>: <span class="type">u32</span> &#123;</span><br><span class="line"><span class="keyword">const</span> NONE = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// LAB3 其他可能的选项都有什么？</span></span><br><span class="line"><span class="comment">// 参考: https://man7.org/linux/man-pages/man2/renameat2.2.html</span></span><br><span class="line"><span class="keyword">const</span> RENAME_EXCHANGE = <span class="number">1</span>; <span class="comment">// 原子交换旧路径和新路径。两个路径名必须存在</span></span><br><span class="line"><span class="keyword">const</span> RENAME_NOREPLACE = <span class="number">2</span>; <span class="comment">// 如果newpath已经存在, 不要覆盖重命名的新路径。</span></span><br><span class="line"><span class="keyword">const</span> RENAME_WHITEOUT  = <span class="number">4</span>; <span class="comment">// 仅适用于覆盖/并集文件系统实现</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>实现<code>syscall_renameat2</code><br>此处我没有实现<code>RENAME_EXCHANGE</code>和<code>RENAME_WHITEOUT</code>, 只对<code>RENAME_NOREPLACE</code>进行了实现, 其核心就是调用底层的<code>axfs::api::rename</code>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 276</span></span><br><span class="line"><span class="comment">/// 重命名文件或目录</span></span><br><span class="line"><span class="comment">// LAB3 你需要完成这个 syscall</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">syscall_renameat2</span>(</span><br><span class="line">old_dirfd: <span class="type">usize</span>,</span><br><span class="line">old_path: *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">new_dirfd: <span class="type">usize</span>,</span><br><span class="line">new_path: *<span class="keyword">const</span> <span class="type">u8</span>,</span><br><span class="line">flags: <span class="type">usize</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> SyscallResult &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">old_path</span> = <span class="title function_ invoke__">deal_with_path</span>(old_dirfd, <span class="title function_ invoke__">Some</span>(old_path), <span class="literal">false</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">new_path</span> = <span class="title function_ invoke__">deal_with_path</span>(new_dirfd, <span class="title function_ invoke__">Some</span>(new_path), <span class="literal">false</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">proc_path</span> = FilePath::<span class="title function_ invoke__">new</span>(<span class="string">&quot;/proc&quot;</span>).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line"><span class="keyword">if</span> old_path.<span class="title function_ invoke__">start_with</span>(&amp;proc_path) || new_path.<span class="title function_ invoke__">start_with</span>(&amp;proc_path) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(SyscallError::EPERM);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">new_path_str</span> = new_path.<span class="title function_ invoke__">path</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">replace</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(flag) = RenameFlags::<span class="title function_ invoke__">from_bits</span>(flags.<span class="title function_ invoke__">try_into</span>().<span class="title function_ invoke__">unwrap</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> flag.<span class="title function_ invoke__">contains</span>(RenameFlags::RENAME_EXCHANGE) &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;not supported!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> flag.<span class="title function_ invoke__">contains</span>(RenameFlags::RENAME_NOREPLACE) &#123;</span><br><span class="line">        replace = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> flag.<span class="title function_ invoke__">contains</span>(RenameFlags::RENAME_WHITEOUT) &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;not supported!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !<span class="title function_ invoke__">path_exists</span>(old_path_str) &#123;</span><br><span class="line">    error!(<span class="string">&quot;old path not exists:&#123;&#125;&quot;</span>, old_path_str);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(SyscallError::ENOENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !replace &amp;&amp; <span class="title function_ invoke__">path_exists</span>(new_path_str) &#123;</span><br><span class="line">    error!(<span class="string">&quot;new path exists:&#123;&#125;&quot;</span>, new_path_str);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(SyscallError::EEXIST);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error!(&quot;old path = &#123;&#125;&quot;, old_path_str);</span></span><br><span class="line"><span class="comment">// error!(&quot;new path = &#123;&#125;&quot;, new_path_str);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">res</span> = axfs::api::<span class="title function_ invoke__">rename</span>(old_path_str, new_path_str);</span><br><span class="line"></span><br><span class="line"><span class="keyword">match</span> res &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(()) =&gt; <span class="title function_ invoke__">Ok</span>(<span class="number">0</span>),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e.<span class="title function_ invoke__">into</span>()),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// return Err(SyscallError::EPERM);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-1-4-输出结果"><a href="#1-1-4-输出结果" class="headerlink" title="1.1.4 输出结果"></a>1.1.4 输出结果</h3><p>输出结果如下:<br>    <img src="/../../../images/lab3_1.png" alt="img"></p><h2 id="1-2-实验3-2"><a href="#1-2-实验3-2" class="headerlink" title="1.2 实验3.2"></a>1.2 实验3.2</h2><blockquote><p>修改代码，使得 busybox mv def bin 正常输出 bin&#x2F;def。</p></blockquote><h3 id="1-2-1-对拍结果"><a href="#1-2-1-对拍结果" class="headerlink" title="1.2.1 对拍结果"></a>1.2.1 对拍结果</h3><p>根据题目分析可知, 此处的错误原因在于内核将<code>bin</code>看成了一个文件, 而不是一个目录<br>因此, 此处对拍可以不用跟<code>strace</code>对比, 其实际输出太过复杂, 可以和我们之前的<code>实验3.1</code>进行对拍</p><blockquote><p>PS:此处借助VScode的比较工具对2次的输出进行比对</p></blockquote><p><img src="/../../../images/3-1%E5%AF%B9%E6%8B%8D3-2.png" alt="实验3.1对拍实验3.2"></p><p>通过<code>VSCode</code>的对比我们可以更快地定位对拍的不同:</p><ul><li>在调用<code>syscall_renameat2</code>之前, 左侧的<code>实验3.1</code>不存在系统调用<code>FACCESSAT</code>, 而右侧的<code>实验3.2</code>则存在</li><li>在调用<code>syscall_renameat2</code>之前的系统调用<code>FSTATAT</code>返回值不同:左侧的<code>实验3.1</code>返回值为<code>-2</code>, 而右侧的<code>实验3.2</code>返回<code>0</code></li></ul><h3 id="1-2-2-对拍分析"><a href="#1-2-2-对拍分析" class="headerlink" title="1.2.2 对拍分析"></a>1.2.2 对拍分析</h3><ol><li><p>对拍分析–<code>FACCESSAT</code><br>查阅<code>syscall_faccessat</code>的注释可知, 该函数用于<code>获取文件权限</code>与判别目录还是文件无关, 可暂时跳过</p></li><li><p>对拍分析–<code>FSTATAT</code><br> 再次回到熟悉的函数<code>syscall_fstatat</code>, 发现其对路径字符串的解析在<code>get_stat_in_fs</code>中<br> 分析<code>get_stat_in_fs</code>, 发现其判断路径为文件夹或文件的依据是:</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !real_path.<span class="title function_ invoke__">ends_with</span>(<span class="string">&quot;/&quot;</span>) &amp;&amp; !real_path.<span class="title function_ invoke__">ends_with</span>(<span class="string">&quot;include&quot;</span>)</span><br></pre></td></tr></table></figure><p> 大致可以判断出错误原因了, 因为其判断路径是文件夹或者文件的依据是其是否以<code>/</code>结尾, 参考<code>syscall_renameat2</code>中的提示, 使用<code>metadata</code>来判断其是否为文件:</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">is_file</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">meta_data</span> = <span class="title function_ invoke__">metadata</span>(real_path);</span><br><span class="line"><span class="keyword">if</span> meta_data.<span class="title function_ invoke__">is_ok</span>() &#123;</span><br><span class="line">    is_file = meta_data.<span class="title function_ invoke__">unwrap</span>().<span class="title function_ invoke__">is_file</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(SyscallError::ENOENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_file &#123;</span><br><span class="line">    <span class="comment">// 是文件</span></span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 是目录</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-2-3-输出结果"><a href="#1-2-3-输出结果" class="headerlink" title="1.2.3 输出结果"></a>1.2.3 输出结果</h3><p>输出结果如下:<br>    <img src="/../../../images/lab3_2.png" alt="img"></p><h1 id="2-问答作业"><a href="#2-问答作业" class="headerlink" title="2 问答作业"></a>2 问答作业</h1><h2 id="2-1-思考题1"><a href="#2-1-思考题1" class="headerlink" title="2.1 思考题1"></a>2.1 思考题1</h2><ul><li>思考题1.1<blockquote><p>思考题1.1：这些代码具体在 ~&#x2F;.cargo 下的哪个文件夹？</p></blockquote></li></ul><p>我的<code>log</code>库的路径为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.cargo/registry/src/mirrors.tuna.tsinghua.edu.cn-df7c3c540f42cdbd/log-0.4.19/src/lib.rs</span><br></pre></td></tr></table></figure><p>其中<code>src</code>的下一级目录为设置的镜像代理</p><ul><li>思考题1.2<blockquote><p>思考题1.2：如果忘记 make clean 会发生什么？</p></blockquote></li></ul><p>阅读Makefile:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean: clean_c</span></span><br><span class="line">rm -rf <span class="variable">$(APP)</span>/*.bin <span class="variable">$(APP)</span>/*.elf</span><br><span class="line">cargo clean</span><br></pre></td></tr></table></figure><p>可知, <code>make clean</code>进行了<code>cargo clean</code>, 如果直接<code>make run</code>会导致依赖库不会重新下载</p><h2 id="2-3-思考题2"><a href="#2-3-思考题2" class="headerlink" title="2.3 思考题2"></a>2.3 思考题2</h2><blockquote><p>思考题2：在部分往届内核及运行指引 一节提到的内核中挑选一个，描述它在默认情况下启动后会执行哪些测例（抑或是直接启动终端）。你不一定要真的运行那个内核，读文档或搜索即可。</p></blockquote><p>选择内核为<a href="https://github.com/oscomp/2021oscomp-best-kernel-design-impl/tree/2021-xv6">xv6</a>(<del>嘿嘿, 其实是对xv6比较熟悉, 偷个懒</del>)<br><code>xv6</code>运行测例位于<code>xv6-user</code>文件夹下, 并需要再在<code>Makefile</code>中尽显指定:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_init\</span><br><span class="line">$U/_sh\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">$U/_grep\</span><br><span class="line">$U/_ls\</span><br><span class="line">$U/_kill\</span><br><span class="line">$U/_mkdir\</span><br><span class="line">$U/_xargs\</span><br><span class="line">$U/_sleep\</span><br><span class="line">$U/_find\</span><br><span class="line">$U/_rm\</span><br><span class="line">$U/_rmdir\</span><br><span class="line">$U/_wc\</span><br><span class="line">$U/_info\</span><br><span class="line">$U/_usertests\</span><br><span class="line">$U/_strace\</span><br><span class="line">$U/_mv\</span><br><span class="line">$U/_test\</span><br><span class="line">$U/_grind\</span><br><span class="line">$U/_forktest\</span><br><span class="line">$U/_stressfs\</span><br><span class="line">$U/_cowtest\</span><br><span class="line">$U/_lazytests\</span><br><span class="line">$U/_mount\</span><br><span class="line">$U/_umount\</span><br><span class="line">$U/_dup3\</span><br><span class="line">$U/_mmaptests\</span><br><span class="line">$U/_sync\</span><br><span class="line">$U/_signal_test</span><br></pre></td></tr></table></figure><p><code>Makefile</code>以上文件对应于<code>xv6-user</code>文件夹下去掉下划线并以<code>.c</code>结尾的源文件, 如<code>init.c</code>, <code>test.c</code>等</p><h2 id="2-3-思考题3"><a href="#2-3-思考题3" class="headerlink" title="2.3 思考题3"></a>2.3 思考题3</h2><ul><li>思考题3.1<blockquote><p>思考题3.1：为什么要在开头结尾各输出一句，会不会太过重复？（提示：考虑执行出错的情况，或者 sys_exit ）</p></blockquote></li></ul><p>一方面, <code>sys_exit</code>输出一次后就终止了, 另一方面, 收尾各自输出依据可以判断是否出现了<code>panic</code>(<del>不确定是不是这个意思</del>)</p><ul><li>思考题3.2<blockquote><p>思考题3.2：为什么要结尾还要输出一遍 syscall 的完整参数，只输出返回值行不行？（提示：考虑像 sys_yield 这样的 syscall）</p></blockquote></li></ul><p><code>sys_yield</code>这类系统调用让出了CPU, 因此通过打印参数, 可以观测让出CPU期间, 其寄存器有没有被修改, 或是将系统让出CPU的时间进行记录(<del>不确定是不是这个意思</del>)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;练习实验书&lt;/strong&gt;: &lt;a href=&quot;https://scpointer.github.io/rcore2oscomp/docs/lab3/intro.html&quot;&gt;https://scpointer.github.io/rcore2oscomp/</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>2023开源操作系统训练营三阶段 proj2 练习2</title>
    <link href="http://example.com/2023/12/14/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%B8%89/%E9%98%B6%E6%AE%B53-proj2%E7%BB%83%E4%B9%A02/"/>
    <id>http://example.com/2023/12/14/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%B8%89/%E9%98%B6%E6%AE%B53-proj2%E7%BB%83%E4%B9%A02/</id>
    <published>2023-12-14T15:34:29.000Z</published>
    <updated>2023-12-23T18:05:03.197Z</updated>
    
    <content type="html"><![CDATA[<p><strong>练习实验书</strong>: <a href="https://scpointer.github.io/rcore2oscomp/docs/lab2/intro.html">https://scpointer.github.io/rcore2oscomp/docs/lab2/intro.html</a></p><h1 id="1-编程作业"><a href="#1-编程作业" class="headerlink" title="1.编程作业"></a>1.编程作业</h1><h2 id="1-1-跟随文档修改内核"><a href="#1-1-跟随文档修改内核" class="headerlink" title="1.1 跟随文档修改内核"></a>1.1 跟随文档修改内核</h2><p>跟随文档编写代码即可, 其实给出的<code>bootloader</code>已经是被修改成适配<code>rCore</code>的版本了, 不需要进行自己的修改, 此处简单说明文档中没有直接给出的代码修改部分:</p><ul><li>思路<blockquote><p><code>bootloader</code>其实就是我们<code>lab1</code>中修改栈布局的完善版本, 只需要将我们在<code>lab1</code>中自己修改的代码换成对<code>bootloader</code>的函数调用即可</p></blockquote></li><li>具体步骤</li></ul><ol><li>调用<code>ElfLoader::new</code>和<code>init_stack</code>完成栈的内存初始化</li><li>将返回的栈底值填充<code>trap_cx</code>, 注意<code>app_init_context</code>也需要填充</li></ol><h2 id="1-2-添加系统调用使hellostd-正常运行"><a href="#1-2-添加系统调用使hellostd-正常运行" class="headerlink" title="1.2 添加系统调用使hellostd 正常运行"></a>1.2 添加系统调用使<code>hellostd </code>正常运行</h2><h3 id="1-2-1-完成ioctl"><a href="#1-2-1-完成ioctl" class="headerlink" title="1.2.1 完成ioctl"></a>1.2.1 完成ioctl</h3><p>通过文档修改后首先输出的是:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unsupported syscall_id: 29</span><br></pre></td></tr></table></figure><p>查阅<a href="https://jborza.com/post/2021-05-11-riscv-linux-syscalls/">此处</a>可知缺少系统调用<code>ioctl</code>的实现</p><ol><li><code>ioctl</code>是什么?<blockquote><p>ioctl（Input&#x2F;Output Control）是一个在Unix和Unix-like系统上的系统调用，用于控制设备的底层参数。它允许用户程序通过文件描述符对设备进行各种控制操作</p></blockquote></li><li>原型和使用方式</li></ol><ul><li>原型  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fd: 打开的文件描述符，指向需要进行控制的设备。</span></span><br><span class="line"><span class="comment">request: 一个表示控制请求的无符号长整型。这个参数指定了具体的操作，如设置参数、获取状态等。</span></span><br><span class="line"><span class="comment">...: 零个或多个可选的参数，取决于具体的控制请求。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><code>Linux</code>下使用案例:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">ws</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取终端窗口大小</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">ws</span>;</span></span><br><span class="line"><span class="keyword">if</span> (ioctl(STDOUT_FILENO, TIOCGWINSZ, &amp;ws) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;ioctl(TIOCGWINSZ) error&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>实现方式<br>可以看出, <code>rCore</code>并不支持以上类似的功能, 一次该系统调用只需要返回 <code>0</code> 即可</li></ol><h3 id="1-2-2-完成writev"><a href="#1-2-2-完成writev" class="headerlink" title="1.2.2 完成writev"></a>1.2.2 完成writev</h3><p>上一步完成后, 运行输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unsupported syscall_id: 66</span><br></pre></td></tr></table></figure><p>查阅<a href="https://jborza.com/post/2021-05-11-riscv-linux-syscalls/">此处</a>可知缺少系统调用<code>writev</code>的实现</p><ol><li><p><code>writev</code>是什么?<br>如果熟悉<code>Linux</code>系统编程的话对这个系统调用很熟悉, 其被<code>writev</code>函数调用, 起作用就是将多个不连续的缓冲区打包一次进行写入, <code>readv</code>的思路也是一样的。其意义在于减少系统调用的开销。</p></li><li><p>原型和使用方式</p></li></ol><ul><li>原型  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line"><span class="type">void</span>  *iov_base; <span class="comment">// 缓冲区的起始地址</span></span><br><span class="line"><span class="type">size_t</span> iov_len;  <span class="comment">// 缓冲区的长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><code>Linux</code>下使用案例  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两个缓冲区</span></span><br><span class="line"><span class="type">char</span> buffer1[] = <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line"><span class="type">char</span> buffer2[] = <span class="string">&quot;writev!\n&quot;</span>;</span><br><span class="line"><span class="comment">// 定义iovec结构数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[2];</span></span><br><span class="line">iov[<span class="number">0</span>].iov_base = buffer1;</span><br><span class="line">iov[<span class="number">0</span>].iov_len = <span class="built_in">strlen</span>(buffer1);</span><br><span class="line">iov[<span class="number">1</span>].iov_base = buffer2;</span><br><span class="line">iov[<span class="number">1</span>].iov_len = <span class="built_in">strlen</span>(buffer2);</span><br><span class="line"><span class="comment">// 打开文件描述符</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;output.txt&quot;</span>, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);</span><br><span class="line"><span class="comment">// 使用writev写入数据</span></span><br><span class="line"><span class="type">ssize_t</span> bytes_written = writev(fd, iov, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>实现方式</li></ol><ul><li>思路<br>由于已经实现了<code>sys_write</code>, 而<code>sys_writev</code>就是将多个缓冲区打包在一起.因此只需要连续调用<code>sys_write</code>即可</li><li>具体步骤<ol><li>循环获取每一个<code>iov</code>的地址, 需要通过<code>translated_refmut</code>转化</li><li>每一个<code>iov</code>地址的第一个参数是缓冲区地址, 第二个参数是缓冲区长度, 同样通过<code>translated_refmut</code>转化</li><li>获取到上2个参数后调用<code>sys_write</code></li><li>若<code>sys_write</code>返回-1, 则直接返回, 否则对<code>sys_write</code>进行累加并在循环结束后返回<blockquote><p>PS<br>此处我的视线是直接操作指针, 但如果后续还需实现更多有关<code>iovec</code>的系统调用时, 最后单独定义一个结构体, 并对该结构体实现相应的读写方法</p></blockquote></li></ol></li></ul><h3 id="1-2-3-实现exit-group"><a href="#1-2-3-实现exit-group" class="headerlink" title="1.2.3 实现exit_group"></a>1.2.3 实现exit_group</h3><p>上一步完成后, 运行输出:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Unsupported syscall_id: 94</span><br></pre></td></tr></table></figure><p>查阅<a href="https://jborza.com/post/2021-05-11-riscv-linux-syscalls/">此处</a>可知缺少系统调用<code>exit_group</code>的实现</p><ol><li><code>exit_group</code>是什么?<br>exit_group 是一个系统调用，它会终止所有线程和进程，并返回一个退出状态。它与 exit 的区别在于它会终止整个进程组，而不仅仅是调用线程或进程。</li><li>原型和使用方式</li></ol><ul><li>原型  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit_group</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure></li><li>使用方式  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ... 进程的其他工作 ...</span></span><br><span class="line"></span><br><span class="line">    exit_group(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这段代码不会执行，因为 exit_group 已经终止了整个进程</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>实现方式<br>显而易见, 由于<code>rCore</code>不支持进程组, 因此只需要转移给<code>exit</code>即可</li></ol><h3 id="1-2-4-结果"><a href="#1-2-4-结果" class="headerlink" title="1.2.4 结果"></a>1.2.4 结果</h3><p>完成以上修改后, 运行<code>hellostd</code>, 得到如下结果:<br><br><img src="/../../../images/lab1-result.png" alt="img"><br></p><h1 id="2-问答作业"><a href="#2-问答作业" class="headerlink" title="2 问答作业"></a>2 问答作业</h1><ol><li>查询标志位定义。<blockquote><p>标准的 waitpid 调用的结构是 pid_t waitpid(pid_t pid, int *_Nullable wstatus, int options);。其中的 options 参数分别有哪些可能（只要列出不需要解释），用 int 的 32 个 bit 如何表示？</p></blockquote></li></ol><ul><li><strong><code>options</code>包括</strong>:</li><li><code>WNOHANG</code>：如果没有任何子进程终止或停止，<code>waitpid</code> 立即返回而不阻塞。如果指定了这个选项，且子进程的状态没有发生变化，<code>waitpid</code> 返回 0。</li><li><code>WUNTRACED</code>：等待任何已经停止的子进程返回。停止是指子进程收到了一个暂停信号（通常是 <code>SIGSTOP</code>）而进入了停止状态。</li><li><code>WCONTINUED</code>：等待任何已经继续执行的子进程返回。继续执行是指子进程从停止状态转为运行状态。</li><li><code>WSTOPPED</code>：它是一个被废弃的宏，不应该在新的代码中使用。使用 <code>WIFSTOPPED</code> 替代。</li><li><code>WEXITED</code>：如果子进程正常终止，<code>waitpid</code> 返回。可以与 <code>WIFEXITED</code> 结合使用。</li><li><code>WEXITSTATUS</code>：用于获取正常终止的子进程的退出状态，需与 <code>WIFEXITED</code> 结合使用。</li><li><code>WIFEXITED</code>：如果子进程正常终止，返回一个非零值。可以与 <code>WEXITSTATUS</code> 结合使用。</li><li><code>WIFSIGNALED</code>：如果子进程因为信号而终止，返回一个非零值。</li><li><code>WIFSTOPPED</code>：如果子进程当前处于停止状态，返回一个非零值。可以与 <code>WSTOPSIG</code> 结合使用。</li><li><code>WIFCONTINUED</code>：如果子进程继续运行，返回一个非零值。</li><li><code>WSTOPSIG</code>：用于获取导致子进程停止的信号编号，需与 <code>WIFSTOPPED</code> 结合使用。</li></ul><blockquote><p>用 int 的 32 个 bit 如何表示?</p></blockquote><p>由于其对应的整型只有一个位被设置为1, 因此可以通过按位或（<code>|</code>）操作组合</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;练习实验书&lt;/strong&gt;: &lt;a href=&quot;https://scpointer.github.io/rcore2oscomp/docs/lab2/intro.html&quot;&gt;https://scpointer.github.io/rcore2oscomp/</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>2023开源操作系统训练营三阶段 proj2 练习1</title>
    <link href="http://example.com/2023/12/13/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%B8%89/%E9%98%B6%E6%AE%B53-proj2%E7%BB%83%E4%B9%A01/"/>
    <id>http://example.com/2023/12/13/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%B8%89/%E9%98%B6%E6%AE%B53-proj2%E7%BB%83%E4%B9%A01/</id>
    <published>2023-12-13T04:11:22.000Z</published>
    <updated>2023-12-23T18:04:54.783Z</updated>
    
    <content type="html"><![CDATA[<p><strong>练习实验书</strong>: <a href="https://scpointer.github.io/rcore2oscomp/docs/lab1/intro.html">https://scpointer.github.io/rcore2oscomp/docs/lab1/intro.html</a></p><h1 id="1-编程作业"><a href="#1-编程作业" class="headerlink" title="1.编程作业"></a>1.编程作业</h1><h2 id="1-1-扩展-easy-fs-fuse"><a href="#1-1-扩展-easy-fs-fuse" class="headerlink" title="1.1 扩展 easy-fs-fuse"></a>1.1 扩展 easy-fs-fuse</h2><blockquote><p>跟随前面文档的指引，扩展 easy-fs-fuse，使得它可以生成同时包含 Rust 和 C 用户程序的镜像</p></blockquote><ol><li>修改内核代码<br>此步骤参考任务书</li><li>修改Makefile<br>根据项目文档的说明, 基本上完成了生成同时包含 Rust 和 C 用户程序的镜像的需求, 但<code>Makefile</code>需要进行一定的修改<br>此处我基于<code>ch8</code>的代码进行修改 <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FS_IMG := target/fs.img</span><br><span class="line">...</span><br><span class="line"><span class="section">fs-img: <span class="variable">$(APPS)</span></span></span><br><span class="line">    @make -C ../user build TEST=<span class="variable">$(TEST)</span> CHAPTER=<span class="variable">$(CHAPTER)</span> BASE=<span class="variable">$(BASE)</span></span><br><span class="line">    @make -C ../testcases build</span><br><span class="line">    @rm -f <span class="variable">$(FS_IMG)</span></span><br><span class="line">    @cp ../user/build/elf/* ../testcases/build/</span><br><span class="line">    @cd ../easy-fs-fuse &amp;&amp; cargo run --release -- -s ../testcases/build -o ../os/<span class="variable">$(FS_IMG)</span></span><br></pre></td></tr></table></figure> 主要区别在于, 此次构建<code>fs-img</code>之前需要先编译<code>testcases</code>目录下的c程序, 并将<code>user</code>目录下的<code>elf</code>文件复制到<code>testcases/build/</code>下, 根据<code>testcases/build/</code>生成镜像时需要将任务书中的<code>-t</code>参数替换为<code>-o</code>参数</li><li>结果和测试<br>在<code>os</code>下执行<code>make fs-img CHAPTER=8 BASE=2</code>, 可以生成包含c程序的文件系统镜像。<br>同理，<code>os</code>下执行<code>make run CHAPTER=8 BASE=2</code>后运行<code>42</code>和<code>hello</code>程序:<ul><li><code>42</code>运行结果 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; 42</span><br><span class="line">Shell: Process 2 exited with code 42</span><br></pre></td></tr></table></figure> 可以看出<code>42</code>返回值为42, 这与期望值相符合</li><li><code>hello</code>运行结果 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; hello xwd</span><br><span class="line">Incorrect argc</span><br><span class="line">Shell: Process 2 exited with code 1</span><br><span class="line">&gt;&gt; hello</span><br><span class="line">Incorrect argc</span><br><span class="line">Shell: Process 2 exited with code 1</span><br></pre></td></tr></table></figure> 可以看出, <code>hello</code>程序无论是否添加参数, 都会输出错误信息, 这也是接下来要解决的问题。</li></ul></li></ol><h2 id="1-2-修改os内核支持C程序"><a href="#1-2-修改os内核支持C程序" class="headerlink" title="1.2 修改os内核支持C程序"></a>1.2 修改os内核支持C程序</h2><blockquote><p>在 usershell 里运行了 42 和 hello 两个用户程序。42 的运行结果是符合预期的，但 hello 的结果看起来不太对，你的任务是修改内核，使得 hello 测例给出正常输出（即给出一行以 my name is 开头的输出，且 exit_code为0）。</p></blockquote><ol><li>原因分析<br>阅读原<code>rCore</code><a href="http://learningos.cn/rCore-Tutorial-Guide-2023A/chapter7/2cmdargs-and-redirection.html">文档</a>与本实验<a href="https://scpointer.github.io/rcore2oscomp/docs/lab1/clib.html">文档</a><br>可以看出, 二者的栈分布是不同的, 先看旧的栈内存分布<br><img src="/../../../images/%E6%97%A7%E6%A0%88%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png" alt="img"><br><br>可以看到在此栈的内存分布中, 实际的参数放在接近栈底的位置, 其指向的实际参数在靠近栈顶的位置, 并且通过阅读源码<code>process.rs</code>中的<code>exec</code>: <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trap_cx.x[<span class="number">10</span>] = args.<span class="title function_ invoke__">len</span>();</span><br><span class="line">trap_cx.x[<span class="number">11</span>] = argv_base;</span><br></pre></td></tr></table></figure> 可知参数个数<code>argc</code>时通过手动计算<code>args</code>的长度计算得到的, 并没有存储在栈上。<br> 阅读本实验指导书可知，C程序的栈内存分布如下：<br><img src="/../../../images/%E6%96%B0%E6%A0%88%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83.png" alt="img"><br><br>在此栈的内存分布中, 实际的参数放在接近栈顶的位置, 其指向的实际参数在靠近栈底的位置， 并且栈指针指向了<code>argc</code><br>而且由<code>testcases/lib/main.c</code>可知: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __start_main(<span class="type">long</span> *p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> argc = p[<span class="number">0</span>];</span><br><span class="line"><span class="type">char</span> **argv = (<span class="type">void</span> *)(p+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(main(argc, argv));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <code>p</code>是传递的栈指针<code>sp</code>, 因此<code>argc</code>会被置为栈指针当前指向的数据, 而根据前述分析可知, <code>argc</code>是存放于<code>a0</code>寄存器的, 因此后续使用<code>argc</code>时报错, 这是栈分布于C程序标准不一致导致的。</li><li>修改os思路<br>因此，需要将os中初始化栈分布相关的代码进行修改， 使之符合C语言的约定， 实际上我们要修改的代码位于：<code>os/src/task/process.rs</code>中的<code>pub fn exec(self: &amp;Arc&lt;Self&gt;, elf_data: &amp;[u8], args: Vec&lt;String&gt;)</code><br>修改内存分布为上图的形式, 次过程不难, 具体代码实现可参考: <a href="../os/src/task/process.rs#L184">我的实现</a></li><li>小bug修改: 去除文件名<br>观察<code>hello.c</code>源码: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line"><span class="type">char</span> greeting[<span class="number">11</span>] = <span class="string">&quot;my name is &quot;</span>;</span><br><span class="line"><span class="type">char</span> error[<span class="number">15</span>] = <span class="string">&quot;Incorrect argc\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">1</span>) &#123;</span><br><span class="line">    write(<span class="number">1</span>, error, <span class="number">15</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(argv[<span class="number">0</span>][len] != <span class="number">0</span>) &#123;</span><br><span class="line">    len++;</span><br><span class="line">&#125;</span><br><span class="line">write(<span class="number">1</span>, greeting, <span class="number">11</span>);</span><br><span class="line">write(<span class="number">1</span>, argv[<span class="number">0</span>], len);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 可知其<code>argv[0]</code>应当为命令行输入的参数, 而非约定中的程序名, 因此需要在系统调用中对<code>args</code>中去除第一个函数名参数:<br> 具体代码实现可参考: <a href="../os/src/syscall/process.rs#L74">我的实现</a></li><li>运行结果<br>再次执行<code>make run CHAPTER=8 BASE=2</code>后运行<code>hello</code>程序 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rust user shell</span><br><span class="line">&gt;&gt; hello xwd</span><br><span class="line">my name is xwdShell: Process 2 exited with code 0</span><br></pre></td></tr></table></figure> <img src="/../../../images/lab1-result.png" alt="结果截图"><br></li></ol><h1 id="2-问答作业"><a href="#2-问答作业" class="headerlink" title="2 问答作业"></a>2 问答作业</h1><ol><li><p>elf 文件和 bin 文件有什么区别？<br><code>elf</code>是包含符号信息的二进制文件, <code>bin</code>文件是剥离了二进制信息的符号文件<br>以下是各个命令的输出</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ file elf/ch6_file0.elf</span><br><span class="line">elf/ch6_file0.elf: ELF 64-bit LSB executable, UCB RISC-V, RVC, double-float ABI, version 1 (SYSV), statically linked, stripped</span><br><span class="line">$ file bin/ch6_file0.bin</span><br><span class="line">bin/ch6_file0.bin: data</span><br></pre></td></tr></table></figure><p> <code>elf</code>文件包含的信息有:</p><ul><li>类型: ELF 64-bit LSB executable</li><li>RISC-V: 表示这是一个 RISC-V 架构的可执行文件。</li><li>RVC: 表示该文件使用了 RISC-V 的压缩指令集。</li><li>double-float ABI: 表示该文件使用了双精度浮点数 ABI（Application Binary Interface）。</li><li>版本 1 (SYSV): 表示该 ELF 文件采用了 SYSV 版本 1 的格式。</li><li>静态链接: 表示该文件是静态链接的，即所有的库和依赖在编译时就被链接进来了。</li><li>stripped: 表示该文件已经被剥离了符号信息。<br> <code>bin</code>文件包含的信息有:</li><li>“data” 表示这是一个二进制数据文件</li></ul><p> 总而言之, <code>elf</code>包含了程序的代码、数据、和用于指示操作系统如何运行程序的元数据, <code>bin</code>是纯二进制格式的文件，不包含元数据</p><p> 因此<code>riscv64-linux-musl-objdump -ld ch6_file0.bin &gt; debug.S</code>命令会报错:<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ riscv64-linux-musl-objdump -ld ch6_file0.bin &gt; debug.S</span><br><span class="line">riscv64-linux-musl-objdump: ch6_file0.bin: file format not recognized</span><br></pre></td></tr></table></figure><br> 而<code>riscv64-linux-musl-objdump -ld ch6_file0.elf &gt; debug.S</code>可以得到反汇编文件<code>debug.S</code></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;练习实验书&lt;/strong&gt;: &lt;a href=&quot;https://scpointer.github.io/rcore2oscomp/docs/lab1/intro.html&quot;&gt;https://scpointer.github.io/rcore2oscomp/</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>2023开源操作系统训练营二阶段:rCore chapter3练习</title>
    <link href="http://example.com/2023/12/11/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/%E9%98%B6%E6%AE%B52-rCore-chapter3%E7%BB%83%E4%B9%A0/"/>
    <id>http://example.com/2023/12/11/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6-2023%E7%A7%8B%E5%86%AC%E5%AD%A3%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5/%E9%98%B6%E6%AE%B5%E4%BA%8C/%E9%98%B6%E6%AE%B52-rCore-chapter3%E7%BB%83%E4%B9%A0/</id>
    <published>2023-12-11T14:54:06.000Z</published>
    <updated>2023-12-23T18:05:42.550Z</updated>
    
    <content type="html"><![CDATA[<p><strong>练习实验书</strong>: <a href="https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter3/5exercise.html">https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter3/5exercise.html</a></p><h1 id="1-实现的功能描述"><a href="#1-实现的功能描述" class="headerlink" title="1 实现的功能描述"></a>1 实现的功能描述</h1><ol><li>在<code>task.rs</code>中的<code>TaskControlBlock</code>结构体增加了<code>sys_call_times</code>数组, 用于记录当前<code>task</code>中各个系统调用的次数</li><li>每次执行系统调用时, 将全局变量<code>TASK_MANAGER</code>中当前任务<code>current_task</code>对应的<code>TaskControlBlock</code>结构体的系统调用记录自增</li><li>为<code>TaskManager</code>实现<code>get_sys_call_times</code>方法, 获取当前任务<code>current_task</code>对应的<code>TaskControlBlock</code>结构体的系统调用数组的拷贝</li><li>完成<code>process.rs</code>的<code>sys_task_info</code>, 调用<code>get_sys_call_times</code>和<code>get_time_ms</code>获取<code>TaskInfo</code>结构体的<code>syscall_times</code>和<code>time</code>部分, <code>status</code>部分设为<code>Running</code></li></ol><h1 id="2-简答作业"><a href="#2-简答作业" class="headerlink" title="2 简答作业"></a>2 简答作业</h1><h2 id="2-1-简答作业第一部分"><a href="#2-1-简答作业第一部分" class="headerlink" title="2.1 简答作业第一部分"></a>2.1 简答作业第一部分</h2><p>正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容 (运行 Rust 三个 bad 测例 (ch2b_bad_*.rs) ， 注意在编译时至少需要指定 LOG&#x3D;ERROR 才能观察到内核的报错信息) ， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。</p><p>Rustsbi 版本为: 0.2.0-alpha.2</p><p>出现报错: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[kernel] PageFault <span class="keyword">in</span> application, bad addr = 0x0, bad instruction = 0x804003c4, kernel killed it.</span><br><span class="line">[kernel] IllegalInstruction <span class="keyword">in</span> application, kernel killed it.</span><br><span class="line">[kernel] IllegalInstruction <span class="keyword">in</span> application, kernel killed it.</span><br></pre></td></tr></table></figure><p><code>ch2b_bad_address.rs</code> 由于除0错误触发异常退出<br><code>ch2b_bad_instructions.rs</code> 在用户态非法使用指令<code>sret</code><br><code>ch2b_bad_register.rs</code> 在用户态非法使用指令<code>csrr</code></p><h2 id="2-2-简答作业第二部分"><a href="#2-2-简答作业第二部分" class="headerlink" title="2.2 简答作业第二部分"></a>2.2 简答作业第二部分</h2><p>深入理解 trap.S 中两个函数 __alltraps 和 __restore 的作用，并回答如下问题:</p><h3 id="2-2-1-L40：刚进入-restore-时，a0-代表了什么值。请指出-restore-的两种使用情景。"><a href="#2-2-1-L40：刚进入-restore-时，a0-代表了什么值。请指出-restore-的两种使用情景。" class="headerlink" title="2.2.1 L40：刚进入 __restore 时，a0 代表了什么值。请指出 __restore 的两种使用情景。"></a>2.2.1 L40：刚进入 __restore 时，a0 代表了什么值。请指出 __restore 的两种使用情景。</h3><blockquote><ol><li>刚进入 __restore 时，a0 代表了系统调用的第一个参数</li><li>__restore 的作用包括:</li></ol><ul><li>从系统调用和异常返回时, 恢复要返回的用户态的上下文信息</li><li>任务切换时, 恢复要切换的任务的上下文信息</li></ul></blockquote><h3 id="2-2-2-L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。"><a href="#2-2-2-L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。" class="headerlink" title="2.2.2 L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。"></a>2.2.2 L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ld t0, 32*8(sp) <span class="comment"># 内核栈 32*8(sp) 处存储了原 sstatus 寄存器的值, 将其读取到 t0</span></span><br><span class="line">ld t1, 33*8(sp) <span class="comment"># 内核栈 32*8(sp) 处存储了原 sepc 寄存器的值, 将其读取到 t1</span></span><br><span class="line">ld t2, 2*8(sp) <span class="comment"># 内核栈 32*8(sp) 处存储了原 sscratch 寄存器的值, 将其读取到 t2</span></span><br><span class="line">csrw sstatus, t0 <span class="comment"># 将 t0中原 sstatus 寄存器的值读取到 sstatus</span></span><br><span class="line">csrw sepc, t1 <span class="comment"># 将 t0中原 sepc 寄存器的值读取到 sepc</span></span><br><span class="line">csrw sscratch, t2 <span class="comment"># 将 t0中原 sscratch 寄存器的值读取到 sscratch</span></span><br></pre></td></tr></table></figure><h3 id="2-2-3-L50-L56：为何跳过了-x2-和-x4？"><a href="#2-2-3-L50-L56：为何跳过了-x2-和-x4？" class="headerlink" title="2.2.3 L50-L56：为何跳过了 x2 和 x4？"></a>2.2.3 L50-L56：为何跳过了 x2 和 x4？</h3><ol><li>跳过<code>x2</code>是因为<code>x2</code>对应的用户栈指针保存到了sscratch寄存器, 不需要从内核栈中进行恢复</li><li>跳过<code>x4</code>是因为并没有使用它, 所以无需恢复</li></ol><h3 id="2-2-4-L60：该指令之后，sp-和-sscratch-中的值分别有什么意义？"><a href="#2-2-4-L60：该指令之后，sp-和-sscratch-中的值分别有什么意义？" class="headerlink" title="2.2.4 L60：该指令之后，sp 和 sscratch 中的值分别有什么意义？"></a>2.2.4 L60：该指令之后，sp 和 sscratch 中的值分别有什么意义？</h3><p><code>sp</code>指向用户栈, <code>sscratch</code>指向内核栈</p><h3 id="2-2-5-restore：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？"><a href="#2-2-5-restore：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？" class="headerlink" title="2.2.5 __restore：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？"></a>2.2.5 __restore：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？</h3><p><code>sret</code>后发生了状态切换, 执行该指令后, PC设置为 <code>sepc</code> 寄存器的值。<code>sepc</code> 存储着产生中断或异常前的指令地址，因此这实现了到原始代码的返回。</p><h3 id="2-2-6-L13：该指令之后，sp-和-sscratch-中的值分别有什么意义？"><a href="#2-2-6-L13：该指令之后，sp-和-sscratch-中的值分别有什么意义？" class="headerlink" title="2.2.6 L13：该指令之后，sp 和 sscratch 中的值分别有什么意义？"></a>2.2.6 L13：该指令之后，sp 和 sscratch 中的值分别有什么意义？</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">csrrw sp, sscratch, sp</span><br></pre></td></tr></table></figure><p><code>sp</code>, <code>sscratch</code>寄存器的内容被交换, <code>sp</code>保存了原<code>sscratch</code>中的内核栈指针, <code>sscratch</code>保存了原<code>sp</code>中的用户栈栈指针</p><h3 id="2-2-7-从-U-态进入-S-态是哪一条指令发生的？"><a href="#2-2-7-从-U-态进入-S-态是哪一条指令发生的？" class="headerlink" title="2.2.7 从 U 态进入 S 态是哪一条指令发生的？"></a>2.2.7 从 U 态进入 S 态是哪一条指令发生的？</h3><p><code>ecall</code>指令</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;练习实验书&lt;/strong&gt;: &lt;a href=&quot;https://learningos.cn/rCore-Tutorial-Guide-2023A/chapter3/5exercise.html&quot;&gt;https://learningos.cn/rCore-Tu</summary>
      
    
    
    
    <category term="训练营笔记" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/"/>
    
    <category term="清华大学开源操作系统训练营2023" scheme="http://example.com/categories/%E8%AE%AD%E7%BB%83%E8%90%A5%E7%AC%94%E8%AE%B0/%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A52023/"/>
    
    
    <category term="OS" scheme="http://example.com/tags/OS/"/>
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="riscv" scheme="http://example.com/tags/riscv/"/>
    
    <category term="Rust" scheme="http://example.com/tags/Rust/"/>
    
  </entry>
  
</feed>
