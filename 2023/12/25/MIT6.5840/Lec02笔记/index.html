<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="课程主页: https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.824&#x2F;schedule.html 这节课主要是对分布式整体的概念和Go的一些相关介绍, 包括线程、RPC、同步原语、管道等，相对简单， 简单记录一下， 顺带附上我进行Lab1实验时相关知识的补充 1 同步原语课程举了一个投票的例子: 12345678910111213141516171819202122232425262728">
<meta property="og:type" content="article">
<meta property="og:title" content="MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)">
<meta property="og:url" content="http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="ToniBlog">
<meta property="og:description" content="课程主页: https:&#x2F;&#x2F;pdos.csail.mit.edu&#x2F;6.824&#x2F;schedule.html 这节课主要是对分布式整体的概念和Go的一些相关介绍, 包括线程、RPC、同步原语、管道等，相对简单， 简单记录一下， 顺带附上我进行Lab1实验时相关知识的补充 1 同步原语课程举了一个投票的例子: 12345678910111213141516171819202122232425262728">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-12-25T09:01:51.000Z">
<meta property="article:modified_time" content="2024-01-15T18:04:01.774Z">
<meta property="article:author" content="GFX9">
<meta property="article:tag" content="分布式系统">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/flash_dc.png">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/flash_dc.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/flash_dc.png">
        
      
    
    <!-- title -->
    <title>MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
<meta name="generator" content="Hexo 7.0.0"><link rel="alternate" href="/atom.xml" title="ToniBlog" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2023/12/27/%E6%95%B0%E6%8D%AE%E5%BA%93/sql%E5%AD%A6%E4%B9%A0/SQL%E8%BF%9B%E9%98%B6-1/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2023/12/24/MIT6.5840/Lec01%E7%AC%94%E8%AE%B0/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&text=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&title=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&is_video=false&description=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)&body=Check out this article: http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&title=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&title=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&title=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&title=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&name=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&t=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.</span> <span class="toc-text">1 同步原语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-1-%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">1.1 锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-2-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">1.2 条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-WaitGroup%E5%8D%8F%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">3.1.</span> <span class="toc-text">1.3 WaitGroup协程同步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%80%9A%E9%81%93"><span class="toc-number">4.</span> <span class="toc-text">2 通道</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%A1%88%E4%BE%8B"><span class="toc-number">4.1.</span> <span class="toc-text">2.1 案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">4.2.</span> <span class="toc-text">2.2 带缓冲的通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-SELECT%E5%92%8C%E9%80%9A%E9%81%93"><span class="toc-number">4.3.</span> <span class="toc-text">2.3 SELECT和通道</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Context%E6%8E%A7%E5%88%B6%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">5.</span> <span class="toc-text">3 Context控制上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Context-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.1.</span> <span class="toc-text">3.1 Context 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%93%8D%E7%BA%B5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">3.2 操纵上下文的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%A1%88%E4%BE%8B"><span class="toc-number">5.2.</span> <span class="toc-text">3.3 案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">3.3.1 简单案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E5%A4%8D%E6%9D%82%E6%A1%88%E4%BE%8Bsocks5%E4%BB%A3%E7%90%86"><span class="toc-number">5.2.2.</span> <span class="toc-text">3.3.2 复杂案例socks5代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.3.</span> <span class="toc-text">3.4 注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-RPC"><span class="toc-number">6.</span> <span class="toc-text">4 RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-number">6.1.</span> <span class="toc-text">4.1 服务器端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">6.2.</span> <span class="toc-text">4.2 客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%BC%BA%E7%82%B9"><span class="toc-number">6.3.</span> <span class="toc-text">4.3 缺点</span></a></li></ol></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">GFX9</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-12-25T09:01:51.000Z" class="dt-published" itemprop="datePublished">2023-12-25</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">CS课程笔记</a> › <a class="category-link" href="/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/">MIT6.5840(6.824) 2023</a> › <a class="category-link" href="/categories/CS%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/MIT6-5840-6-824-2023/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Go/" rel="tag">Go</a>, <a class="p-category" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" rel="tag">分布式系统</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>课程主页: <a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.824/schedule.html">https://pdos.csail.mit.edu/6.824/schedule.html</a></p>
<p>这节课主要是对分布式整体的概念和<code>Go</code>的一些相关介绍, 包括线程、RPC、同步原语、管道等，相对简单， 简单记录一下， 顺带附上我进行Lab1实验时相关知识的补充</p>
<h1 id="1-同步原语"><a href="#1-同步原语" class="headerlink" title="1 同步原语"></a>1 同步原语</h1><p>课程举了一个投票的例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	finished := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">	cond := sync.NewCond(&amp;mu)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			vote := requestVote()</span><br><span class="line">			mu.Lock()</span><br><span class="line">			<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">			<span class="keyword">if</span> vote &#123;</span><br><span class="line">				count++</span><br><span class="line">			&#125;</span><br><span class="line">			finished++</span><br><span class="line">			cond.Broadcast()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">for</span> count &lt; <span class="number">5</span> &amp;&amp; finished != <span class="number">10</span> &#123;</span><br><span class="line">		cond.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> count &gt;= <span class="number">5</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;received 5+ votes!&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;lost&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestVote</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line">	<span class="keyword">return</span> rand.Int() % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-1-锁"><a href="#1-1-锁" class="headerlink" title="1.1 锁"></a>1.1 <strong>锁</strong></h1><p>整体而言<code>go</code>中锁的语法和<code>C/C++</code>区别不大, 但这里介绍一下<code>defer</code>:</p>
<ul>
<li><code>defer</code> 语句后面跟着的是一个函数调用，这个调用不会立即执行。而是延迟到包含它的函数执行完毕时才执行</li>
<li>如果有多个 <code>defer</code> 语句，它们的调用顺序是后进先出的，即最后一个 <code>defer</code> 的函数调用将会第一个被执行</li>
<li><strong>重点:<code>defer</code> 的调用不会在每次循环结束时执行，而是会在包围 defer 的函数返回时才执行</strong> &#x3D;&gt; 如果有锁需要释放的话, 需要在循环体内手动释放?</li>
</ul>
<h1 id="1-2-条件变量"><a href="#1-2-条件变量" class="headerlink" title="1.2 条件变量"></a>1.2 <strong>条件变量</strong></h1><p>还是相同的例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	finished := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">	cond := sync.NewCond(&amp;mu)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			vote := requestVote()</span><br><span class="line">			mu.Lock()</span><br><span class="line">			<span class="keyword">defer</span> mu.Unlock()</span><br><span class="line">			<span class="keyword">if</span> vote &#123;</span><br><span class="line">				count++</span><br><span class="line">			&#125;</span><br><span class="line">			finished++</span><br><span class="line">			cond.Broadcast()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	mu.Lock()</span><br><span class="line">	<span class="keyword">for</span> count &lt; <span class="number">5</span> &amp;&amp; finished != <span class="number">10</span> &#123;</span><br><span class="line">		cond.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> count &gt;= <span class="number">5</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;received 5+ votes!&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;lost&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestVote</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line">	<span class="keyword">return</span> rand.Int() % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没啥好讲的…<br>条件变量的三个主要方法是：</p>
<ul>
<li><code>Wait</code>：调用这个方法会阻塞调用协程，直到其他协程在相同的条件变量上调用 Signal 或 Broadcast。</li>
<li><code>Signal</code>：唤醒等待该条件变量的一个协程（如果存在的话）。</li>
<li><code>Broadcast</code>：唤醒等待该条件变量的所有协程。</li>
</ul>
<h2 id="1-3-WaitGroup协程同步"><a href="#1-3-WaitGroup协程同步" class="headerlink" title="1.3 WaitGroup协程同步"></a>1.3 <code>WaitGroup</code>协程同步</h2><p><code>sync.WaitGroup </code>用于等待一组协程的完成。一个 <code>WaitGroup</code> 等待一系列的事件，主要的用法包括三个方法：</p>
<ul>
<li><code>Add</code> 方法: 在启动协程之前，使用 <code>Add</code> 方法来设置要等待的事件数量。通常这个值设置为即将启动的协程的数量。</li>
<li><code>Done</code> 方法: 当协程的工作完成时，调用 <code>Done</code> <code>方法。Done</code> 方法减少 <code>WaitGroup</code> 的内部计数器，通常等价于 <code>Add(-1)</code>。</li>
<li><code>Wait</code> 方法: 使用 Wait 方法来阻塞，直到所有的事件都已通过调用 <code>Done</code> 方法来报告完成。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设我们有三个并行的任务需要执行</span></span><br><span class="line">    tasks := <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Add方法来设置WaitGroup的计数器</span></span><br><span class="line">    wg.Add(tasks)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= tasks; i++ &#123;</span><br><span class="line">        <span class="comment">// 启动一个协程</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done() <span class="comment">// 确保在协程的末尾调用Done来递减计数器</span></span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟耗时任务</span></span><br><span class="line">            fmt.Printf(<span class="string">&quot;Task %d finished\n&quot;</span>, i)</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Wait会阻塞，直到WaitGroup的计数器减为0</span></span><br><span class="line">    wg.Wait()</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>:</p>
<ol>
<li>不要复制 <code>WaitGroup</code>。如果需要将 WaitGroup 传递给函数，应使用指针。</li>
<li>避免在协程内部调用 <code>Add</code> 方法，因为这可能会导致计数器不准确。最好在启动协程之前添加所需的计数。</li>
<li>使用 <code>Done</code> 方法是减少 <code>WaitGroup</code> 计数器的推荐方式，它等价于 <code>Add(-1)</code>。</li>
</ol>
<h1 id="2-通道"><a href="#2-通道" class="headerlink" title="2 通道"></a>2 通道</h1><h2 id="2-1-案例"><a href="#2-1-案例" class="headerlink" title="2.1 案例"></a>2.1 案例</h2><p>还是投票…<br><code>go</code>的通道可以实现无锁的并发访问, 核心在于其保证通道写入在不同协程间不会冲突</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;math/rand&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rand.Seed(time.Now().UnixNano())</span><br><span class="line"></span><br><span class="line">	count := <span class="number">0</span></span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			ch &lt;- requestVote()</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		v := &lt;-ch</span><br><span class="line">		<span class="keyword">if</span> v &#123;</span><br><span class="line">			count += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> count &gt;= <span class="number">5</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;received 5+ votes!&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">println</span>(<span class="string">&quot;lost&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestVote</span><span class="params">()</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	time.Sleep(time.Duration(rand.Intn(<span class="number">100</span>)) * time.Millisecond)</span><br><span class="line">	<span class="keyword">return</span> rand.Int()%<span class="number">2</span> == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-带缓冲的通道"><a href="#2-2-带缓冲的通道" class="headerlink" title="2.2 带缓冲的通道"></a>2.2 带缓冲的通道</h2><p>另外, 通道还支持带缓冲:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufferedCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">2</span>) <span class="comment">// 缓冲大小为2</span></span><br></pre></td></tr></table></figure>
<p>两种通道区别如下:</p>
<ul>
<li>不带缓冲的通道在发送操作和接收操作之间进行同步：发送会阻塞，直到有另一个协程来接收数据；接收会阻塞，直到有另一个协程发送数据。</li>
<li>带缓冲的通道有一个固定大小的缓冲区。发送操作只在缓冲区满时阻塞，接收操作只在缓冲区空时阻塞。</li>
</ul>
<h2 id="2-3-SELECT和通道"><a href="#2-3-SELECT和通道" class="headerlink" title="2.3 SELECT和通道"></a>2.3 SELECT和通道</h2><p><code>select</code>允许协程在多个通道操作上等待。select 会阻塞，直到其中一个通道操作可以执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> msg := &lt;-ch1:</span><br><span class="line">    <span class="comment">// 从ch1接收消息</span></span><br><span class="line"><span class="keyword">case</span> ch2 &lt;- msg:</span><br><span class="line">    <span class="comment">// 发送消息到ch2</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果以上都不可执行，则执行默认操作（非阻塞）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-Context控制上下文"><a href="#3-Context控制上下文" class="headerlink" title="3 Context控制上下文"></a>3 Context控制上下文</h1><h2 id="3-1-Context-接口"><a href="#3-1-Context-接口" class="headerlink" title="3.1 Context 接口"></a>3.1 Context 接口</h2><p><code>Context 类型</code>用于创建和操纵上下文的函数,用于定义截止日期、取消信号以及其他请求范围的值的接口。它设计用来传递给请求范围的数据、取消信号和截止时间到不同的协程中，以便于管理它们的生命周期。先来看<code>Context 接口</code>:<br><code>Context</code> 接口定义了四个方法：</p>
<ol>
<li><code>Deadline</code>：返回 <code>Context</code> 被取消的时间，也就是完成工作的截止时间（如果有的话）。</li>
<li><code>Done</code>：返回一个 <code>Channel</code>，这个 <code>Channel</code> 会在当前工作应当被取消时关闭。</li>
<li><code>Err</code>：返回 <code>Context</code> 结束的原因，它只会在 <code>Done</code> 返回的 <code>Channel</code> 被关闭后返回非空值。</li>
<li><code>Value</code>：从 <code>Context</code> 中检索键对应的值。</li>
</ol>
<h3 id="3-2-操纵上下文的函数"><a href="#3-2-操纵上下文的函数" class="headerlink" title="3.2 操纵上下文的函数"></a>3.2 操纵上下文的函数</h3><p><code>context</code> 包提供了几个用于创建和操纵上下文的函数：</p>
<ol>
<li><code>context.Background</code>：返回一个空的 <code>Context</code>。这个 <code>Context</code> 通常被用作整个程序或请求的顶层 <code>Context</code>。</li>
<li><code>context.TODO</code>：不确定应该使用哪个 <code>Context</code> 或者还没有可用的 <code>Context</code> 时，使用这个函数。这在编写初始化代码或者不确定要使用什么上下文时特别有用。</li>
<li><code>context.WithCancel</code>：创建一个新的 <code>Context</code>，这个 <code>Context</code> 会包含一个取消函数，可用于取消这个 <code>Context</code> 及其子树。</li>
<li><code>context.WithDeadline</code>：创建一个新的 <code>Context</code>，这个 <code>Context</code> 会在指定的时间到达时自动取消。</li>
<li><code>context.WithTimeout</code>：创建一个新的 <code>Context</code>，这个 <code>Context</code> 会在指定的时间段后自动取消。</li>
</ol>
<h2 id="3-3-案例"><a href="#3-3-案例" class="headerlink" title="3.3 案例"></a>3.3 案例</h2><h3 id="3-3-1-简单案例"><a href="#3-3-1-简单案例" class="headerlink" title="3.3.1 简单案例"></a>3.3.1 简单案例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operation</span><span class="params">(ctx context.Context, duration time.Duration)</span></span> &#123;</span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(duration): <span class="comment">// 模拟一个耗时操作</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;Operation done.&quot;</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 检测 context 的取消事件</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;Operation canceled:&quot;</span>, ctx.Err())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个可取消的 context</span></span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 在一个新的协程中运行 operation 函数</span></span><br><span class="line">	<span class="keyword">go</span> operation(ctx, <span class="number">5</span>*time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 模拟在 operation 运行一段时间后取消操作</span></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	cancel() <span class="comment">// 取消 context</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 给 operation 一些时间来处理取消事件</span></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个案例中, 将<code>ctx</code>显式传递给在子协程, 使其可以受外部的协程控制。</p>
<h3 id="3-3-2-复杂案例socks5代理"><a href="#3-3-2-复杂案例socks5代理" class="headerlink" title="3.3.2 复杂案例socks5代理"></a>3.3.2 复杂案例<code>socks5代理</code></h3><p>这里给出一个<code>字节跳动后端青训营</code>实现的<code>socks5代理</code>中对<code>context</code> 的使用, 完整代码看<a target="_blank" rel="noopener" href="https://github.com/wangkechun/go-by-example/tree/master/proxy/v4">这里</a>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_, _ = io.Copy(dest, reader)</span><br><span class="line">	cancel()</span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	_, _ = io.Copy(conn, dest)</span><br><span class="line">	cancel()</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">&lt;-ctx.Done()</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>任务需求</strong>:<br>有两个 goroutine 分别用于从客户端读取数据并写入目的端，以及从目的端读取数据并写入客户端, 要求一旦有一个方向的拷贝操作出现错误, 将另一个操作也取消</p>
</blockquote>
<ul>
<li>方案:使用<code>WithCancel</code>和<code>&lt;-ctx.Done()</code>:</li>
<li>问题？我第一次看到这个代码时， 有这样的问题<br><code>ctx</code>并没有被显式地传递给2个goroutine, 2个<code>goroutine</code>调用<code>cancel</code>取消的是<code>WithCancel</code>返回的<code>ctx</code>, 而不是自己, 所以这为什么能工作?</li>
<li>答案:<br><code>cancel</code> 函数与 <code>ctx</code> 相关联，而 <code>cancel</code> 被闭包捕获并在多个 <code>goroutine</code> 中使用。这就是为什么调用<code> cancel()</code> 会影响所有这些 goroutine 的原因，不管 <code>ctx</code> 是否被显式传递。这种行为是 <code>context</code> 包设计的一部分，允许协调不同 <code>goroutine</code> 之间的取消事件。cancel() 被调用时会取消 <code>ctx</code> 上下文，而与这个 <code>ctx</code> 相关联的所有操作（在这个例子中是两个 <code>io.Copy</code> 调用）都会接收到取消通知，即使它们在不同的 <code>goroutine</code> 中执行，且 <code>ctx</code> 没有显式地传递给它们。</li>
</ul>
<h2 id="3-4-注意事项"><a href="#3-4-注意事项" class="headerlink" title="3.4 注意事项"></a>3.4 注意事项</h2><ul>
<li>不应该把 <code>Context</code> 存储在结构体中，它应该通过参数传递。</li>
<li><code>Context</code> 是协程安全的，你可以把一个 <code>Context</code> 传递给多个协程，每个协程都可以安全地读取和监听它。</li>
<li>一旦一个 <code>Context</code> 被取消，它的所有子 <code>Context</code> 都会被取消。</li>
<li><code>Context</code> 的 <code>Value</code> 方法应该被用于传递请求范围的数据，而不是函数的可选参数。</li>
</ul>
<p><code>Context</code> 在处理跨越多个协程的取消信号、超时以及传递请求范围数据时起到了关键作用，是 Go 并发编程中的重要组件。</p>
<h1 id="4-RPC"><a href="#4-RPC" class="headerlink" title="4 RPC"></a>4 RPC</h1><blockquote>
<p>这本来是在<code>Lab 1</code>过程中补的知识, 但介于这里写了这么多<code>Go</code>, 就放在一起了</p>
</blockquote>
<p>Go 标准库中的 <code>net/rpc</code> 包提供了创建 <code>RPC</code> 客户端和服务器的机制。<br>RPC 允许客户端程序调用在服务器上运行的程序的函数或方法，就好像它是本地可用的一样。客户端和服务器之间的通信通常是透明的，客户端程序仅需知道需要调用的远程方法和必须提供的参数。<br> <code>net/rpc</code> 包使用了 Go 的编码和解码接口，允许使用 <code>encoding/gob</code> 包来序列化和反序列化数据（尽管也可以使用其他编码，如 <code>JSON</code>）。<code>RPC</code> 调用默认是通过 <code>TCP</code> 或者 <code>UNIX</code> 套接字传输的，但是你可以实现自己的传输方式。</p>
<h2 id="4-1-服务器端"><a href="#4-1-服务器端" class="headerlink" title="4.1 服务器端"></a>4.1 服务器端</h2><p>要创建一个 <code>Go RPC</code> 服务器，你需要创建一些方法，这些方法必须满足以下条件：</p>
<ol>
<li>方法是导出的（首字母大写）。<del>Lab1 被坑惨了</del></li>
<li>方法有两个参数，都是导出类型或内建类型。</li>
<li>方法的第二个参数是指针, 相当于写出。</li>
<li>方法返回一个 <code>error</code> 类型。</li>
</ol>
<p>然后，将这个类型的实例注册为 RPC 服务：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Arith <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span></span> Multiply(args *Args, reply *<span class="type">int</span>) <span class="type">error</span> &#123;</span><br><span class="line">    *reply = args.A * args.B</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arith := <span class="built_in">new</span>(Arith)</span><br><span class="line">    rpc.Register(arith)</span><br><span class="line">    rpc.HandleHTTP()</span><br><span class="line">    err := http.ListenAndServe(<span class="string">&quot;:1234&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-客户端"><a href="#4-2-客户端" class="headerlink" title="4.2 客户端"></a>4.2 客户端</h2><p>客户端需要使用 <code>rpc.Dial</code> 函数连接到 RPC 服务器，然后可以通过 <code>Call</code> 方法进行同步调用或 <code>Go</code> 方法进行异步调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">client, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;server address&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;dialing:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Synchronous call</span></span><br><span class="line">args := &amp;Args&#123;<span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"><span class="keyword">var</span> reply <span class="type">int</span></span><br><span class="line">err = client.Call(<span class="string">&quot;Arith.Multiply&quot;</span>, args, &amp;reply)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">&quot;arith error:&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Arith: %d*%d=%d&quot;</span>, args.A, args.B, reply)</span><br></pre></td></tr></table></figure>

<h2 id="4-3-缺点"><a href="#4-3-缺点" class="headerlink" title="4.3 缺点"></a>4.3 缺点</h2><p><code>net/rpc</code> 包的文档提到，该包已经被标记为<a target="_blank" rel="noopener" href="https://golang.org/s/go1.7-rpc">“冻结”（frozen）</a>并不推荐使用。这意味着该包不会有新的发展，尽管它仍然是可用的。因此，应该考虑使用更现代的解决方案，如 <a target="_blank" rel="noopener" href="https://grpc.io/">gRPC</a>，它支持多种语言，提供了更复杂的特性，例如双向流和集成认证。</p>

  </div>
</article>


    <div class="blog-post-comments">
        <div id="utterances_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>


        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/about/">关于</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
          <li><a href="/categories/">分类</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD"><span class="toc-number">1.</span> <span class="toc-text">1 同步原语</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-1-%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">1.1 锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-2-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">1.2 条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-WaitGroup%E5%8D%8F%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">3.1.</span> <span class="toc-text">1.3 WaitGroup协程同步</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E9%80%9A%E9%81%93"><span class="toc-number">4.</span> <span class="toc-text">2 通道</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%A1%88%E4%BE%8B"><span class="toc-number">4.1.</span> <span class="toc-text">2.1 案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%B8%A6%E7%BC%93%E5%86%B2%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">4.2.</span> <span class="toc-text">2.2 带缓冲的通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-SELECT%E5%92%8C%E9%80%9A%E9%81%93"><span class="toc-number">4.3.</span> <span class="toc-text">2.3 SELECT和通道</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Context%E6%8E%A7%E5%88%B6%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">5.</span> <span class="toc-text">3 Context控制上下文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Context-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.1.</span> <span class="toc-text">3.1 Context 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%93%8D%E7%BA%B5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">3.2 操纵上下文的函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E6%A1%88%E4%BE%8B"><span class="toc-number">5.2.</span> <span class="toc-text">3.3 案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">3.3.1 简单案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E5%A4%8D%E6%9D%82%E6%A1%88%E4%BE%8Bsocks5%E4%BB%A3%E7%90%86"><span class="toc-number">5.2.2.</span> <span class="toc-text">3.3.2 复杂案例socks5代理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.3.</span> <span class="toc-text">3.4 注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-RPC"><span class="toc-number">6.</span> <span class="toc-text">4 RPC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF"><span class="toc-number">6.1.</span> <span class="toc-text">4.1 服务器端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">6.2.</span> <span class="toc-text">4.2 客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E7%BC%BA%E7%82%B9"><span class="toc-number">6.3.</span> <span class="toc-text">4.3 缺点</span></a></li></ol></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&text=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&title=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&is_video=false&description=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)&body=Check out this article: http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&title=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&title=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&title=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&title=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&name=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2023/12/25/MIT6.5840/Lec02%E7%AC%94%E8%AE%B0/&t=MIT6.5840(6.824) Lec02笔记: Go: 同步原语、通道、Context和RPC)"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2024
    GFX9
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/categories/">分类</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->

  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script>
  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

    <script type="text/javascript">
      var utterances_repo = 'GFX9/GFX9.github.io';
      var utterances_issue_term = 'pathname';
      var utterances_label = 'Comment';
      var utterances_theme = 'github-dark';

      (function(){
          var script = document.createElement('script');

          script.src = 'https://utteranc.es/client.js';
          script.setAttribute('repo', utterances_repo);
          script.setAttribute('issue-term', 'pathname');
          script.setAttribute('label', utterances_label);
          script.setAttribute('theme', utterances_theme);
          script.setAttribute('crossorigin', 'anonymous');
          script.async = true;
          (document.getElementById('utterances_thread')).appendChild(script);
      }());
  </script>

</body>
</html>
